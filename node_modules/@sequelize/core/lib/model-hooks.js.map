{
  "version": 3,
  "sources": ["../src/model-hooks.ts"],
  "sourcesContent": ["import type {\n  AfterAssociateEventData,\n  AssociationOptions,\n  BeforeAssociateEventData,\n} from './associations/index.js';\nimport type { AsyncHookReturn } from './hooks.js';\nimport { HookHandlerBuilder } from './hooks.js';\nimport type { ValidationOptions } from './instance-validator.js';\nimport type { DestroyManyOptions } from './model-repository.types.js';\nimport type {\n  BulkCreateOptions,\n  CountOptions,\n  CreateOptions,\n  DestroyOptions,\n  FindOptions,\n  InstanceDestroyOptions,\n  InstanceRestoreOptions,\n  InstanceUpdateOptions,\n  Model,\n  ModelStatic,\n  RestoreOptions,\n  UpdateOptions,\n  UpsertOptions,\n} from './model.js';\nimport type { SyncOptions } from './sequelize.js';\n\nexport interface ModelHooks<M extends Model = Model, TAttributes = any> {\n  beforeValidate(instance: M, options: ValidationOptions): AsyncHookReturn;\n  afterValidate(instance: M, options: ValidationOptions): AsyncHookReturn;\n  validationFailed(instance: M, options: ValidationOptions, error: unknown): AsyncHookReturn;\n  beforeCreate(attributes: M, options: CreateOptions<TAttributes>): AsyncHookReturn;\n  afterCreate(attributes: M, options: CreateOptions<TAttributes>): AsyncHookReturn;\n  beforeDestroy(instance: M, options: InstanceDestroyOptions): AsyncHookReturn;\n  afterDestroy(instance: M, options: InstanceDestroyOptions): AsyncHookReturn;\n  beforeDestroyMany(instances: M[], options: DestroyManyOptions): AsyncHookReturn;\n  afterDestroyMany(\n    instances: readonly M[],\n    options: DestroyManyOptions,\n    deletedCount: number,\n  ): AsyncHookReturn;\n  beforeRestore(instance: M, options: InstanceRestoreOptions): AsyncHookReturn;\n  afterRestore(instance: M, options: InstanceRestoreOptions): AsyncHookReturn;\n  beforeUpdate(instance: M, options: InstanceUpdateOptions<TAttributes>): AsyncHookReturn;\n  afterUpdate(instance: M, options: InstanceUpdateOptions<TAttributes>): AsyncHookReturn;\n  beforeUpsert(attributes: M, options: UpsertOptions<TAttributes>): AsyncHookReturn;\n  afterUpsert(\n    attributes: [M, boolean | null],\n    options: UpsertOptions<TAttributes>,\n  ): AsyncHookReturn;\n  beforeSave(\n    instance: M,\n    options: InstanceUpdateOptions<TAttributes> | CreateOptions<TAttributes>,\n  ): AsyncHookReturn;\n  afterSave(\n    instance: M,\n    options: InstanceUpdateOptions<TAttributes> | CreateOptions<TAttributes>,\n  ): AsyncHookReturn;\n  beforeBulkCreate(instances: M[], options: BulkCreateOptions<TAttributes>): AsyncHookReturn;\n  afterBulkCreate(\n    instances: readonly M[],\n    options: BulkCreateOptions<TAttributes>,\n  ): AsyncHookReturn;\n  beforeBulkDestroy(options: DestroyOptions<TAttributes>): AsyncHookReturn;\n  afterBulkDestroy(options: DestroyOptions<TAttributes>): AsyncHookReturn;\n  _UNSTABLE_beforeBulkDestroy(options: DestroyOptions<TAttributes>): AsyncHookReturn;\n  _UNSTABLE_afterBulkDestroy(\n    options: DestroyOptions<TAttributes>,\n    deletedCount: number,\n  ): AsyncHookReturn;\n  beforeBulkRestore(options: RestoreOptions<TAttributes>): AsyncHookReturn;\n  afterBulkRestore(options: RestoreOptions<TAttributes>): AsyncHookReturn;\n  beforeBulkUpdate(options: UpdateOptions<TAttributes>): AsyncHookReturn;\n  afterBulkUpdate(options: UpdateOptions<TAttributes>): AsyncHookReturn;\n\n  /**\n   * A hook that is run at the start of {@link Model.count}\n   */\n  beforeCount(options: CountOptions<TAttributes>): AsyncHookReturn;\n\n  /**\n   * A hook that is run before a find (select) query\n   */\n  beforeFind(options: FindOptions<TAttributes>): AsyncHookReturn;\n\n  /**\n   * A hook that is run before a find (select) query, after any `{ include: {all: ...} }` options are expanded\n   *\n   * @deprecated use `beforeFind` instead\n   */\n  beforeFindAfterExpandIncludeAll(options: FindOptions<TAttributes>): AsyncHookReturn;\n\n  /**\n   * A hook that is run before a find (select) query, after all option have been normalized\n   *\n   * @deprecated use `beforeFind` instead\n   */\n  beforeFindAfterOptions(options: FindOptions<TAttributes>): AsyncHookReturn;\n  /**\n   * A hook that is run after a find (select) query\n   */\n  afterFind(\n    instancesOrInstance: readonly M[] | M | null,\n    options: FindOptions<TAttributes>,\n  ): AsyncHookReturn;\n\n  /**\n   * A hook that is run at the start of {@link Model.sync}\n   */\n  beforeSync(options: SyncOptions): AsyncHookReturn;\n\n  /**\n   * A hook that is run at the end of {@link Model.sync}\n   */\n  afterSync(options: SyncOptions): AsyncHookReturn;\n  beforeAssociate(\n    data: BeforeAssociateEventData,\n    options: AssociationOptions<any>,\n  ): AsyncHookReturn;\n  afterAssociate(data: AfterAssociateEventData, options: AssociationOptions<any>): AsyncHookReturn;\n\n  /**\n   * Runs before the definition of the model changes because {@link ModelDefinition#refreshAttributes} was called.\n   */\n  beforeDefinitionRefresh(): void;\n\n  /**\n   * Runs after the definition of the model has changed because {@link ModelDefinition#refreshAttributes} was called.\n   */\n  afterDefinitionRefresh(): void;\n}\n\nexport const validModelHooks: Array<keyof ModelHooks> = [\n  'beforeValidate',\n  'afterValidate',\n  'validationFailed',\n  'beforeCreate',\n  'afterCreate',\n  'beforeDestroy',\n  'afterDestroy',\n  'beforeDestroyMany',\n  'afterDestroyMany',\n  'beforeRestore',\n  'afterRestore',\n  'beforeUpdate',\n  'afterUpdate',\n  'beforeUpsert',\n  'afterUpsert',\n  'beforeSave',\n  'afterSave',\n  'beforeBulkCreate',\n  'afterBulkCreate',\n  'beforeBulkDestroy',\n  'afterBulkDestroy',\n  '_UNSTABLE_beforeBulkDestroy',\n  '_UNSTABLE_afterBulkDestroy',\n  'beforeBulkRestore',\n  'afterBulkRestore',\n  'beforeBulkUpdate',\n  'afterBulkUpdate',\n  'beforeCount',\n  'beforeFind',\n  'beforeFindAfterExpandIncludeAll',\n  'beforeFindAfterOptions',\n  'afterFind',\n  'beforeSync',\n  'afterSync',\n  'beforeAssociate',\n  'afterAssociate',\n  'beforeDefinitionRefresh',\n  'afterDefinitionRefresh',\n];\n\nexport const staticModelHooks = new HookHandlerBuilder<ModelHooks>(\n  validModelHooks,\n  async (eventTarget, isAsync, hookName: keyof ModelHooks, args) => {\n    // This forwards hooks run on Models to the Sequelize instance's hooks.\n    const model = eventTarget as ModelStatic;\n\n    if (!model.sequelize) {\n      throw new Error('Model must be initialized before running hooks on it.');\n    }\n\n    if (isAsync) {\n      await model.sequelize.hooks.runAsync(hookName, ...args);\n    } else {\n      model.sequelize.hooks.runSync(hookName, ...args);\n    }\n  },\n);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,mBAAmC;AA6H5B,MAAM,kBAA2C;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,MAAM,mBAAmB,IAAI;AAAA,EAClC;AAAA,EACA,OAAO,aAAa,SAAS,UAA4B,SAAS;AAEhE,UAAM,QAAQ;AAEd,QAAI,CAAC,MAAM,WAAW;AACpB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAEA,QAAI,SAAS;AACX,YAAM,MAAM,UAAU,MAAM,SAAS,UAAU,GAAG,IAAI;AAAA,IACxD,OAAO;AACL,YAAM,UAAU,MAAM,QAAQ,UAAU,GAAG,IAAI;AAAA,IACjD;AAAA,EACF;AACF;",
  "names": []
}
