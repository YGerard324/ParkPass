{
  "version": 3,
  "sources": ["../src/hooks.ts"],
  "sourcesContent": ["import type { AllowArray, Nullish } from '@sequelize/utils';\nimport { MultiMap } from '@sequelize/utils';\n\nexport type AsyncHookReturn = Promise<void> | void;\n\ntype HookParameters<Hook> = Hook extends (...args2: any) => any ? Parameters<Hook> : never;\n\ntype OnRunHook<HookConfig extends {}> = <HookName extends keyof HookConfig>(\n  eventTarget: object,\n  isAsync: boolean,\n  hookName: HookName,\n  args: HookParameters<HookConfig[HookName]>,\n) => AsyncHookReturn;\n\n/**\n * @private\n */\nexport class HookHandler<HookConfig extends {}> {\n  readonly #validHookNames: Array<keyof HookConfig>;\n  readonly #eventTarget: object;\n  readonly #listeners = new MultiMap<\n    PropertyKey,\n    { listenerName: string | Nullish; callback: HookConfig[keyof HookConfig] }\n  >();\n\n  readonly #onRunHook: OnRunHook<HookConfig> | undefined;\n\n  constructor(\n    eventTarget: object,\n    validHookNames: Array<keyof HookConfig>,\n    onRunHook?: OnRunHook<HookConfig>,\n  ) {\n    this.#eventTarget = eventTarget;\n    this.#validHookNames = validHookNames;\n    this.#onRunHook = onRunHook;\n  }\n\n  removeListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listenerOrListenerName: string | HookConfig[HookName],\n  ): void {\n    this.#assertValidHookName(hookName);\n\n    if (typeof listenerOrListenerName === 'string') {\n      const listener = this.#getNamedListener(hookName, listenerOrListenerName);\n      if (listener) {\n        this.#listeners.deleteValue(hookName, listener);\n      }\n    } else {\n      const listeners = this.#listeners.get(hookName);\n      for (const listener of listeners) {\n        if (listener.callback === listenerOrListenerName) {\n          this.#listeners.deleteValue(hookName, listener);\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.#listeners.clear();\n  }\n\n  #getNamedListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listenerName: string,\n  ): { listenerName: string | Nullish; callback: HookConfig[keyof HookConfig] } | null {\n    const listeners = this.#listeners.get(hookName);\n    for (const listener of listeners) {\n      if (listener.listenerName === listenerName) {\n        return listener;\n      }\n    }\n\n    return null;\n  }\n\n  hasListeners(hookName: keyof HookConfig): boolean {\n    this.#assertValidHookName(hookName);\n\n    return this.#listeners.count(hookName) > 0;\n  }\n\n  getListenerCount(hookName: keyof HookConfig): number {\n    this.#assertValidHookName(hookName);\n\n    return this.#listeners.count(hookName);\n  }\n\n  runSync<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    ...args: HookConfig[HookName] extends (...args2: any) => any\n      ? Parameters<HookConfig[HookName]>\n      : never\n  ): void {\n    this.#assertValidHookName(hookName);\n\n    const listeners = this.#listeners.get(hookName);\n    for (const listener of listeners) {\n      // @ts-expect-error -- callback can by any hook type (due to coming from the map), args is the args of a specific hook. Too hard to type properly.\n      const out = listener.callback(...args);\n\n      if (out && 'then' in out) {\n        throw new Error(\n          `${listener.listenerName ? `Listener ${listener.listenerName}` : `An unnamed listener`} of hook ${String(hookName)} on ${getName(this.#eventTarget)} returned a Promise, but the hook is synchronous.`,\n        );\n      }\n    }\n\n    if (this.#onRunHook) {\n      void this.#onRunHook(this.#eventTarget, false, hookName, args);\n    }\n  }\n\n  async runAsync<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    ...args: HookConfig[HookName] extends (...args2: any) => any\n      ? Parameters<HookConfig[HookName]>\n      : never\n  ): Promise<void> {\n    this.#assertValidHookName(hookName);\n\n    const listeners = this.#listeners.get(hookName);\n    for (const listener of listeners) {\n      /* eslint-disable no-await-in-loop */\n      // @ts-expect-error -- callback can by any hook type (due to coming from the map), args is the args of a specific hook. Too hard to type properly.\n      await listener.callback(...args);\n      /* eslint-enable no-await-in-loop */\n    }\n\n    if (this.#onRunHook) {\n      await this.#onRunHook(this.#eventTarget, true, hookName, args);\n    }\n  }\n\n  /**\n   * Registers a listener for a hook.\n   *\n   * Returns a function that can be called to deregister the listener.\n   *\n   * @param hookName\n   * @param listener\n   * @param listenerName\n   */\n  addListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listener: HookConfig[HookName],\n    listenerName?: string,\n  ): () => void {\n    this.#assertValidHookName(hookName);\n\n    if (listenerName) {\n      const existingListener = this.#getNamedListener(hookName, listenerName);\n\n      if (existingListener) {\n        throw new Error(\n          `Named listener ${listenerName} already exists for hook ${String(hookName)} on ${getName(this.#eventTarget)}.`,\n        );\n      }\n    }\n\n    this.#listeners.append(hookName, { callback: listener, listenerName });\n\n    return () => {\n      this.removeListener(hookName, listenerName || listener);\n    };\n  }\n\n  addListeners(listeners: {\n    [Key in keyof HookConfig]?: AllowArray<\n      HookConfig[Key] | { name: string | symbol; callback: HookConfig[Key] }\n    >;\n  }) {\n    for (const hookName of this.#validHookNames) {\n      const hookListeners = listeners[hookName];\n      if (!hookListeners) {\n        continue;\n      }\n\n      const hookListenersArray = Array.isArray(hookListeners) ? hookListeners : [hookListeners];\n      for (const listener of hookListenersArray) {\n        if (typeof listener === 'function') {\n          this.addListener(hookName, listener);\n        } else {\n          this.addListener(hookName, listener.callback, listener.name);\n        }\n      }\n    }\n  }\n\n  #assertValidHookName(hookName: any) {\n    if (!this.#validHookNames.includes(hookName)) {\n      throw new Error(\n        `Target ${getName(this.#eventTarget)} does not support a hook named \"${String(hookName)}\".`,\n      );\n    }\n  }\n}\n\nexport class HookHandlerBuilder<HookConfig extends {}> {\n  readonly #validHookNames: Array<keyof HookConfig>;\n  readonly #hookHandlers = new WeakMap<object, HookHandler<HookConfig>>();\n  readonly #onRunHook: OnRunHook<HookConfig> | undefined;\n\n  constructor(validHookNames: Array<keyof HookConfig>, onRunHook?: OnRunHook<HookConfig>) {\n    this.#validHookNames = validHookNames;\n    this.#onRunHook = onRunHook;\n  }\n\n  getFor(target: object): HookHandler<HookConfig> {\n    let hookHandler = this.#hookHandlers.get(target);\n    if (!hookHandler) {\n      hookHandler = new HookHandler<HookConfig>(target, this.#validHookNames, this.#onRunHook);\n      this.#hookHandlers.set(target, hookHandler);\n    }\n\n    return hookHandler;\n  }\n}\n\nfunction getName(obj: object) {\n  if (typeof obj === 'function') {\n    return `[class ${obj.name}]`;\n  }\n\n  return `[instance ${obj.constructor.name}]`;\n}\n\nexport interface NewHookable<HookNames extends string> {\n  /**\n   * Controls which hooks should be run.\n   *\n   * Possible values:\n   * - false: All hooks will be run. (default)\n   * - true: No hooks will be run.\n   * - An array of strings: The hooks listed in the array will not be run.\n   * - An object with the \"except\" property: Only the hooks listed in the array will be run.\n   */\n  noHooks?: boolean | undefined | readonly HookNames[] | { except: readonly HookNames[] };\n}\n\nexport function mayRunHook<HookName extends string>(\n  hookName: HookName,\n  noHooksConfig: NewHookable<HookName>['noHooks'],\n): boolean {\n  if (!noHooksConfig) {\n    return true;\n  }\n\n  if (noHooksConfig === true) {\n    return false;\n  }\n\n  if ('except' in noHooksConfig) {\n    return noHooksConfig.except.includes(hookName);\n  }\n\n  return !noHooksConfig.includes(hookName);\n}\n"],
  "mappings": "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",
  "names": []
}
