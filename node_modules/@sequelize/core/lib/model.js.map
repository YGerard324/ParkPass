{
  "version": 3,
  "sources": ["../src/model.js"],
  "sourcesContent": ["'use strict';\n\nimport { EMPTY_OBJECT, every, find } from '@sequelize/utils';\nimport Dottie from 'dottie';\nimport assignWith from 'lodash/assignWith';\nimport cloneDeepLodash from 'lodash/cloneDeep';\nimport defaultsLodash from 'lodash/defaults';\nimport difference from 'lodash/difference';\nimport each from 'lodash/each';\nimport flattenDepth from 'lodash/flattenDepth';\nimport forEach from 'lodash/forEach';\nimport forIn from 'lodash/forIn';\nimport get from 'lodash/get';\nimport intersection from 'lodash/intersection';\nimport isEmpty from 'lodash/isEmpty';\nimport isEqual from 'lodash/isEqual';\nimport isObject from 'lodash/isObject';\nimport isPlainObject from 'lodash/isPlainObject';\nimport mapValues from 'lodash/mapValues';\nimport omit from 'lodash/omit';\nimport omitBy from 'lodash/omitBy';\nimport pick from 'lodash/pick';\nimport pickBy from 'lodash/pickBy';\nimport remove from 'lodash/remove';\nimport union from 'lodash/union';\nimport unionBy from 'lodash/unionBy';\nimport uniq from 'lodash/uniq';\nimport without from 'lodash/without';\nimport assert from 'node:assert';\nimport NodeUtil from 'node:util';\nimport { AbstractDataType } from './abstract-dialect/data-types';\nimport {\n  Association,\n  BelongsToAssociation,\n  BelongsToManyAssociation,\n  HasManyAssociation,\n  HasOneAssociation,\n} from './associations';\nimport { AssociationSecret } from './associations/helpers';\nimport * as DataTypes from './data-types';\nimport * as SequelizeErrors from './errors';\nimport { BaseSqlExpression } from './expression-builders/base-sql-expression.js';\nimport { InstanceValidator } from './instance-validator';\nimport {\n  _validateIncludedElements,\n  combineIncludes,\n  getModelPkWhere,\n  setTransactionFromCls,\n  throwInvalidInclude,\n} from './model-internals';\nimport { ModelTypeScript } from './model-typescript';\nimport { Op } from './operators';\nimport { QueryTypes } from './query-types';\nimport { intersects } from './utils/array';\nimport {\n  noDoubleNestedGroup,\n  noModelDropSchema,\n  noNewModel,\n  schemaRenamedToWithSchema,\n  scopeRenamedToWithScope,\n} from './utils/deprecations';\nimport { toDefaultValue } from './utils/dialect';\nimport { mapFinderOptions, mapOptionFieldNames, mapValueFieldNames } from './utils/format';\nimport { logger } from './utils/logger';\nimport { isModelStatic, isSameInitialModel } from './utils/model-utils';\nimport {\n  cloneDeep,\n  defaults,\n  flattenObjectDeep,\n  getObjectFromMap,\n  mergeDefaults,\n} from './utils/object';\nimport { isWhereEmpty } from './utils/query-builder-utils';\nimport { getComplexKeys } from './utils/where.js';\n\n// This list will quickly become dated, but failing to maintain this list just means\n// we won't throw a warning when we should. At least most common cases will forever be covered\n// so we stop throwing erroneous warnings when we shouldn't.\nconst validQueryKeywords = new Set([\n  'where',\n  'attributes',\n  'paranoid',\n  'include',\n  'order',\n  'limit',\n  'offset',\n  'transaction',\n  'lock',\n  'raw',\n  'logging',\n  'benchmark',\n  'having',\n  'searchPath',\n  'rejectOnEmpty',\n  'plain',\n  'scope',\n  'group',\n  'through',\n  'defaults',\n  'distinct',\n  'primary',\n  'exception',\n  'type',\n  'hooks',\n  'force',\n  'name',\n]);\n\n// List of attributes that should not be implicitly passed into subqueries/includes.\nconst nonCascadingOptions = [\n  'include',\n  'attributes',\n  'originalAttributes',\n  'order',\n  'where',\n  'limit',\n  'offset',\n  'plain',\n  'group',\n  'having',\n];\n\n/**\n * Used to ensure Model.build is used instead of new Model().\n * Do not expose.\n */\nconst CONSTRUCTOR_SECRET = Symbol('model-constructor-secret');\n\n/**\n * A Model represents a table in the database. Instances of this class represent a database row.\n *\n * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the\n * instance. By default, the values from dataValues can also be accessed directly from the Instance, that is:\n * ```js\n * instance.field\n * // is the same as\n * instance.get('field')\n * // is the same as\n * instance.getDataValue('field')\n * ```\n * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from\n * `dataValues`. Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be\n * used for custom getters.\n *\n * @see {Sequelize#define} for more information about getters and setters\n */\nexport class Model extends ModelTypeScript {\n  /**\n   * Builds a new model instance.\n   *\n   * Cannot be used directly. Use {@link Model.build} instead.\n   *\n   * @param {object}  [values={}] an object of key value pairs\n   * @param {object}  [options] instance construction options\n   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n   * @param {boolean} [options.isNewRecord=true] Is this a new record\n   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See\n   *   `set`\n   * @param {symbol}  secret Secret used to ensure Model.build is used instead of new Model(). Don't forget to pass it up if\n   *   you define a custom constructor.\n   */\n  constructor(values = {}, options = {}, secret) {\n    super();\n\n    if (secret !== CONSTRUCTOR_SECRET) {\n      noNewModel();\n      // TODO [>=8]: throw instead of deprecation notice\n      // throw new Error(`Use ${this.constructor.name}.build() instead of new ${this.constructor.name}()`);\n    }\n\n    this.constructor.assertIsInitialized();\n\n    options = {\n      isNewRecord: true,\n      _schema: this.modelDefinition.table.schema,\n      _schemaDelimiter: this.modelDefinition.table.delimiter,\n      ...options,\n      model: this.constructor,\n    };\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => {\n        return Array.isArray(attribute) ? attribute[1] : attribute;\n      });\n    }\n\n    if (!options.includeValidated) {\n      this.constructor._conformIncludes(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        _validateIncludedElements(options);\n      }\n    }\n\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this.uniqno = 1;\n    this._changed = new Set();\n    this._options = omit(options, ['comesFromDatabase']);\n\n    /**\n     * Returns true if this instance has not yet been persisted to the database\n     *\n     * @property isNewRecord\n     * @returns {boolean}\n     */\n    this.isNewRecord = options.isNewRecord;\n\n    this._initValues(values, options);\n  }\n\n  _initValues(values, options) {\n    values = { ...values };\n\n    if (options.isNewRecord) {\n      const modelDefinition = this.modelDefinition;\n\n      const defaults =\n        modelDefinition.defaultValues.size > 0\n          ? mapValues(getObjectFromMap(modelDefinition.defaultValues), getDefaultValue => {\n              const value = getDefaultValue();\n\n              return value && value instanceof BaseSqlExpression ? value : cloneDeepLodash(value);\n            })\n          : Object.create(null);\n\n      // set id to null if not passed as value, a newly created dao has no id\n      // removing this breaks bulkCreate\n      // do after default values since it might have UUID as a default value\n      if (modelDefinition.primaryKeysAttributeNames.size > 0) {\n        for (const primaryKeyAttribute of modelDefinition.primaryKeysAttributeNames) {\n          if (!Object.hasOwn(defaults, primaryKeyAttribute)) {\n            defaults[primaryKeyAttribute] = null;\n          }\n        }\n      }\n\n      const {\n        createdAt: createdAtAttrName,\n        deletedAt: deletedAtAttrName,\n        updatedAt: updatedAtAttrName,\n      } = modelDefinition.timestampAttributeNames;\n\n      if (createdAtAttrName && defaults[createdAtAttrName]) {\n        this.dataValues[createdAtAttrName] = toDefaultValue(defaults[createdAtAttrName]);\n        delete defaults[createdAtAttrName];\n      }\n\n      if (updatedAtAttrName && defaults[updatedAtAttrName]) {\n        this.dataValues[updatedAtAttrName] = toDefaultValue(defaults[updatedAtAttrName]);\n        delete defaults[updatedAtAttrName];\n      }\n\n      if (deletedAtAttrName && defaults[deletedAtAttrName]) {\n        this.dataValues[deletedAtAttrName] = toDefaultValue(defaults[deletedAtAttrName]);\n        delete defaults[deletedAtAttrName];\n      }\n\n      for (const key in defaults) {\n        if (values[key] === undefined) {\n          this.set(key, toDefaultValue(defaults[key]), { raw: true });\n          delete values[key];\n        }\n      }\n    }\n\n    this.set(values, options);\n  }\n\n  // validateIncludedElements should have been called before this method\n  static _paranoidClause(model, options = {}) {\n    // Apply on each include\n    // This should be handled before handling where conditions because of logic with returns\n    // otherwise this code will never run on includes of a already conditionable where\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n\n    // apply paranoid when groupedLimit is used\n    if (get(options, 'groupedLimit.on.through.model.options.paranoid')) {\n      const throughModel = get(options, 'groupedLimit.on.through.model');\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(\n          throughModel,\n          options.groupedLimit.through,\n        );\n      }\n    }\n\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      // This model is not paranoid, nothing to do here;\n      return options;\n    }\n\n    const modelDefinition = model.modelDefinition;\n\n    const deletedAtCol = modelDefinition.timestampAttributeNames.deletedAt;\n    const deletedAtAttribute = modelDefinition.attributes.get(deletedAtCol);\n    const deletedAtObject = Object.create(null);\n\n    let deletedAtDefaultValue = deletedAtAttribute.defaultValue ?? null;\n\n    deletedAtDefaultValue ||= {\n      [Op.eq]: null,\n    };\n\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n\n    if (isWhereEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { [Op.and]: [deletedAtObject, options.where] };\n    }\n\n    return options;\n  }\n\n  /**\n   * Returns the attributes of the model.\n   *\n   * @returns {object|any}\n   */\n  static getAttributes() {\n    return getObjectFromMap(this.modelDefinition.attributes);\n  }\n\n  get validators() {\n    throw new Error(\n      'Model#validators has been removed. Use the validators option on Model.modelDefinition.attributes instead.',\n    );\n  }\n\n  static get _schema() {\n    throw new Error('Model._schema has been removed. Use Model.modelDefinition instead.');\n  }\n\n  static get _schemaDelimiter() {\n    throw new Error('Model._schemaDelimiter has been removed. Use Model.modelDefinition instead.');\n  }\n\n  static _getAssociationDebugList() {\n    return `The following associations are defined on \"${this.name}\": ${Object.keys(\n      this.associations,\n    )\n      .map(associationName => `\"${associationName}\"`)\n      .join(', ')}`;\n  }\n\n  static getAssociation(associationName) {\n    if (!Object.hasOwn(this.associations, associationName)) {\n      throw new Error(`Association with alias \"${associationName}\" does not exist on ${this.name}.\n${this._getAssociationDebugList()}`);\n    }\n\n    return this.associations[associationName];\n  }\n\n  static _getAssociationsByModel(model) {\n    const matchingAssociations = [];\n\n    for (const associationName of Object.keys(this.associations)) {\n      const association = this.associations[associationName];\n      if (!isSameInitialModel(association.target, model)) {\n        continue;\n      }\n\n      matchingAssociations.push(association);\n    }\n\n    return matchingAssociations;\n  }\n\n  static _normalizeIncludes(options, associationOwner) {\n    this._conformIncludes(options, associationOwner);\n    this._expandIncludeAll(options, associationOwner);\n  }\n\n  static _conformIncludes(options, associationOwner) {\n    if (!options.include) {\n      return;\n    }\n\n    // if include is not an array, wrap in an array\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (options.include.length === 0) {\n      delete options.include;\n\n      return;\n    }\n\n    // convert all included elements to { model: Model } form\n    options.include = options.include.map(include =>\n      this._conformInclude(include, associationOwner),\n    );\n  }\n\n  static _conformInclude(include, associationOwner) {\n    if (!include) {\n      throwInvalidInclude(include);\n    }\n\n    if (!associationOwner || !isModelStatic(associationOwner)) {\n      throw new TypeError(\n        `Sequelize sanity check: associationOwner must be a model subclass. Got ${NodeUtil.inspect(associationOwner)} (${typeof associationOwner})`,\n      );\n    }\n\n    if (include._pseudo) {\n      return include;\n    }\n\n    if (include.all) {\n      this._conformIncludes(include, associationOwner);\n\n      return include;\n    }\n\n    // normalize to IncludeOptions\n    if (!isPlainObject(include)) {\n      if (isModelStatic(include)) {\n        include = {\n          model: include,\n        };\n      } else {\n        include = {\n          association: include,\n        };\n      }\n    } else {\n      // copy object so we can mutate it without side effects\n      include = { ...include };\n    }\n\n    if (include.as && !include.association) {\n      include.association = include.as;\n    }\n\n    if (!include.association) {\n      include.association = associationOwner.getAssociationWithModel(include.model, include.as);\n    } else if (typeof include.association === 'string') {\n      include.association = associationOwner.getAssociation(include.association);\n    } else {\n      if (!(include.association instanceof Association)) {\n        throwInvalidInclude(include);\n      }\n\n      if (!isSameInitialModel(include.association.source, associationOwner)) {\n        throw new Error(`Invalid Include received: the specified association \"${include.association.as}\" is not defined on model \"${associationOwner.name}\". It is owned by model \"${include.association.source.name}\".\n${associationOwner._getAssociationDebugList()}`);\n      }\n    }\n\n    if (!include.model) {\n      include.model = include.association.target;\n    }\n\n    if (!isSameInitialModel(include.model, include.association.target)) {\n      throw new TypeError(\n        `Invalid Include received: the specified \"model\" option (\"${include.model.name}\") does not match the target (\"${include.association.target.name}\") of the \"${include.association.as}\" association.`,\n      );\n    }\n\n    if (!include.as) {\n      include.as = include.association.as;\n    }\n\n    this._conformIncludes(include, include.model);\n\n    return include;\n  }\n\n  static _expandIncludeAllElement(includes, include) {\n    // check 'all' attribute provided is valid\n    let { all, nested, ...includeOptions } = include;\n\n    if (Object.keys(includeOptions).length > 0) {\n      throw new Error(\n        '\"include: { all: true }\" does not allow extra options (except for \"nested\") because they are unsafe. Select includes one by one if you want to specify more options.',\n      );\n    }\n\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: ['BelongsTo', 'HasOne'],\n        Has: ['HasOne', 'HasMany'],\n        Many: ['HasMany'],\n      };\n\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === 'All') {\n          all = true;\n          break;\n        }\n\n        const types = validTypes[type];\n        if (!types) {\n          throw new SequelizeErrors.EagerLoadingError(\n            `include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`,\n          );\n        }\n\n        if (types !== true) {\n          // replace type placeholder e.g. 'One' with its constituent types e.g. 'HasOne', 'BelongsTo'\n          all.splice(i, 1);\n          i--;\n          for (const type_ of types) {\n            if (!all.includes(type_)) {\n              all.unshift(type_);\n              i++;\n            }\n          }\n        }\n      }\n    }\n\n    const visitedModels = [];\n    const addAllIncludes = (parent, includes) => {\n      forEach(parent.associations, association => {\n        if (all !== true && !all.includes(association.associationType)) {\n          return;\n        }\n\n        // 'fromSourceToThroughOne' is a bit hacky and should not be included when { all: true } is specified\n        //  because its parent 'belongsToMany' will be replaced by it in query generator.\n        if (\n          association.parentAssociation instanceof BelongsToManyAssociation &&\n          association === association.parentAssociation.fromSourceToThroughOne\n        ) {\n          return;\n        }\n\n        // skip if the association is already included\n        if (includes.some(existingInclude => existingInclude.association === association)) {\n          return;\n        }\n\n        const newInclude = { association };\n\n        const model = association.target;\n\n        // skip if recursing over a model whose associations have already been included\n        // to prevent infinite loops with associations such as this:\n        // user -> projects -> user\n        if (nested && visitedModels.includes(model)) {\n          return;\n        }\n\n        // include this model\n        const normalizedNewInclude = this._conformInclude(newInclude, parent);\n        includes.push(normalizedNewInclude);\n\n        // run recursively if nested\n        if (nested) {\n          visitedModels.push(parent);\n\n          const subIncludes = [];\n          addAllIncludes(model, subIncludes);\n          visitedModels.pop();\n\n          if (subIncludes.length > 0) {\n            normalizedNewInclude.include = subIncludes;\n          }\n        }\n      });\n    };\n\n    addAllIncludes(this, includes);\n  }\n\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.table] = true;\n\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n\n      include.originalAttributes = include.model._injectDependentVirtualAttributes(\n        include.attributes,\n      );\n\n      include = mapFinderOptions(include, include.model);\n\n      if (include.attributes.length > 0) {\n        each(include.model.primaryKeys, (attr, key) => {\n          // Include the primary key if it's not already included - take into account that the pk might be aliased (due to a .field prop)\n          if (\n            !include.attributes.some(includeAttr => {\n              if (attr.field !== key) {\n                return (\n                  Array.isArray(includeAttr) &&\n                  includeAttr[0] === attr.field &&\n                  includeAttr[1] === key\n                );\n              }\n\n              return includeAttr === key;\n            })\n          ) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = mapFinderOptions(include, include.model);\n    }\n\n    // pseudo include just needed the attribute logic, return\n    if (include._pseudo) {\n      if (!include.attributes) {\n        include.attributes = Object.keys(include.model.tableAttributes);\n      }\n\n      return mapFinderOptions(include, include.model);\n    }\n\n    // check if the current Model is actually associated with the passed Model - or it's a pseudo include\n    const association =\n      include.association || this.getAssociationWithModel(include.model, include.as);\n\n    include.association = association;\n    include.as ||= association.as;\n\n    // If through, we create a pseudo child include, to ease our parsing later on\n    if (association instanceof BelongsToManyAssociation) {\n      if (!include.include) {\n        include.include = [];\n      }\n\n      const through = include.association.through;\n\n      include.through = defaultsLodash(include.through || {}, {\n        model: through.model,\n        // Through Models are a special case: we always want to load them as the name of the model, not the name of the association\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true,\n        },\n        _pseudo: true,\n        parent: include,\n      });\n\n      if (through.scope) {\n        include.through.where = include.through.where\n          ? { [Op.and]: [include.through.where, through.scope] }\n          : through.scope;\n      }\n\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n\n    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source\n    let model;\n    if (include.model.scoped === true) {\n      // If the passed model is already scoped, keep that\n      model = include.model;\n    } else {\n      // Otherwise use the model that was originally passed to the association\n      model =\n        include.association.target.name === include.model.name\n          ? include.association.target\n          : include.association.source;\n    }\n\n    model._injectScope(include);\n\n    // This check should happen after injecting the scope, since the scope may contain a .attributes\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n\n    include = mapFinderOptions(include, include.model);\n\n    if (include.required === undefined) {\n      include.required = Boolean(include.where);\n    }\n\n    if (include.association.scope) {\n      include.where = include.where\n        ? { [Op.and]: [include.where, include.association.scope] }\n        : include.association.scope;\n    }\n\n    if (include.limit && include.separate === undefined) {\n      include.separate = true;\n    }\n\n    if (include.separate === true) {\n      if (!(include.association instanceof HasManyAssociation)) {\n        throw new TypeError('Only HasMany associations support include.separate');\n      }\n\n      include.duplicating = false;\n\n      if (\n        options.attributes &&\n        options.attributes.length > 0 &&\n        !flattenDepth(options.attributes, 2).includes(association.sourceKey)\n      ) {\n        options.attributes.push(association.sourceKey);\n      }\n\n      if (\n        include.attributes &&\n        include.attributes.length > 0 &&\n        !flattenDepth(include.attributes, 2).includes(association.foreignKey)\n      ) {\n        include.attributes.push(association.foreignKey);\n      }\n    }\n\n    // Validate child includes\n    if (Object.hasOwn(include, 'include')) {\n      _validateIncludedElements(include, tableNames);\n    }\n\n    return include;\n  }\n\n  static _expandIncludeAll(options, associationOwner) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n\n        associationOwner._expandIncludeAllElement(includes, include);\n      }\n    }\n\n    for (const include of includes) {\n      this._expandIncludeAll(include, include.model);\n    }\n  }\n\n  static _baseMerge(...args) {\n    assignWith(...args);\n\n    return args[0];\n  }\n\n  static _mergeFunction(objValue, srcValue, key) {\n    if (key === 'include') {\n      return combineIncludes(objValue, srcValue);\n    }\n\n    if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n      return union(objValue, srcValue);\n    }\n\n    if (['where', 'having'].includes(key)) {\n      return combineWheresWithAnd(objValue, srcValue);\n    } else if (key === 'attributes' && isPlainObject(objValue) && isPlainObject(srcValue)) {\n      return assignWith(objValue, srcValue, (objValue, srcValue) => {\n        if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n          return union(objValue, srcValue);\n        }\n      });\n    }\n\n    // If we have a possible object/array to clone, we try it.\n    // Otherwise, we return the original value when it's not undefined,\n    // or the resulting object in that case.\n    if (srcValue) {\n      return cloneDeep(srcValue, true);\n    }\n\n    return srcValue === undefined ? objValue : srcValue;\n  }\n\n  static _assignOptions(...args) {\n    return this._baseMerge(...args, this._mergeFunction);\n  }\n\n  static _defaultsOptions(target, opts) {\n    return this._baseMerge(target, opts, (srcValue, objValue, key) => {\n      return this._mergeFunction(objValue, srcValue, key);\n    });\n  }\n\n  /**\n   * Remove attribute from model definition.\n   * Only use if you know what you're doing.\n   *\n   * @param {string} attribute name of attribute to remove\n   */\n  static removeAttribute(attribute) {\n    delete this.modelDefinition.rawAttributes[attribute];\n    this.modelDefinition.refreshAttributes();\n  }\n\n  /**\n   * Merges new attributes with the existing ones.\n   * Only use if you know what you're doing.\n   *\n   * Warning: Attributes are not replaced, they are merged.\n   *\n   * @param {object} newAttributes\n   */\n  static mergeAttributesDefault(newAttributes) {\n    const rawAttributes = this.modelDefinition.rawAttributes;\n\n    mergeDefaults(rawAttributes, newAttributes);\n\n    this.modelDefinition.refreshAttributes();\n\n    return rawAttributes;\n  }\n\n  /**\n   * Sync this Model to the DB, that is create the table.\n   * See {@link Sequelize#sync} for options\n   *\n   * @param {object} [options] sync options\n   *\n   * @returns {Promise<Model>}\n   */\n  static async sync(options) {\n    options = { ...this.options, ...options };\n    options.hooks = options.hooks === undefined ? true : Boolean(options.hooks);\n\n    const modelDefinition = this.modelDefinition;\n    const physicalAttributes = getObjectFromMap(modelDefinition.physicalAttributes);\n    const columnDefs = getObjectFromMap(modelDefinition.columns);\n\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeSync', options);\n    }\n\n    const tableName = { ...this.table };\n    if (options.schema && options.schema !== tableName.schema) {\n      // Some users sync the same set of tables in different schemas for various reasons\n      // They then set `searchPath` when running a query to use different schemas.\n      // See https://github.com/sequelize/sequelize/pull/15274#discussion_r1020770364\n      // We only allow this if the tables are in the default schema, because we need to ensure that\n      // all tables are in the same schema to prevent collisions and `searchPath` only works if we don't specify the schema\n      // (which we don't for the default schema)\n      if (tableName.schema !== this.sequelize.dialect.getDefaultSchema()) {\n        throw new Error(\n          `The \"schema\" option in sync can only be used on models that do not already specify a schema, or that are using the default schema. Model ${this.name} already specifies schema ${tableName.schema}`,\n        );\n      }\n\n      tableName.schema = options.schema;\n    }\n\n    delete options.schema;\n\n    let tableExists;\n    if (options.force) {\n      await this.drop({\n        ...options,\n        cascade: this.sequelize.dialect.supports.dropTable.cascade || undefined,\n      });\n      tableExists = false;\n    } else {\n      tableExists = await this.queryInterface.tableExists(tableName, options);\n    }\n\n    if (!tableExists) {\n      await this.queryInterface.createTable(tableName, physicalAttributes, options, this);\n    } else {\n      // enums are always updated, even if alter is not set. createTable calls it too.\n      await this.queryInterface.ensureEnums(tableName, physicalAttributes, options, this);\n    }\n\n    if (tableExists && options.alter) {\n      const tableInfos = await Promise.all([\n        this.queryInterface.describeTable(tableName, options),\n        this.queryInterface.showConstraints(tableName, {\n          ...options,\n          constraintType: 'FOREIGN KEY',\n        }),\n      ]);\n\n      const columns = tableInfos[0];\n      // Use for alter foreign keys\n      const foreignKeyReferences = tableInfos[1];\n      const removedConstraints = {};\n\n      for (const columnName in physicalAttributes) {\n        if (!Object.hasOwn(physicalAttributes, columnName)) {\n          continue;\n        }\n\n        if (!columns[columnName] && !columns[physicalAttributes[columnName].field]) {\n          await this.queryInterface.addColumn(\n            tableName,\n            physicalAttributes[columnName].field || columnName,\n            physicalAttributes[columnName],\n            options,\n          );\n        }\n      }\n\n      if (\n        options.alter === true ||\n        (typeof options.alter === 'object' && options.alter.drop !== false)\n      ) {\n        for (const columnName in columns) {\n          if (!Object.hasOwn(columns, columnName)) {\n            continue;\n          }\n\n          const currentAttribute = columnDefs[columnName];\n          if (!currentAttribute) {\n            await this.queryInterface.removeColumn(tableName, columnName, options);\n            continue;\n          }\n\n          if (currentAttribute.primaryKey) {\n            continue;\n          }\n\n          // Check foreign keys. If it's a foreign key, it should remove constraint first.\n          const references = currentAttribute.references;\n          if (currentAttribute.references) {\n            const schema = tableName.schema;\n            const database = this.sequelize.options.replication.write.database;\n            const foreignReferenceSchema = currentAttribute.references.table.schema;\n            const foreignReferenceTableName =\n              typeof references.table === 'object' ? references.table.tableName : references.table;\n            // Find existed foreign keys\n            for (const foreignKeyReference of foreignKeyReferences) {\n              const constraintName = foreignKeyReference.constraintName;\n              if (\n                (constraintName &&\n                  (foreignKeyReference.tableCatalog\n                    ? foreignKeyReference.tableCatalog === database\n                    : true) &&\n                  (schema ? foreignKeyReference.tableSchema === schema : true) &&\n                  foreignKeyReference.referencedTableName === foreignReferenceTableName &&\n                  foreignKeyReference.referencedColumnNames.includes(references.key) &&\n                  (foreignReferenceSchema\n                    ? foreignKeyReference.referencedTableSchema === foreignReferenceSchema\n                    : true) &&\n                  !removedConstraints[constraintName]) ||\n                this.sequelize.dialect.name === 'ibmi'\n              ) {\n                // Remove constraint on foreign keys.\n                await this.queryInterface.removeConstraint(tableName, constraintName, options);\n                removedConstraints[constraintName] = true;\n              }\n            }\n          }\n\n          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);\n        }\n      }\n    }\n\n    const existingIndexes = await this.queryInterface.showIndex(tableName, options);\n    const missingIndexes = this.getIndexes()\n      .filter(item1 => !existingIndexes.some(item2 => item1.name === item2.name))\n      .sort((index1, index2) => {\n        if (this.sequelize.dialect.name === 'postgres') {\n          // move concurrent indexes to the bottom to avoid weird deadlocks\n          if (index1.concurrently === true) {\n            return 1;\n          }\n\n          if (index2.concurrently === true) {\n            return -1;\n          }\n        }\n\n        return 0;\n      });\n\n    for (const index of missingIndexes) {\n      // TODO: 'options' is ignored by addIndex, making Add Index queries impossible to log.\n      await this.queryInterface.addIndex(tableName, index, options);\n    }\n\n    if (options.hooks) {\n      await this.hooks.runAsync('afterSync', options);\n    }\n\n    return this;\n  }\n\n  /**\n   * Drop the table represented by this Model\n   *\n   * @param {object} [options] drop options\n   * @returns {Promise}\n   */\n  static async drop(options) {\n    return await this.queryInterface.dropTable(this, options);\n  }\n\n  /**\n   * @param {object | string} schema\n   * @deprecated use {@link Sequelize#dropSchema} or {@link QueryInterface#dropSchema}\n   */\n  // TODO [>=2023-01-01]: remove me in Sequelize >= 8\n  static async dropSchema(schema) {\n    noModelDropSchema();\n\n    return await this.queryInterface.dropSchema(schema);\n  }\n\n  /**\n   * Returns a copy of this model with the corresponding table located in the specified schema.\n   *\n   * For postgres, this will actually place the schema in front of the table name (`\"schema\".\"tableName\"`),\n   * while the schema will be prepended to the table name for mysql and sqlite (`'schema.tablename'`).\n   *\n   * This method is intended for use cases where the same model is needed in multiple schemas.\n   * In such a use case it is important to call {@link Model.sync} (or use migrations!) for each model created by this method\n   * to ensure the models are created in the correct schema.\n   *\n   * If a single default schema per model is needed, set the {@link ModelOptions.schema} option instead.\n   *\n   * @param {string|object} schema The name of the schema\n   *\n   * @returns {Model}\n   */\n  static withSchema(schema) {\n    if (arguments.length > 1) {\n      throw new TypeError(\n        'Unlike Model.schema, Model.withSchema only accepts 1 argument which may be either a string or an option bag.',\n      );\n    }\n\n    const schemaOptions = typeof schema === 'string' || schema === null ? { schema } : schema;\n\n    schemaOptions.schema ||=\n      this.sequelize.options.schema || this.sequelize.dialect.getDefaultSchema();\n\n    return this.getInitialModel()._withScopeAndSchema(schemaOptions, this._scope, this._scopeNames);\n  }\n\n  // TODO [>=2023-01-01]: remove in Sequelize 8\n  static schema(schema, options) {\n    schemaRenamedToWithSchema();\n\n    return this.withSchema({\n      schema,\n      schemaDelimiter: typeof options === 'string' ? options : options?.schemaDelimiter,\n    });\n  }\n\n  /**\n   * Returns the initial model, the one returned by {@link Model.init} or {@link Sequelize#define},\n   * before any scope or schema was applied.\n   */\n  static getInitialModel() {\n    // '_initialModel' is set on model variants (withScope, withSchema, etc)\n    return this._initialModel ?? this;\n  }\n\n  /**\n   * Add a new scope to the model\n   *\n   * This is especially useful for adding scopes with includes, when the model you want to\n   * include is not available at the time this model is defined.\n   *\n   * By default, this will throw an error if a scope with that name already exists.\n   * Use {@link AddScopeOptions.override} in the options object to silence this error.\n   *\n   * See {@link https://sequelize.org/docs/v7/other-topics/scopes/} to learn more about scopes.\n   *\n   * @param {string}          name The name of the scope. Use `defaultScope` to override the default scope\n   * @param {object|Function} scope scope or options\n   * @param {object}          [options] scope options\n   */\n  static addScope(name, scope, options) {\n    if (this !== this.getInitialModel()) {\n      throw new Error(\n        `Model.addScope can only be called on the initial model. Use \"${this.name}.getInitialModel()\" to access the initial model.`,\n      );\n    }\n\n    options = { override: false, ...options };\n\n    if (\n      ((name === 'defaultScope' && Object.keys(this.options.defaultScope).length > 0) ||\n        name in this.options.scopes) &&\n      options.override === false\n    ) {\n      throw new Error(\n        `The scope ${name} already exists. Pass { override: true } as options to silence this error`,\n      );\n    }\n\n    if (name === 'defaultScope') {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n\n  // TODO [>=2023-01-01]: remove in Sequelize 8\n  static scope(...options) {\n    scopeRenamedToWithScope();\n\n    return this.withScope(...options);\n  }\n\n  /**\n   * Creates a copy of this model, with one or more scopes applied.\n   *\n   * See {@link https://sequelize.org/docs/v7/other-topics/scopes/} to learn more about scopes.\n   *\n   * @param {?Array|object|string} [scopes] The scope(s) to apply. Scopes can either be passed as consecutive arguments, or\n   *   as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For\n   *   scope function, pass an object, with a `method` property. The value can either be a string, if the method does not\n   *   take any arguments, or an array, where the first element is the name of the method, and consecutive elements are\n   *   arguments to that method. Pass null to remove all scopes, including the default.\n   *\n   * @example To invoke scope functions you can do\n   * ```ts\n   * Model.withScope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()\n   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42\n   * ```\n   *\n   * @returns {Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will\n   *   clear the previous scope.\n   */\n  static withScope(...scopes) {\n    scopes = scopes.flat().filter(Boolean);\n\n    const initialModel = this.getInitialModel();\n\n    const mergedScope = {};\n    const scopeNames = [];\n\n    for (const option of scopes) {\n      let scope = null;\n      let scopeName = null;\n\n      if (isPlainObject(option)) {\n        if (option.method) {\n          if (\n            Array.isArray(option.method) &&\n            Boolean(initialModel.options.scopes[option.method[0]])\n          ) {\n            scopeName = option.method[0];\n            scope = initialModel.options.scopes[scopeName].apply(\n              initialModel,\n              option.method.slice(1),\n            );\n          } else if (initialModel.options.scopes[option.method]) {\n            scopeName = option.method;\n            scope = initialModel.options.scopes[scopeName].apply(initialModel);\n          }\n        } else {\n          scope = option;\n        }\n      } else if (option === 'defaultScope' && isPlainObject(initialModel.options.defaultScope)) {\n        scope = initialModel.options.defaultScope;\n      } else {\n        scopeName = option;\n        scope = initialModel.options.scopes[scopeName];\n        if (typeof scope === 'function') {\n          scope = scope();\n        }\n      }\n\n      if (!scope) {\n        throw new SequelizeErrors.SequelizeScopeError(\n          `\"${this.name}.withScope()\" has been called with an invalid scope: \"${scopeName}\" does not exist.`,\n        );\n      }\n\n      this._conformIncludes(scope, this);\n      // clone scope so it doesn't get modified\n      this._assignOptions(mergedScope, cloneDeep(scope) ?? {});\n      scopeNames.push(scopeName ? scopeName : 'defaultScope');\n    }\n\n    const modelDefinition = this.modelDefinition;\n\n    return initialModel._withScopeAndSchema(\n      {\n        schema: modelDefinition.table.schema || '',\n        schemaDelimiter: modelDefinition.table.delimiter || '',\n      },\n      mergedScope,\n      scopeNames,\n    );\n  }\n\n  // TODO [>=2023-01-01]: remove in Sequelize 8\n  /**\n   * Returns a model without scope. The default scope is also omitted.\n   *\n   * See {@link https://sequelize.org/docs/v7/other-topics/scopes/} to learn more about scopes.\n   */\n  static unscoped() {\n    scopeRenamedToWithScope();\n\n    return this.withoutScope();\n  }\n\n  /**\n   * Returns a model without scope. The default scope is also omitted.\n   *\n   * See {@link https://sequelize.org/docs/v7/other-topics/scopes/} to learn more about scopes.\n   */\n  static withoutScope() {\n    return this.withScope(null);\n  }\n\n  /**\n   * Returns the base model, with its initial scope.\n   */\n  static withInitialScope() {\n    const initialModel = this.getInitialModel();\n\n    const modelDefinition = this.modelDefinition;\n    const initialModelDefinition = initialModel.modelDefinition;\n\n    if (\n      modelDefinition.table.schema !== initialModelDefinition.table.schema ||\n      modelDefinition.table.delimiter !== initialModelDefinition.table.delimiter\n    ) {\n      return initialModel.withSchema({\n        schema: modelDefinition.table.schema,\n        schemaDelimiter: modelDefinition.table.delimiter,\n      });\n    }\n\n    return initialModel;\n  }\n\n  static _withScopeAndSchema(schemaOptions, mergedScope, scopeNames) {\n    if (!this._modelVariantRefs) {\n      // technically this weakref is unnecessary because we're referencing ourselves but it simplifies the code\n      // eslint-disable-next-line no-undef -- eslint doesn't know about WeakRef, this will be resolved once we migrate to TS.\n      this._modelVariantRefs = new Set([new WeakRef(this)]);\n    }\n\n    const newTable = this.queryGenerator.extractTableDetails({\n      tableName: this.modelDefinition.table.tableName,\n      schema: schemaOptions.schema,\n      delimiter: schemaOptions.delimiter,\n    });\n\n    for (const modelVariantRef of this._modelVariantRefs) {\n      const modelVariant = modelVariantRef.deref();\n\n      if (!modelVariant) {\n        this._modelVariantRefs.delete(modelVariantRef);\n        continue;\n      }\n\n      const variantTable = modelVariant.table;\n\n      if (variantTable.schema !== newTable.schema) {\n        continue;\n      }\n\n      if (variantTable.delimiter !== newTable.delimiter) {\n        continue;\n      }\n\n      // the item order of these arrays is important! scope('a', 'b') is not equal to scope('b', 'a')\n      if (!isEqual(modelVariant._scopeNames, scopeNames)) {\n        continue;\n      }\n\n      if (!isEqual(modelVariant._scope, mergedScope)) {\n        continue;\n      }\n\n      return modelVariant;\n    }\n\n    const clone = this._createModelVariant({\n      schema: schemaOptions.schema,\n      schemaDelimiter: schemaOptions.schemaDelimiter,\n    });\n    // eslint-disable-next-line no-undef -- eslint doesn't know about WeakRef, this will be resolved once we migrate to TS.\n    this._modelVariantRefs.add(new WeakRef(clone));\n\n    clone._scope = mergedScope;\n    clone._scopeNames = scopeNames;\n\n    if (scopeNames.length !== 1 || scopeNames[0] !== 'defaultScope') {\n      clone.scoped = true;\n    }\n\n    return clone;\n  }\n\n  static _createModelVariant(optionOverrides) {\n    const model = class extends this {};\n    model._initialModel = this;\n    Object.defineProperty(model, 'name', { value: this.name });\n\n    model.init(this.modelDefinition.rawAttributes, {\n      ...this.options,\n      ...optionOverrides,\n    });\n\n    // This is done for legacy reasons, where in a previous design both models shared the same association objects.\n    // TODO: re-create the associations on the new model instead of sharing them.\n    Object.assign(model.modelDefinition.associations, this.modelDefinition.associations);\n\n    return model;\n  }\n\n  /**\n   * Search for multiple instances.\n   * See {@link https://sequelize.org/docs/v7/core-concepts/model-querying-basics/} for more information about querying.\n   *\n   * __Example of a simple search:__\n   * ```js\n   * Model.findAll({\n   *   where: {\n   *     attr1: 42,\n   *     attr2: 'cake'\n   *   }\n   * })\n   * ```\n   *\n   * See also:\n   * - {@link Model.findOne}\n   * - {@link Sequelize#query}\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that will resolve with the array containing the results of the SELECT query.\n   */\n  static async findAll(options) {\n    if (options !== undefined && !isPlainObject(options)) {\n      throw new SequelizeErrors.QueryError(\n        'The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value',\n      );\n    }\n\n    if (\n      options !== undefined &&\n      options.attributes &&\n      !Array.isArray(options.attributes) &&\n      !isPlainObject(options.attributes)\n    ) {\n      throw new SequelizeErrors.QueryError(\n        'The attributes option must be an array of column names or an object',\n      );\n    }\n\n    const modelDefinition = this.modelDefinition;\n\n    this._warnOnInvalidOptions(options, Object.keys(modelDefinition.attributes));\n\n    const tableNames = {};\n\n    tableNames[this.table] = true;\n    options = cloneDeep(options) ?? {};\n\n    setTransactionFromCls(options, this.sequelize);\n\n    defaultsLodash(options, { hooks: true, model: this });\n\n    // set rejectOnEmpty option, defaults to model options\n    options.rejectOnEmpty = Object.hasOwn(options, 'rejectOnEmpty')\n      ? options.rejectOnEmpty\n      : this.options.rejectOnEmpty;\n\n    this._conformIncludes(options, this);\n    this._injectScope(options);\n\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeFind', options);\n      this._conformIncludes(options, this);\n    }\n\n    this._expandAttributes(options);\n    this._expandIncludeAll(options, options.model);\n\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeFindAfterExpandIncludeAll', options);\n    }\n\n    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n\n    if (options.include) {\n      options.hasJoin = true;\n\n      _validateIncludedElements(options, tableNames);\n\n      // If we're not raw, we have to make sure we include the primary key for de-duplication\n      if (\n        options.attributes &&\n        !options.raw &&\n        this.primaryKeyAttribute &&\n        !options.attributes.includes(this.primaryKeyAttribute) &&\n        (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)\n      ) {\n        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n      }\n    }\n\n    if (!options.attributes) {\n      options.attributes = Array.from(modelDefinition.attributes.keys());\n      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    }\n\n    mapFinderOptions(options, this);\n\n    options = this._paranoidClause(this, options);\n\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeFindAfterOptions', options);\n    }\n\n    const selectOptions = { ...options, tableNames: Object.keys(tableNames) };\n    const results = await this.queryInterface.select(this, this.table, selectOptions);\n    if (options.hooks) {\n      await this.hooks.runAsync('afterFind', results, options);\n    }\n\n    // rejectOnEmpty mode\n    if (isEmpty(results) && options.rejectOnEmpty) {\n      if (typeof options.rejectOnEmpty === 'function') {\n        throw new options.rejectOnEmpty();\n      }\n\n      if (typeof options.rejectOnEmpty === 'object') {\n        throw options.rejectOnEmpty;\n      }\n\n      throw new SequelizeErrors.EmptyResultError();\n    }\n\n    return await Model._findSeparate(results, options);\n  }\n\n  static _warnOnInvalidOptions(options, validColumnNames) {\n    if (!isPlainObject(options)) {\n      return;\n    }\n\n    const unrecognizedOptions = Object.keys(options).filter(k => !validQueryKeywords.has(k));\n    const unexpectedModelAttributes = intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      logger.warn(\n        `Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`,\n      );\n    }\n  }\n\n  static _injectDependentVirtualAttributes(attributes) {\n    const modelDefinition = this.modelDefinition;\n\n    if (modelDefinition.virtualAttributeNames.size === 0) {\n      return attributes;\n    }\n\n    if (!attributes || !Array.isArray(attributes)) {\n      return attributes;\n    }\n\n    for (const attribute of attributes) {\n      if (\n        modelDefinition.virtualAttributeNames.has(attribute) &&\n        modelDefinition.attributes.get(attribute).type.attributeDependencies\n      ) {\n        attributes = attributes.concat(\n          modelDefinition.attributes.get(attribute).type.attributeDependencies,\n        );\n      }\n    }\n\n    attributes = uniq(attributes);\n\n    return attributes;\n  }\n\n  static async _findSeparate(results, options) {\n    if (!options.include || options.raw || !results) {\n      return results;\n    }\n\n    const original = results;\n    if (options.plain) {\n      results = [results];\n    }\n\n    if (!Array.isArray(results) || results.length === 0) {\n      return original;\n    }\n\n    await Promise.all(\n      options.include.map(async include => {\n        if (!include.separate) {\n          return await Model._findSeparate(\n            results.reduce((memo, result) => {\n              let associations = result.get(include.association.as);\n\n              // Might be an empty belongsTo relation\n              if (!associations) {\n                return memo;\n              }\n\n              // Force array so we can concat no matter if it's 1:1 or :M\n              if (!Array.isArray(associations)) {\n                associations = [associations];\n              }\n\n              for (let i = 0, len = associations.length; i !== len; ++i) {\n                memo.push(associations[i]);\n              }\n\n              return memo;\n            }, []),\n            {\n              ...omit(\n                options,\n                'include',\n                'attributes',\n                'order',\n                'where',\n                'limit',\n                'offset',\n                'plain',\n                'scope',\n              ),\n              include: include.include || [],\n            },\n          );\n        }\n\n        const map = await include.association.get(results, {\n          ...omit(options, nonCascadingOptions),\n          ...omit(include, ['parent', 'association', 'as', 'originalAttributes']),\n        });\n\n        for (const result of results) {\n          result.set(include.association.as, map.get(result.get(include.association.sourceKey)), {\n            raw: true,\n          });\n        }\n      }),\n    );\n\n    return original;\n  }\n\n  /**\n   * Search for a single instance by its primary key.\n   *\n   * This applies LIMIT 1, only a single instance will be returned.\n   *\n   * Returns the model with the matching primary key.\n   * If not found, returns null or throws an error if {@link FindOptions.rejectOnEmpty} is set.\n   *\n   * @param  {number|bigint|string|Buffer}      param The value of the desired instance's primary key.\n   * @param  {object}                           [options] find options\n   * @returns {Promise<Model|null>}\n   */\n  static async findByPk(param, options) {\n    // return Promise resolved with null if no arguments are passed\n    if (param == null) {\n      return null;\n    }\n\n    options = cloneDeep(options) ?? {};\n\n    if (\n      typeof param === 'number' ||\n      typeof param === 'bigint' ||\n      typeof param === 'string' ||\n      Buffer.isBuffer(param)\n    ) {\n      options.where = {\n        // TODO: support composite primary keys\n        [this.primaryKeyAttribute]: param,\n      };\n    } else {\n      throw new TypeError(`Argument passed to findByPk is invalid: ${param}`);\n    }\n\n    // Bypass a possible overloaded findOne\n    return await Model.findOne.call(this, options);\n  }\n\n  /**\n   * Search for a single instance.\n   *\n   * Returns the first instance corresponding matching the query.\n   * If not found, returns null or throws an error if {@link FindOptions.rejectOnEmpty} is set.\n   *\n   * @param  {object}       [options] A hash of options to describe the scope of the search\n   * @returns {Promise<Model|null>}\n   */\n  static async findOne(options) {\n    if (options !== undefined && !isPlainObject(options)) {\n      throw new Error(\n        'The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value',\n      );\n    }\n\n    options = cloneDeep(options) ?? {};\n    // findOne only ever needs one result\n    // conditional temporarily fixes 14618\n    // https://github.com/sequelize/sequelize/issues/14618\n    if (options.limit === undefined) {\n      options.limit = 1;\n    }\n\n    // Bypass a possible overloaded findAll.\n    return await Model.findAll.call(\n      this,\n      defaultsLodash(options, {\n        model: this,\n        plain: true,\n      }),\n    );\n  }\n\n  /**\n   * Run an aggregation method on the specified field.\n   *\n   * Returns the aggregate result cast to {@link AggregateOptions.dataType},\n   * unless `options.plain` is false, in which case the complete data result is returned.\n   *\n   * @param {string}          attribute The attribute to aggregate over. Can be a field name or *\n   * @param {string}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.\n   * @param {object}          [options] Query options. See sequelize.query for full options\n   *\n   * @returns {Promise<DataTypes|object>}\n   */\n  static async aggregate(attribute, aggregateFunction, options) {\n    options = cloneDeep(options) ?? {};\n    options.model = this;\n\n    // We need to preserve attributes here as the `injectScope` call would inject non aggregate columns.\n    const prevAttributes = options.attributes;\n    this._injectScope(options);\n    options.attributes = prevAttributes;\n    this._conformIncludes(options, this);\n\n    if (options.include) {\n      this._expandIncludeAll(options);\n      _validateIncludedElements(options);\n    }\n\n    const attrOptions = this.getAttributes()[attribute];\n    const field = (attrOptions && attrOptions.field) || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);\n    }\n\n    let { group } = options;\n    if (Array.isArray(group) && Array.isArray(group[0])) {\n      noDoubleNestedGroup();\n      group = group.flat();\n    }\n\n    options.attributes = unionBy(\n      options.attributes,\n      group,\n      [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]],\n      a => (Array.isArray(a) ? a[1] : a),\n    );\n\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        // Use FLOAT as fallback\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n\n    mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n\n    const value = await this.queryInterface.rawSelect(this.table, options, aggregateFunction, this);\n\n    return value;\n  }\n\n  /**\n   * Count the number of records matching the provided where clause.\n   *\n   * If you provide an `include` option, the number of matching associations will be counted instead.\n   *\n   * @param {object}        [options] options\n   * @returns {Promise<number>}\n   */\n  static async count(options) {\n    options = cloneDeep(options) ?? {};\n    options = defaultsLodash(options, { hooks: true });\n\n    setTransactionFromCls(options, this.sequelize);\n\n    options.raw = true;\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeCount', options);\n    }\n\n    let col = options.col || '*';\n    if (options.include) {\n      col = `${this.name}.${options.col || this.primaryKeyField}`;\n    }\n\n    if (options.distinct && col === '*') {\n      col = this.primaryKeyField;\n    }\n\n    options.plain = !options.group;\n    options.dataType = new DataTypes.INTEGER();\n    options.includeIgnoreAttributes = false;\n\n    // No limit, offset or order for the options max be given to count()\n    // Set them to null to prevent scopes setting those values\n    options.limit = null;\n    options.offset = null;\n    options.order = null;\n\n    const result = await this.aggregate(col, 'count', options);\n\n    // When grouping is used, some dialects such as PG are returning the count as string\n    // --> Manually convert it to number\n    if (Array.isArray(result)) {\n      return result.map(item => ({\n        ...item,\n        count: Number(item.count),\n      }));\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds all the rows matching your query, within a specified offset / limit, and get the total number of\n   * rows matching your query. This is very useful for pagination.\n   *\n   * ```js\n   * Model.findAndCountAll({\n   *   where: ...,\n   *   limit: 12,\n   *   offset: 12\n   * }).then(result => {\n   *   ...\n   * })\n   * ```\n   * In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return\n   * the total number of rows that matched your query.\n   *\n   * When you add includes, only those which are required (either because they have a where clause, or\n   * because required` is explicitly set to true on the include) will be added to the count part.\n   *\n   * Suppose you want to find all users who have a profile attached:\n   * ```js\n   * User.findAndCountAll({\n   *   include: [\n   *      { model: Profile, required: true}\n   *   ],\n   *   limit: 3\n   * });\n   * ```\n   * Because the include for `Profile` has `required` set it will result in an inner join, and only the users\n   * who have a profile will be counted. If we remove `required` from the include, both users with and\n   * without profiles will be counted\n   *\n   * This function also support grouping, when `group` is provided, the count will be an array of objects\n   * containing the count for each group and the projected attributes.\n   * ```js\n   * User.findAndCountAll({\n   *   group: 'type'\n   * });\n   * ```\n   *\n   * @param {object} [options] See findAll options\n   * @returns {Promise<{count: number | number[], rows: Model[]}>}\n   */\n  static async findAndCountAll(options) {\n    if (options !== undefined && !isPlainObject(options)) {\n      throw new Error(\n        'The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value',\n      );\n    }\n\n    const countOptions = cloneDeep(options) ?? {};\n\n    if (countOptions.attributes) {\n      countOptions.attributes = undefined;\n    }\n\n    const [count, rows] = await Promise.all([this.count(countOptions), this.findAll(options)]);\n\n    return {\n      count,\n      rows: count === 0 ? [] : rows,\n    };\n  }\n\n  /**\n   * Finds the maximum value of field\n   *\n   * @param {string} field attribute / field name\n   * @param {object} [options] See aggregate\n   * @returns {Promise<*>}\n   */\n  static async max(field, options) {\n    return await this.aggregate(field, 'max', options);\n  }\n\n  /**\n   * Finds the minimum value of field\n   *\n   * @param {string} field attribute / field name\n   * @param {object} [options] See aggregate\n   * @returns {Promise<*>}\n   */\n  static async min(field, options) {\n    return await this.aggregate(field, 'min', options);\n  }\n\n  /**\n   * Retrieves the sum of field\n   *\n   * @param {string} field attribute / field name\n   * @param {object} [options] See aggregate\n   * @returns {Promise<number>}\n   */\n  static async sum(field, options) {\n    return await this.aggregate(field, 'sum', options);\n  }\n\n  /**\n   * Builds a new model instance.\n   * Unlike {@link Model.create}, the instance is not persisted, you need to call {@link Model#save} yourself.\n   *\n   * @param {object|Array} values An object of key value pairs or an array of such. If an array, the function will return an\n   *   array of instances.\n   * @param {object}  [options] Instance build options\n   *\n   * @returns {Model|Array<Model>}\n   */\n  static build(values, options) {\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n\n    const instance = new this(values, options, CONSTRUCTOR_SECRET);\n\n    // Our Model class adds getters and setters for attributes on the prototype,\n    // so they can be shadowed by native class properties that are defined on the class that extends Model (See #14300).\n    // This deletes the instance properties, to un-shadow the getters and setters.\n    for (const attributeName of this.modelDefinition.attributes.keys()) {\n      delete instance[attributeName];\n    }\n\n    // If there are associations in the instance, we assign them as properties on the instance\n    // so that they can be accessed directly, instead of having to call `get` and `set`.\n    // class properties re-assign them to whatever value was set on the class property (or undefined if none)\n    // so this workaround re-assigns the association after the instance was created.\n    for (const associationName of Object.keys(this.modelDefinition.associations)) {\n      instance[associationName] = instance.getDataValue(associationName);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Builds multiple new model instances.\n   * Unlike {@link Model.create}, the instances are not persisted, you need to call {@link Model#save} yourself.\n   *\n   * @param {Array} valueSets An array of objects with key value pairs.\n   * @param {object}  [options] Instance build options\n   */\n  static bulkBuild(valueSets, options) {\n    options = { isNewRecord: true, ...options };\n\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        _validateIncludedElements(options);\n      }\n    }\n\n    if (options.attributes) {\n      options.attributes = options.attributes.map(attribute => {\n        return Array.isArray(attribute) ? attribute[1] : attribute;\n      });\n    }\n\n    return valueSets.map(values => this.build(values, options));\n  }\n\n  /**\n   * Builds a new model instance and persists it.\n   * Equivalent to calling {@link Model.build} then {@link Model.save}.\n   *\n   * @param {object} values\n   * @param {object} options\n   * @returns {Promise<Model>}\n   */\n  static async create(values, options) {\n    options = cloneDeep(options) ?? {};\n\n    return await this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent,\n    }).save(options);\n  }\n\n  /**\n   * Find an entity that matches the query, or build (but don't save) the entity if none is found.\n   * The successful result of the promise will be the tuple [instance, initialized].\n   *\n   * @param {object} options find options\n   * @returns {Promise<Model,boolean>}\n   */\n  static async findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrBuild. ' +\n          'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)',\n      );\n    }\n\n    let values;\n\n    let instance = await this.findOne(options);\n    if (instance === null) {\n      values = { ...options.defaults };\n      if (isPlainObject(options.where)) {\n        values = defaults(values, options.where);\n      }\n\n      instance = this.build(values, options);\n\n      return [instance, true];\n    }\n\n    return [instance, false];\n  }\n\n  /**\n   * Find an entity that matches the query, or {@link Model.create} the entity if none is found.\n   * The successful result of the promise will be the tuple [instance, initialized].\n   *\n   * If no transaction is passed in the `options` object, a new transaction will be created internally, to\n   * prevent the race condition where a matching row is created by another connection after the find but\n   * before the insert call.\n   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts\n   * and another tries to select before the first one has committed.\n   * In this case, an instance of {@link TimeoutError} will be thrown instead.\n   *\n   * If a transaction is passed, a savepoint will be created instead,\n   * and any unique constraint violation will be handled internally.\n   *\n   * @param {object} options find and create options\n   * @returns {Promise<Model,boolean>}\n   */\n  static async findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\n        'Missing where attribute in the options parameter passed to findOrCreate. ' +\n          'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)',\n      );\n    }\n\n    if (options.connection) {\n      throw new Error(\n        'findOrCreate does not support specifying which connection must be used, because findOrCreate must run in a transaction.',\n      );\n    }\n\n    options = { ...options };\n\n    const modelDefinition = this.modelDefinition;\n\n    if (options.defaults) {\n      const defaults = Object.keys(options.defaults);\n      const unknownDefaults = defaults.filter(name => !modelDefinition.attributes.has(name));\n\n      if (unknownDefaults.length > 0) {\n        logger.warn(\n          `Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`,\n        );\n      }\n    }\n\n    setTransactionFromCls(options, this.sequelize);\n\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n\n    try {\n      // TODO: use managed sequelize.transaction() instead\n      transaction = await this.sequelize.startUnmanagedTransaction(options);\n      options.transaction = transaction;\n\n      const found = await this.findOne(options);\n      if (found !== null) {\n        return [found, false];\n      }\n\n      values = { ...options.defaults };\n      if (isPlainObject(options.where)) {\n        values = defaults(values, options.where);\n      }\n\n      options.exception = true;\n      options.returning = true;\n\n      try {\n        const created = await this.create(values, options);\n        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation\n          throw new SequelizeErrors.UniqueConstraintError();\n        }\n\n        return [created, true];\n      } catch (error) {\n        if (!(error instanceof SequelizeErrors.UniqueConstraintError)) {\n          throw error;\n        }\n\n        const flattenedWhere = flattenObjectDeep(options.where);\n        const flattenedWhereKeys = Object.keys(flattenedWhere).map(name => name.split('.').at(-1));\n        const whereFields = flattenedWhereKeys.map(\n          name => modelDefinition.attributes.get(name)?.columnName ?? name,\n        );\n        const defaultFields =\n          options.defaults &&\n          Object.keys(options.defaults)\n            .filter(name => modelDefinition.attributes.get(name))\n            .map(name => modelDefinition.getColumnNameLoose(name));\n\n        const errFieldKeys = Object.keys(error.fields);\n        const errFieldsWhereIntersects = intersects(errFieldKeys, whereFields);\n        if (defaultFields && !errFieldsWhereIntersects && intersects(errFieldKeys, defaultFields)) {\n          throw error;\n        }\n\n        if (errFieldsWhereIntersects) {\n          each(error.fields, (value, key) => {\n            const name = modelDefinition.columns.get(key).attributeName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(\n                `${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`,\n              );\n            }\n          });\n        }\n\n        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!\n        const otherCreated = await this.findOne(\n          defaults(\n            {\n              transaction: internalTransaction ? null : transaction,\n            },\n            options,\n          ),\n        );\n\n        // Sanity check, ideally we caught this at the defaultFeilds/err.fields check\n        // But if we didn't and instance is null, we will throw\n        if (otherCreated === null) {\n          throw error;\n        }\n\n        return [otherCreated, false];\n      }\n    } finally {\n      if (internalTransaction && transaction) {\n        await transaction.commit();\n      }\n    }\n  }\n\n  /**\n   * A more performant {@link Model.findOrCreate} that will not start its own transaction or savepoint (at least not in\n   * postgres)\n   *\n   * It will execute a find call, attempt to create if empty, then attempt to find again if a unique constraint fails.\n   *\n   * The successful result of the promise will be the tuple [instance, initialized].\n   *\n   * @param {object} options find options\n   * @returns {Promise<Model,boolean>}\n   */\n  static async findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error('Missing where attribute in the options parameter passed to findCreateFind.');\n    }\n\n    let values = { ...options.defaults };\n    if (isPlainObject(options.where)) {\n      values = defaults(values, options.where);\n    }\n\n    const found = await this.findOne(options);\n    if (found) {\n      return [found, false];\n    }\n\n    try {\n      const createOptions = { ...options };\n\n      // To avoid breaking a postgres transaction, run the create with `ignoreDuplicates`.\n      if (this.sequelize.dialect.name === 'postgres' && options.transaction) {\n        createOptions.ignoreDuplicates = true;\n      }\n\n      const created = await this.create(values, createOptions);\n\n      return [created, true];\n    } catch (error) {\n      if (\n        !(\n          error instanceof SequelizeErrors.UniqueConstraintError ||\n          error instanceof SequelizeErrors.EmptyResultError\n        )\n      ) {\n        throw error;\n      }\n\n      const foundAgain = await this.findOne(options);\n\n      return [foundAgain, false];\n    }\n  }\n\n  /**\n   * Inserts or updates a single entity. An update will be executed if a row which matches the supplied values on\n   * either the primary key or a unique key is found. Note that the unique index must be defined in your\n   * sequelize model and not just in the table. Otherwise, you may experience a unique constraint violation,\n   * because sequelize fails to identify the row that should be updated.\n   *\n   * **Implementation details:**\n   *\n   * * MySQL - Implemented as a single query `INSERT values ON DUPLICATE KEY UPDATE values`\n   * * PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN\n   *   unique_constraint UPDATE\n   * * SQLite - Implemented as two queries `INSERT; UPDATE`. This means that the update is executed regardless\n   *   of whether the row already existed or not\n   *\n   * **Note:** SQLite returns null for created, no matter if the row was created or updated. This is\n   * because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know\n   * whether the row was inserted or not.\n   *\n   * @param  {object} values hash of values to upsert\n   * @param  {object} [options] upsert options\n   * @returns {Promise<Array<Model, boolean | null>>} an array with two elements, the first being the new record and\n   *   the second being `true` if it was just created or `false` if it already existed (except on Postgres and SQLite, which\n   *   can't detect this and will always return `null` instead of a boolean).\n   */\n  static async upsert(values, options) {\n    options = {\n      hooks: true,\n      returning: true,\n      validate: true,\n      ...cloneDeep(options),\n    };\n\n    setTransactionFromCls(options, this.sequelize);\n\n    const modelDefinition = this.modelDefinition;\n\n    const createdAtAttr = modelDefinition.timestampAttributeNames.createdAt;\n    const updatedAtAttr = modelDefinition.timestampAttributeNames.updatedAt;\n    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n\n    options.model = this;\n    options.instance = instance;\n\n    const changed = [...instance._changed];\n    if (!options.fields) {\n      options.fields = changed;\n    }\n\n    if (options.validate) {\n      await instance.validate(options);\n    }\n\n    // Map field names\n    const updatedDataValues = pick(instance.dataValues, changed);\n    const insertValues = mapValueFieldNames(\n      instance.dataValues,\n      modelDefinition.attributes.keys(),\n      this,\n    );\n    const updateValues = mapValueFieldNames(updatedDataValues, options.fields, this);\n    const now = new Date();\n\n    // Attach createdAt\n    if (createdAtAttr && !insertValues[createdAtAttr]) {\n      const field = modelDefinition.attributes.get(createdAtAttr).columnName || createdAtAttr;\n      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n    }\n\n    if (updatedAtAttr && !updateValues[updatedAtAttr]) {\n      const field = modelDefinition.attributes.get(updatedAtAttr).columnName || updatedAtAttr;\n      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n\n    // Db2 does not allow NULL values for unique columns.\n    // Add dummy values if not provided by test case or user.\n    if (this.sequelize.dialect.name === 'db2') {\n      // TODO: remove. This is fishy and is going to be a source of bugs (because it replaces null values with arbitrary values that could be actual data).\n      //  If DB2 doesn't support NULL in unique columns, then it should error if the user tries to insert NULL in one.\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(\n        insertValues,\n        this.modelDefinition.rawAttributes,\n        this.uniqno,\n      );\n    }\n\n    // Build adds a null value for the primary key, if none was given by the user.\n    // We need to remove that because of some Postgres technicalities.\n    if (\n      !hasPrimary &&\n      this.primaryKeyAttribute &&\n      !modelDefinition.attributes.get(this.primaryKeyAttribute).defaultValue\n    ) {\n      delete insertValues[this.primaryKeyField];\n      delete updateValues[this.primaryKeyField];\n    }\n\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeUpsert', values, options);\n    }\n\n    const result = await this.queryInterface.upsert(\n      this.table,\n      insertValues,\n      updateValues,\n      // TODO: this is only used by DB2 & MSSQL, as these dialects require a WHERE clause in their UPSERT implementation.\n      //  but the user should be able to specify a WHERE clause themselves (because we can't perfectly include all UNIQUE constraints in our implementation)\n      //  there is also some incoherence in our implementation: This \"where\" returns the Primary Key constraint, but all other unique constraints\n      //  are added inside of QueryInterface. Everything should be done inside of QueryInterface instead.\n      instance.where(false, true) ?? {},\n      options,\n    );\n\n    const [record] = result;\n    record.isNewRecord = false;\n\n    if (options.hooks) {\n      await this.hooks.runAsync('afterUpsert', result, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates and inserts multiple instances in bulk.\n   *\n   * The promise resolves with an array of instances.\n   *\n   * Please note that, depending on your dialect, the resulting instances may not accurately\n   * represent the state of their rows in the database.\n   * This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs\n   * and other default values in a way that can be mapped to multiple records.\n   * To obtain the correct data for the newly created instance, you will need to query for them again.\n   *\n   * If validation fails, the promise is rejected with {@link AggregateError}\n   *\n   * @param  {Array}          records                          List of objects (key/value pairs) to create instances from\n   * @param  {object}         [options]                        Bulk create options\n   * @returns {Promise<Array<Model>>}\n   */\n  static async bulkCreate(records, options = {}) {\n    if (records.length === 0) {\n      return [];\n    }\n\n    const dialect = this.sequelize.dialect.name;\n    const now = new Date();\n    options = cloneDeep(options) ?? {};\n\n    setTransactionFromCls(options, this.sequelize);\n\n    options.model = this;\n\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        _validateIncludedElements(options);\n      }\n    }\n\n    const instances = records.map(values =>\n      this.build(values, { isNewRecord: true, include: options.include }),\n    );\n\n    const recursiveBulkCreate = async (instances, options) => {\n      options = {\n        validate: false,\n        hooks: true,\n        individualHooks: false,\n        ignoreDuplicates: false,\n        ...options,\n      };\n\n      if (options.returning === undefined) {\n        if (options.association) {\n          options.returning = false;\n        } else {\n          options.returning = true;\n        }\n      }\n\n      if (options.ignoreDuplicates && ['mssql', 'db2', 'ibmi'].includes(dialect)) {\n        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);\n      }\n\n      if (\n        options.updateOnDuplicate &&\n        !['mysql', 'mariadb', 'sqlite3', 'postgres', 'ibmi'].includes(dialect)\n      ) {\n        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);\n      }\n\n      const model = options.model;\n      const modelDefinition = model.modelDefinition;\n\n      options.fields = options.fields || Array.from(modelDefinition.attributes.keys());\n      const createdAtAttr = modelDefinition.timestampAttributeNames.createdAt;\n      const updatedAtAttr = modelDefinition.timestampAttributeNames.updatedAt;\n\n      if (options.updateOnDuplicate !== undefined) {\n        if (Array.isArray(options.updateOnDuplicate) && options.updateOnDuplicate.length > 0) {\n          options.updateOnDuplicate = intersection(\n            without(Object.keys(model.tableAttributes), createdAtAttr),\n            options.updateOnDuplicate,\n          );\n        } else {\n          throw new Error('updateOnDuplicate option only supports non-empty array.');\n        }\n      }\n\n      // Run before hook\n      if (options.hooks) {\n        await model.hooks.runAsync('beforeBulkCreate', instances, options);\n      }\n\n      // Validate\n      if (options.validate) {\n        const errors = [];\n        const validateOptions = { ...options };\n        validateOptions.hooks = options.individualHooks;\n\n        await Promise.all(\n          instances.map(async instance => {\n            try {\n              await instance.validate(validateOptions);\n            } catch (error) {\n              errors.push(new SequelizeErrors.BulkRecordError(error, instance));\n            }\n          }),\n        );\n\n        delete options.skip;\n        if (errors.length > 0) {\n          throw new SequelizeErrors.AggregateError(errors);\n        }\n      }\n\n      if (options.individualHooks) {\n        await Promise.all(\n          instances.map(async instance => {\n            const individualOptions = {\n              ...options,\n              validate: false,\n              hooks: true,\n            };\n            delete individualOptions.fields;\n            delete individualOptions.individualHooks;\n            delete individualOptions.ignoreDuplicates;\n\n            await instance.save(individualOptions);\n          }),\n        );\n      } else {\n        if (options.include && options.include.length > 0) {\n          await Promise.all(\n            options.include\n              .filter(include => include.association instanceof BelongsToAssociation)\n              .map(async include => {\n                const associationInstances = [];\n                const associationInstanceIndexToInstanceMap = [];\n\n                for (const instance of instances) {\n                  const associationInstance = instance.get(include.as);\n                  if (associationInstance) {\n                    associationInstances.push(associationInstance);\n                    associationInstanceIndexToInstanceMap.push(instance);\n                  }\n                }\n\n                if (associationInstances.length === 0) {\n                  return;\n                }\n\n                const includeOptions = defaultsLodash(omit(cloneDeep(include), ['association']), {\n                  connection: options.connection,\n                  transaction: options.transaction,\n                  logging: options.logging,\n                });\n\n                const createdAssociationInstances = await recursiveBulkCreate(\n                  associationInstances,\n                  includeOptions,\n                );\n                for (const idx in createdAssociationInstances) {\n                  const associationInstance = createdAssociationInstances[idx];\n                  const instance = associationInstanceIndexToInstanceMap[idx];\n\n                  await include.association.set(instance, associationInstance, {\n                    save: false,\n                    logging: options.logging,\n                  });\n                }\n              }),\n          );\n        }\n\n        // Create all in one query\n        // Recreate records from instances to represent any changes made in hooks or validation\n        records = instances.map(instance => {\n          const values = instance.dataValues;\n\n          // set createdAt/updatedAt attributes\n          if (createdAtAttr && !values[createdAtAttr]) {\n            values[createdAtAttr] = now;\n            if (!options.fields.includes(createdAtAttr)) {\n              options.fields.push(createdAtAttr);\n            }\n          }\n\n          if (updatedAtAttr && !values[updatedAtAttr]) {\n            values[updatedAtAttr] = now;\n            if (!options.fields.includes(updatedAtAttr)) {\n              options.fields.push(updatedAtAttr);\n            }\n          }\n\n          const out = mapValueFieldNames(values, options.fields, model);\n          for (const key of modelDefinition.virtualAttributeNames) {\n            delete out[key];\n          }\n\n          return out;\n        });\n\n        // Map attributes to fields for serial identification\n        const fieldMappedAttributes = Object.create(null);\n        for (const attrName in model.tableAttributes) {\n          const attribute = modelDefinition.attributes.get(attrName);\n          fieldMappedAttributes[attribute.columnName] = attribute;\n        }\n\n        // Map updateOnDuplicate attributes to fields\n        if (options.updateOnDuplicate) {\n          options.updateOnDuplicate = options.updateOnDuplicate.map(attrName => {\n            return modelDefinition.getColumnName(attrName);\n          });\n\n          if (options.conflictAttributes) {\n            options.upsertKeys = options.conflictAttributes.map(attrName =>\n              modelDefinition.getColumnName(attrName),\n            );\n          } else {\n            const upsertKeys = [];\n\n            for (const i of model.getIndexes()) {\n              if (i.unique && !i.where) {\n                // Don't infer partial indexes\n                upsertKeys.push(...i.fields);\n              }\n            }\n\n            options.upsertKeys =\n              upsertKeys.length > 0\n                ? upsertKeys\n                : Object.values(model.primaryKeys).map(x => x.field);\n          }\n        }\n\n        // Map returning attributes to fields\n        if (options.returning && Array.isArray(options.returning)) {\n          options.returning = options.returning.map(attr =>\n            modelDefinition.getColumnNameLoose(attr),\n          );\n        }\n\n        const results = await model.queryInterface.bulkInsert(\n          model.table,\n          records,\n          options,\n          fieldMappedAttributes,\n        );\n        if (Array.isArray(results)) {\n          for (const [i, result] of results.entries()) {\n            const instance = instances[i];\n\n            for (const key in result) {\n              if (!Object.hasOwn(result, key)) {\n                continue;\n              }\n\n              if (\n                !instance ||\n                (key === model.primaryKeyAttribute &&\n                  instance.get(model.primaryKeyAttribute) &&\n                  ['mysql', 'mariadb', 'sqlite3'].includes(dialect))\n              ) {\n                // The query.js for these DBs is blind, it autoincrements the\n                // primarykey value, even if it was set manually. Also, it can\n                // return more results than instances, bug?.\n                continue;\n              }\n\n              const value = result[key];\n              const attr = find(\n                modelDefinition.attributes.values(),\n                attribute => attribute.attributeName === key || attribute.columnName === key,\n              );\n              const attributeName = attr?.attributeName || key;\n              instance.dataValues[attributeName] =\n                value != null && attr?.type instanceof AbstractDataType\n                  ? attr.type.parseDatabaseValue(value)\n                  : value;\n              instance._previousDataValues[attributeName] = instance.dataValues[attributeName];\n            }\n          }\n        }\n      }\n\n      if (options.include && options.include.length > 0) {\n        await Promise.all(\n          options.include\n            .filter(\n              include =>\n                !(\n                  include.association instanceof BelongsToAssociation ||\n                  (include.parent && include.parent.association instanceof BelongsToManyAssociation)\n                ),\n            )\n            .map(async include => {\n              const associationInstances = [];\n              const associationInstanceIndexToInstanceMap = [];\n\n              for (const instance of instances) {\n                let associated = instance.get(include.as);\n                if (!Array.isArray(associated)) {\n                  associated = [associated];\n                }\n\n                for (const associationInstance of associated) {\n                  if (associationInstance) {\n                    if (!(include.association instanceof BelongsToManyAssociation)) {\n                      associationInstance.set(\n                        include.association.foreignKey,\n                        instance.get(\n                          include.association.sourceKey || instance.constructor.primaryKeyAttribute,\n                          { raw: true },\n                        ),\n                        { raw: true },\n                      );\n                      Object.assign(associationInstance, include.association.scope);\n                    }\n\n                    associationInstances.push(associationInstance);\n                    associationInstanceIndexToInstanceMap.push(instance);\n                  }\n                }\n              }\n\n              if (associationInstances.length === 0) {\n                return;\n              }\n\n              const includeOptions = defaultsLodash(omit(cloneDeep(include), ['association']), {\n                connection: options.connection,\n                transaction: options.transaction,\n                logging: options.logging,\n              });\n\n              const createdAssociationInstances = await recursiveBulkCreate(\n                associationInstances,\n                includeOptions,\n              );\n              if (include.association instanceof BelongsToManyAssociation) {\n                const valueSets = [];\n\n                for (const idx in createdAssociationInstances) {\n                  const associationInstance = createdAssociationInstances[idx];\n                  const instance = associationInstanceIndexToInstanceMap[idx];\n\n                  const values = {\n                    [include.association.foreignKey]: instance.get(\n                      instance.constructor.primaryKeyAttribute,\n                      { raw: true },\n                    ),\n                    [include.association.otherKey]: associationInstance.get(\n                      associationInstance.constructor.primaryKeyAttribute,\n                      { raw: true },\n                    ),\n                    // Include values defined in the association\n                    ...include.association.through.scope,\n                  };\n                  if (associationInstance[include.association.through.model.name]) {\n                    const throughDefinition = include.association.through.model.modelDefinition;\n\n                    for (const attributeName of throughDefinition.attributes.keys()) {\n                      const attribute = throughDefinition.attributes.get(attributeName);\n\n                      if (\n                        attribute._autoGenerated ||\n                        attributeName === include.association.foreignKey ||\n                        attributeName === include.association.otherKey ||\n                        typeof associationInstance[include.association.through.model.name][\n                          attributeName\n                        ] === 'undefined'\n                      ) {\n                        continue;\n                      }\n\n                      values[attributeName] =\n                        associationInstance[include.association.through.model.name][attributeName];\n                    }\n                  }\n\n                  valueSets.push(values);\n                }\n\n                const throughOptions = defaultsLodash(\n                  omit(cloneDeep(include), ['association', 'attributes']),\n                  {\n                    connection: options.connection,\n                    transaction: options.transaction,\n                    logging: options.logging,\n                  },\n                );\n                throughOptions.model = include.association.throughModel;\n                const throughInstances = include.association.throughModel.bulkBuild(\n                  valueSets,\n                  throughOptions,\n                );\n\n                await recursiveBulkCreate(throughInstances, throughOptions);\n              }\n            }),\n        );\n      }\n\n      // map fields back to attributes\n      for (const instance of instances) {\n        const attributeDefs = modelDefinition.attributes;\n\n        for (const attribute of attributeDefs.values()) {\n          if (\n            instance.dataValues[attribute.columnName] !== undefined &&\n            attribute.columnName !== attribute.attributeName\n          ) {\n            instance.dataValues[attribute.attributeName] =\n              instance.dataValues[attribute.columnName];\n            // TODO: if a column shares the same name as an attribute, this will cause a bug!\n            delete instance.dataValues[attribute.columnName];\n          }\n\n          instance._previousDataValues[attribute.attributeName] =\n            instance.dataValues[attribute.attributeName];\n          instance.changed(attribute.attributeName, false);\n        }\n\n        instance.isNewRecord = false;\n      }\n\n      // Run after hook\n      if (options.hooks) {\n        await model.hooks.runAsync('afterBulkCreate', instances, options);\n      }\n\n      return instances;\n    };\n\n    return await recursiveBulkCreate(instances, options);\n  }\n\n  /**\n   * Truncates the table associated with the model.\n   *\n   * __Danger__: This will completely empty your table!\n   *\n   * @param {object} [options] truncate options\n   * @returns {Promise}\n   */\n  static async truncate(options) {\n    await this.queryInterface.truncate(this, options);\n  }\n\n  /**\n   * Deletes multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.\n   *\n   * @param  {object} options destroy options\n   * @returns {Promise<number>} The number of destroyed rows\n   */\n  // TODO: add _UNSTABLE_bulkDestroy, aimed to be a replacement,\n  //  which does the same thing but uses `noHooks` instead of `hooks` and `hardDelete` instead of `force`,\n  //  and does not accept `individualHooks`\n  static async destroy(options) {\n    options = cloneDeep(options) ?? {};\n\n    setTransactionFromCls(options, this.sequelize);\n\n    this._injectScope(options);\n\n    if (options && 'truncate' in options) {\n      throw new Error(\n        'Model#destroy does not support the truncate option. Use Model#truncate instead.',\n      );\n    }\n\n    if (!options?.where) {\n      throw new Error(\n        'As a safeguard, the \"destroy\" static model method requires explicitly specifying a \"where\" option. If you actually mean to delete all rows in the table, set the option to a dummy condition such as sql`1 = 1`.',\n      );\n    }\n\n    const modelDefinition = this.modelDefinition;\n    const attributes = modelDefinition.attributes;\n\n    options = defaultsLodash(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n    });\n\n    mapOptionFieldNames(options, this);\n    options.model = this;\n\n    // Run before hook\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeBulkDestroy', options);\n    }\n\n    let instances;\n    // Get daos and run beforeDestroy hook on each record individually\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        connection: options.connection,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n      });\n\n      await Promise.all(\n        instances.map(instance => {\n          return this.hooks.runAsync('beforeDestroy', instance, options);\n        }),\n      );\n    }\n\n    let result;\n    // TODO: rename force -> paranoid: false, as that's how it's called in the instance version\n    // Run delete query (or update if paranoid)\n    if (modelDefinition.timestampAttributeNames.deletedAt && !options.force) {\n      // Set query type appropriately when running soft delete\n      options.type = QueryTypes.BULKUPDATE;\n\n      const attrValueHash = {};\n      const deletedAtAttribute = attributes.get(modelDefinition.timestampAttributeNames.deletedAt);\n      const deletedAtColumnName = deletedAtAttribute.columnName;\n\n      // FIXME: where must be joined with AND instead of using Object.assign. This won't work with literals!\n      const where = {\n        [deletedAtColumnName]: Object.hasOwn(deletedAtAttribute, 'defaultValue')\n          ? deletedAtAttribute.defaultValue\n          : null,\n      };\n\n      attrValueHash[deletedAtColumnName] = new Date();\n      result = await this.queryInterface.bulkUpdate(\n        this.table,\n        attrValueHash,\n        Object.assign(where, options.where),\n        options,\n        getObjectFromMap(modelDefinition.attributes),\n      );\n    } else {\n      result = await this.queryInterface.bulkDelete(this, options);\n    }\n\n    // Run afterDestroy hook on each record individually\n    if (options.individualHooks) {\n      await Promise.all(\n        instances.map(instance => {\n          return this.hooks.runAsync('afterDestroy', instance, options);\n        }),\n      );\n    }\n\n    // Run after hook\n    if (options.hooks) {\n      await this.hooks.runAsync('afterBulkDestroy', options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Restores multiple paranoid instances.\n   * Only usable if {@link ModelOptions.paranoid} is true.\n   *\n   * @param {object} options restore options\n   * @returns {Promise}\n   */\n  static async restore(options) {\n    const modelDefinition = this.modelDefinition;\n\n    if (!modelDefinition.timestampAttributeNames.deletedAt) {\n      throw new Error('Model is not paranoid');\n    }\n\n    options = {\n      hooks: true,\n      individualHooks: false,\n      ...options,\n    };\n\n    setTransactionFromCls(options, this.sequelize);\n\n    options.type = QueryTypes.RAW;\n    options.model = this;\n\n    mapOptionFieldNames(options, this);\n\n    // Run before hook\n    if (options.hooks) {\n      await this.hooks.runAsync('beforeBulkRestore', options);\n    }\n\n    let instances;\n    // Get daos and run beforeRestore hook on each record individually\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        connection: options.connection,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n        paranoid: false,\n      });\n\n      await Promise.all(\n        instances.map(instance => {\n          return this.hooks.runAsync('beforeRestore', instance, options);\n        }),\n      );\n    }\n\n    // Run undelete query\n    const attrValueHash = {};\n    const deletedAtAttributeName = modelDefinition.timestampAttributeNames.deletedAt;\n    const deletedAtAttribute = modelDefinition.attributes.get(deletedAtAttributeName);\n    const deletedAtDefaultValue = deletedAtAttribute.defaultValue ?? null;\n\n    attrValueHash[deletedAtAttribute.columnName || deletedAtAttributeName] = deletedAtDefaultValue;\n    options.omitNull = false;\n    const result = await this.queryInterface.bulkUpdate(\n      this.table,\n      attrValueHash,\n      options.where,\n      options,\n      getObjectFromMap(modelDefinition.attributes),\n    );\n    // Run afterDestroy hook on each record individually\n    if (options.individualHooks) {\n      await Promise.all(\n        instances.map(instance => {\n          return this.hooks.runAsync('afterRestore', instance, options);\n        }),\n      );\n    }\n\n    // Run after hook\n    if (options.hooks) {\n      await this.hooks.runAsync('afterBulkRestore', options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Updates multiple instances that match the where options.\n   *\n   * The promise resolves with an array of one or two elements:\n   * - The first element is always the number of affected rows,\n   * - the second element is the list of affected entities (only supported in postgres and mssql with\n   * {@link UpdateOptions.returning} true.)\n   *\n   * @param  {object} values hash of values to update\n   * @param  {object} options update options\n   * @returns {Promise<Array<number,number>>}\n   */\n  static async update(values, options) {\n    options = cloneDeep(options) ?? {};\n\n    setTransactionFromCls(options, this.sequelize);\n\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n\n    const modelDefinition = this.modelDefinition;\n\n    options = this._paranoidClause(\n      this,\n      defaultsLodash(options, {\n        validate: true,\n        hooks: true,\n        individualHooks: false,\n        returning: false,\n        force: false,\n        sideEffects: true,\n      }),\n    );\n\n    options.type = QueryTypes.BULKUPDATE;\n\n    // Clone values so it doesn't get modified for caller scope and ignore undefined values\n    values = omitBy(values, value => value === undefined);\n\n    const updatedAtAttrName = modelDefinition.timestampAttributeNames.updatedAt;\n\n    // Remove values that are not in the options.fields\n    if (options.fields && Array.isArray(options.fields)) {\n      for (const key of Object.keys(values)) {\n        if (!options.fields.includes(key)) {\n          delete values[key];\n        }\n      }\n    } else {\n      options.fields = intersection(\n        Object.keys(values),\n        Array.from(modelDefinition.physicalAttributes.keys()),\n      );\n      if (updatedAtAttrName && !options.fields.includes(updatedAtAttrName)) {\n        options.fields.push(updatedAtAttrName);\n      }\n    }\n\n    if (updatedAtAttrName && !options.silent) {\n      values[updatedAtAttrName] = this._getDefaultTimestamp(updatedAtAttrName) || new Date();\n    }\n\n    options.model = this;\n\n    let valuesUse;\n    // Validate\n    if (options.validate) {\n      const build = this.build(values);\n      build.set(updatedAtAttrName, values[updatedAtAttrName], { raw: true });\n\n      if (options.sideEffects) {\n        Object.assign(values, pick(build.get(), build.changed()));\n        options.fields = union(options.fields, Object.keys(values));\n      }\n\n      // TODO: instead of setting \"skip\", set the \"fields\" property on a copy of options that's passed to \"validate\"\n      // We want to skip validations for all other fields\n      options.skip = difference(Array.from(modelDefinition.attributes.keys()), Object.keys(values));\n      const attributes = await build.validate(options);\n      options.skip = undefined;\n      if (attributes && attributes.dataValues) {\n        values = pick(attributes.dataValues, Object.keys(values));\n      }\n    }\n\n    // Run before hook\n    if (options.hooks) {\n      options.attributes = values;\n      await this.hooks.runAsync('beforeBulkUpdate', options);\n      values = options.attributes;\n      delete options.attributes;\n    }\n\n    valuesUse = values;\n\n    // Get instances and run beforeUpdate hook on each record individually\n    let instances;\n    let updateDoneRowByRow = false;\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        connection: options.connection,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n        paranoid: options.paranoid,\n      });\n\n      if (instances.length > 0) {\n        // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly\n        // i.e. whether they change values for each record in the same way\n        let changedValues;\n        let different = false;\n\n        instances = await Promise.all(\n          instances.map(async instance => {\n            // Record updates in instances dataValues\n            Object.assign(instance.dataValues, values);\n            // Set the changed fields on the instance\n            forIn(valuesUse, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                instance.setDataValue(attr, newValue);\n              }\n            });\n\n            // Run beforeUpdate hook\n            await this.hooks.runAsync('beforeUpdate', instance, options);\n            await this.hooks.runAsync('beforeSave', instance, options);\n            if (!different) {\n              const thisChangedValues = {};\n              forIn(instance.dataValues, (newValue, attr) => {\n                if (newValue !== instance._previousDataValues[attr]) {\n                  thisChangedValues[attr] = newValue;\n                }\n              });\n\n              if (!changedValues) {\n                changedValues = thisChangedValues;\n              } else {\n                different = !isEqual(changedValues, thisChangedValues);\n              }\n            }\n\n            return instance;\n          }),\n        );\n\n        if (!different) {\n          const keys = Object.keys(changedValues);\n          // Hooks do not change values or change them uniformly\n          if (keys.length > 0) {\n            // Hooks change values - record changes in valuesUse so they are executed\n            valuesUse = changedValues;\n            options.fields = union(options.fields, keys);\n          }\n        } else {\n          instances = await Promise.all(\n            instances.map(async instance => {\n              const individualOptions = {\n                ...options,\n                hooks: false,\n                validate: false,\n              };\n              delete individualOptions.individualHooks;\n\n              return instance.save(individualOptions);\n            }),\n          );\n          updateDoneRowByRow = true;\n        }\n      }\n    }\n\n    let result;\n    if (updateDoneRowByRow) {\n      result = [instances.length, instances];\n    } else if (\n      isEmpty(valuesUse) ||\n      (Object.keys(valuesUse).length === 1 && valuesUse[updatedAtAttrName])\n    ) {\n      // only updatedAt is being passed, then skip update\n      result = [0];\n    } else {\n      valuesUse = mapValueFieldNames(valuesUse, options.fields, this);\n      options = mapOptionFieldNames(options, this);\n      options.hasTrigger = this.options ? this.options.hasTrigger : false;\n\n      const affectedRows = await this.queryInterface.bulkUpdate(\n        this.table,\n        valuesUse,\n        options.where,\n        options,\n        getObjectFromMap(this.modelDefinition.physicalAttributes),\n      );\n      if (options.returning) {\n        result = [affectedRows.length, affectedRows];\n        instances = affectedRows;\n      } else {\n        result = [affectedRows];\n      }\n    }\n\n    if (options.individualHooks) {\n      await Promise.all(\n        instances.map(async instance => {\n          await this.hooks.runAsync('afterUpdate', instance, options);\n          await this.hooks.runAsync('afterSave', instance, options);\n        }),\n      );\n      result[1] = instances;\n    }\n\n    // Run after hook\n    if (options.hooks) {\n      options.attributes = values;\n      await this.hooks.runAsync('afterBulkUpdate', options);\n      delete options.attributes;\n    }\n\n    return result;\n  }\n\n  /**\n   * Runs a describe query on the table.\n   *\n   * @param {string} [schema] schema name to search table in\n   * @param {object} [options] query options\n   *\n   * @returns {Promise} hash of attributes and their types\n   */\n  // TODO: move \"schema\" to options\n  static async describe(schema, options) {\n    const table = this.modelDefinition.table;\n\n    return await this.queryInterface.describeTable(\n      { ...table, schema: schema || table.schema },\n      options,\n    );\n  }\n\n  static _getDefaultTimestamp(attributeName) {\n    const attributes = this.modelDefinition.attributes;\n\n    const attribute = attributes.get(attributeName);\n    if (attribute?.defaultValue) {\n      return toDefaultValue(attribute.defaultValue);\n    }\n  }\n\n  static _expandAttributes(options) {\n    if (!isPlainObject(options.attributes)) {\n      return;\n    }\n\n    let attributes = Array.from(this.modelDefinition.attributes.keys());\n\n    if (options.attributes.exclude) {\n      attributes = attributes.filter(elem => !options.attributes.exclude.includes(elem));\n    }\n\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n\n    options.attributes = attributes;\n  }\n\n  // Inject _scope into options.\n  static _injectScope(options) {\n    const scope = cloneDeep(this._scope) ?? {};\n    this._normalizeIncludes(scope, this);\n    this._defaultsOptions(options, scope);\n  }\n\n  static [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.name;\n  }\n\n  static hasAlias(alias) {\n    return Object.hasOwn(this.associations, alias);\n  }\n\n  static getAssociations(target) {\n    return Object.values(this.associations).filter(\n      association => association.target.name === target.name,\n    );\n  }\n\n  static getAssociationWithModel(targetModel, targetAlias) {\n    if (targetAlias) {\n      return this.getAssociation(targetAlias);\n    }\n\n    if (!targetModel) {\n      throwInvalidInclude({ model: targetModel, as: targetAlias });\n    }\n\n    const matchingAssociations = this._getAssociationsByModel(targetModel);\n    if (matchingAssociations.length === 0) {\n      throw new SequelizeErrors.EagerLoadingError(\n        `Invalid Include received: no associations exist between \"${this.name}\" and \"${targetModel.name}\"`,\n      );\n    }\n\n    if (matchingAssociations.length > 1) {\n      throw new SequelizeErrors.EagerLoadingError(\n        `\nAmbiguous Include received:\nYou're trying to include the model \"${targetModel.name}\", but is associated to \"${this.name}\" multiple times.\n\nInstead of specifying a Model, either:\n1. pass one of the Association object (available in \"${this.name}.associations\") in the \"association\" option, e.g.:\n   include: {\n     association: ${this.name}.associations.${matchingAssociations[0].as},\n   },\n\n2. pass the name of one of the associations in the \"association\" option, e.g.:\n   include: {\n     association: '${matchingAssociations[0].as}',\n   },\n\n\"${this.name}\" is associated to \"${targetModel.name}\" through the following associations: ${matchingAssociations.map(association => `\"${association.as}\"`).join(', ')}\n`.trim(),\n      );\n    }\n\n    return matchingAssociations[0];\n  }\n\n  /**\n   * Increments the value of one or more attributes.\n   *\n   * The increment is done using a `SET column = column + X WHERE foo = 'bar'` query.\n   *\n   * @example increment number by 1\n   * ```ts\n   * Model.increment('number', { where: { foo: 'bar' });\n   * ```\n   *\n   * @example increment number and count by 2\n   * ```ts\n   * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });\n   * ```\n   *\n   * @example increment answer by 42, and decrement tries by 1\n   * ```ts\n   * // `by` cannot be used, as each attribute specifies its own value\n   * Model.increment({ answer: 42, tries: -1}, { where: { foo: 'bar' } });\n   * ```\n   *\n   * @param  {string|Array|object} fields If a string is provided, that column is incremented by the\n   *   value of `by` given in options. If an array is provided, the same is true for each column.\n   *   If an object is provided, each key is incremented by the corresponding value, `by` is ignored.\n   * @param  {object} options increment options\n   * @param  {object} options.where conditions hash\n   *\n   * @returns {Promise<Model[],?number>} an array of affected rows and affected count with `options.returning` true,\n   *   whenever supported by dialect\n   */\n  static async increment(fields, options) {\n    options ||= {};\n    if (typeof fields === 'string') {\n      fields = [fields];\n    }\n\n    const modelDefinition = this.modelDefinition;\n    const attributeDefs = modelDefinition.attributes;\n\n    if (Array.isArray(fields)) {\n      fields = fields.map(attributeName => {\n        const attributeDef = attributeDefs.get(attributeName);\n        if (attributeDef && attributeDef.columnName !== attributeName) {\n          return attributeDef.columnName;\n        }\n\n        return attributeName;\n      });\n    } else if (fields && typeof fields === 'object') {\n      fields = Object.keys(fields).reduce((rawFields, attributeName) => {\n        const attributeDef = attributeDefs.get(attributeName);\n        if (attributeDef && attributeDef.columnName !== attributeName) {\n          rawFields[attributeDef.columnName] = fields[attributeName];\n        } else {\n          rawFields[attributeName] = fields[attributeName];\n        }\n\n        return rawFields;\n      }, {});\n    }\n\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n\n    options = defaults({}, options, {\n      by: 1,\n      where: {},\n      increment: true,\n    });\n    const isSubtraction = !options.increment;\n\n    mapOptionFieldNames(options, this);\n\n    const where = { ...options.where };\n\n    // A plain object whose keys are the fields to be incremented and whose values are\n    // the amounts to be incremented by.\n    let incrementAmountsByField = {};\n    if (Array.isArray(fields)) {\n      incrementAmountsByField = {};\n      for (const field of fields) {\n        incrementAmountsByField[field] = options.by;\n      }\n    } else {\n      // If the `fields` argument is not an array, then we assume it already has the\n      // form necessary to be placed directly in the `incrementAmountsByField` variable.\n      incrementAmountsByField = fields;\n    }\n\n    // If optimistic locking is enabled, we can take advantage that this is an\n    // increment/decrement operation and send it here as well. We put `-1` for\n    // decrementing because it will be subtracted, getting `-(-1)` which is `+1`\n    if (modelDefinition.versionAttributeName) {\n      incrementAmountsByField[modelDefinition.versionAttributeName] = isSubtraction ? -1 : 1;\n    }\n\n    const extraAttributesToBeUpdated = {};\n\n    const updatedAtAttrName = modelDefinition.timestampAttributeNames.updatedAt;\n    if (!options.silent && updatedAtAttrName && !incrementAmountsByField[updatedAtAttrName]) {\n      const columnName = modelDefinition.getColumnName(updatedAtAttrName);\n      extraAttributesToBeUpdated[columnName] =\n        this._getDefaultTimestamp(updatedAtAttrName) || new Date();\n    }\n\n    const tableName = this.table;\n    let affectedRows;\n    if (isSubtraction) {\n      affectedRows = await this.queryInterface.decrement(\n        this,\n        tableName,\n        where,\n        incrementAmountsByField,\n        extraAttributesToBeUpdated,\n        options,\n      );\n    } else {\n      affectedRows = await this.queryInterface.increment(\n        this,\n        tableName,\n        where,\n        incrementAmountsByField,\n        extraAttributesToBeUpdated,\n        options,\n      );\n    }\n\n    if (options.returning) {\n      return [affectedRows, affectedRows.length];\n    }\n\n    return [affectedRows];\n  }\n\n  /**\n   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values\n   * currently stored on the Instance. The decrement is done using a\n   * ```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance\n   * you should do a reload.\n   *\n   * @example decrement number by 1\n   * ```ts\n   * Model.decrement('number', { where: { foo: 'bar' });\n   * ```\n   *\n   * @example decrement number and count by 2\n   * ```ts\n   * Model.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });\n   * ```\n   *\n   * @example decrement answer by 42, and decrement tries by -1\n   * ```ts\n   * // `by` is ignored, since each column has its own value\n   * Model.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });\n   * ```\n   *\n   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in\n   *   options. If an array is provided, the same is true for each column. If and object is provided, each column is\n   *   incremented by the value given.\n   * @param {object} options decrement options, similar to increment\n   *\n   * @since 4.36.0\n   *\n   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true,\n   *   whenever supported by dialect\n   */\n  static async decrement(fields, options) {\n    return this.increment(fields, {\n      by: 1,\n      ...options,\n      increment: false,\n    });\n  }\n\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, 'Missing where attribute in the options parameter');\n    assert(\n      isPlainObject(options.where) ||\n        Array.isArray(options.where) ||\n        options.where instanceof BaseSqlExpression,\n      'Expected plain object, array or sequelize method in the options.where parameter',\n    );\n  }\n\n  /**\n   * Returns a Where Object that can be used to uniquely select this instance, using the instance's primary keys.\n   *\n   * @param {boolean} [checkVersion=false] include version attribute in where hash\n   * @param {boolean} [nullIfImpossible=false] return null instead of throwing an error if the instance is missing its\n   *   primary keys and therefore no Where object can be built.\n   *\n   * @returns {object}\n   */\n  where(checkVersion, nullIfImpossible) {\n    return getModelPkWhere(this, checkVersion, nullIfImpossible);\n  }\n\n  toString() {\n    return `[object SequelizeInstance:${this.constructor.name}]`;\n  }\n\n  /**\n   * Returns the underlying data value\n   *\n   * Unlike {@link Model#get}, this method returns the value as it was retrieved, bypassing\n   * getters, cloning, virtual attributes.\n   *\n   * @param {string} key The name of the attribute to return.\n   * @returns {any}\n   */\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n\n  /**\n   * Updates the underlying data value\n   *\n   * Unlike {@link Model#set}, this method skips any special behavior and directly replaces the raw value.\n   *\n   * @param {string} key The name of the attribute to update.\n   * @param {any} value The new value for that attribute.\n   */\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n\n    if (!isEqual(value, originalValue)) {\n      this.changed(key, true);\n    }\n\n    this.dataValues[key] = value;\n  }\n\n  /**\n   * If no key is given, returns all values of the instance, also invoking virtual getters.\n   *\n   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the\n   * value for key.\n   *\n   * @param {string}  [attributeName] key to get value of\n   * @param {object}  [options] get options\n   *\n   * @returns {object|any}\n   */\n  get(attributeName, options) {\n    if (options === undefined && typeof attributeName === 'object') {\n      options = attributeName;\n      attributeName = undefined;\n    }\n\n    options ??= EMPTY_OBJECT;\n\n    const { attributes, attributesWithGetters } = this.modelDefinition;\n\n    if (attributeName) {\n      const attribute = attributes.get(attributeName);\n      if (attribute?.get && !options.raw) {\n        return attribute.get.call(this, attributeName, options);\n      }\n\n      if (\n        options.plain &&\n        this._options.include &&\n        this._options.includeNames.includes(attributeName)\n      ) {\n        if (Array.isArray(this.dataValues[attributeName])) {\n          return this.dataValues[attributeName].map(instance => instance.get(options));\n        }\n\n        if (this.dataValues[attributeName] instanceof Model) {\n          return this.dataValues[attributeName].get(options);\n        }\n\n        return this.dataValues[attributeName];\n      }\n\n      return this.dataValues[attributeName];\n    }\n\n    // TODO: move to its own method instead of overloading.\n    if (\n      attributesWithGetters.size > 0 ||\n      (options.plain && this._options.include) ||\n      options.clone\n    ) {\n      const values = Object.create(null);\n      if (attributesWithGetters.size > 0) {\n        for (const attributeName2 of attributesWithGetters) {\n          if (!this._options.attributes?.includes(attributeName2)) {\n            continue;\n          }\n\n          values[attributeName2] = this.get(attributeName2, options);\n        }\n      }\n\n      for (const attributeName2 in this.dataValues) {\n        if (\n          !Object.hasOwn(values, attributeName2) &&\n          Object.hasOwn(this.dataValues, attributeName2)\n        ) {\n          values[attributeName2] = this.get(attributeName2, options);\n        }\n      }\n\n      return values;\n    }\n\n    return this.dataValues;\n  }\n\n  /**\n   * Set is used to update values on the instance (the Sequelize representation of the instance that is, remember that\n   * nothing will be persisted before you actually call `save`). In its most basic form `set` will update a value stored in\n   * the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function will be\n   * called instead. To bypass the setter, you can pass `raw: true` in the options object.\n   *\n   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If\n   * you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend\n   * dataValues, if dataValues already contain values.\n   *\n   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).\n   *\n   * Set can also be used to build instances for associations, if you have values for those.\n   * When using set with associations you need to make sure the property key matches the alias of the association\n   * while also making sure that the proper include options have been set (from .build() or .findOne())\n   *\n   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as\n   * changed.\n   *\n   * @param {string|object} key key to set, it can be string or object. When string it will set that key, for object it will\n   *   loop over all object properties nd set them.\n   * @param {any} value value to set\n   * @param {object} [options] set options\n   *\n   * @returns {Model}\n   */\n  set(key, value, options) {\n    let values;\n    let originalValue;\n\n    const modelDefinition = this.modelDefinition;\n\n    if (typeof key === 'object' && key !== null) {\n      values = key;\n      options = value || {};\n\n      if (options.reset) {\n        this.dataValues = {};\n        for (const key in values) {\n          this.changed(key, false);\n        }\n      }\n\n      const hasDateAttributes = modelDefinition.dateAttributeNames.size > 0;\n      const hasBooleanAttributes = modelDefinition.booleanAttributeNames.size > 0;\n\n      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object\n      if (\n        options.raw &&\n        !(this._options && this._options.include) &&\n        !(options && options.attributes) &&\n        !hasDateAttributes &&\n        !hasBooleanAttributes\n      ) {\n        if (Object.keys(this.dataValues).length > 0) {\n          Object.assign(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n\n        // If raw, .changed() shouldn't be true\n        this._previousDataValues = { ...this.dataValues };\n      } else {\n        // Loop and call set\n        if (options.attributes) {\n          const setKeys = data => {\n            for (const k of data) {\n              if (values[k] === undefined) {\n                continue;\n              }\n\n              this.set(k, values[k], options);\n            }\n          };\n\n          setKeys(options.attributes);\n\n          const virtualAttributes = modelDefinition.virtualAttributeNames;\n          if (virtualAttributes.size > 0) {\n            setKeys(virtualAttributes);\n          }\n\n          if (this._options.includeNames) {\n            setKeys(this._options.includeNames);\n          }\n        } else {\n          for (const key in values) {\n            this.set(key, values[key], options);\n          }\n        }\n\n        if (options.raw) {\n          // If raw, .changed() shouldn't be true\n          this._previousDataValues = { ...this.dataValues };\n        }\n      }\n\n      return this;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n\n    const attributeDefinition = modelDefinition.attributes.get(key);\n\n    // If not raw, and there's a custom setter\n    if (!options.raw && attributeDefinition?.set) {\n      attributeDefinition.set.call(this, value, key);\n      // custom setter should have changed value, get that changed value\n      // TODO: v5 make setters return new value instead of changing internal store\n      const newValue = this.dataValues[key];\n      if (!isEqual(newValue, originalValue)) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      // Check if we have included models, and if this key matches the include model names/aliases\n      if (this._options && this._options.include && this._options.includeNames.includes(key)) {\n        // Pass it on to the include handler\n        this._setInclude(key, value, options);\n\n        return this;\n      }\n\n      // Bunch of stuff we won't do when it's raw\n      if (!options.raw) {\n        // If the attribute is not in model definition, return\n        if (!attributeDefinition) {\n          const jsonAttributeNames = modelDefinition.jsonAttributeNames;\n\n          if (key.includes('.') && jsonAttributeNames.has(key.split('.')[0])) {\n            const previousNestedValue = Dottie.get(this.dataValues, key);\n            if (!isEqual(previousNestedValue, value)) {\n              Dottie.set(this.dataValues, key, value);\n              this.changed(key.split('.')[0], true);\n            }\n          }\n\n          return this;\n        }\n\n        // If attempting to set primary key and primary key is already defined, return\n        const primaryKeyNames = modelDefinition.primaryKeysAttributeNames;\n        if (originalValue && primaryKeyNames.has(key)) {\n          return this;\n        }\n\n        // TODO: throw an error when trying to set a read only attribute with to a different value\n        // If attempting to set read only attributes, return\n        const readOnlyAttributeNames = modelDefinition.readOnlyAttributeNames;\n        if (!this.isNewRecord && readOnlyAttributeNames.has(key)) {\n          return this;\n        }\n      }\n\n      // If there's a data type sanitizer\n      const attributeType = attributeDefinition?.type;\n      if (\n        !options.comesFromDatabase &&\n        value != null &&\n        !(value instanceof BaseSqlExpression) &&\n        attributeType &&\n        // \"type\" can be a string\n        attributeType instanceof AbstractDataType\n      ) {\n        value = attributeType.sanitize(value, options);\n      }\n\n      // Set when the value has changed and not raw\n      if (\n        !options.raw &&\n        // True when sequelize method\n        (value instanceof BaseSqlExpression ||\n          // Otherwise, check for data type type comparators\n          (value != null &&\n            attributeType &&\n            attributeType instanceof AbstractDataType &&\n            !attributeType.areValuesEqual(value, originalValue, options)) ||\n          ((value == null || !attributeType || !(attributeType instanceof AbstractDataType)) &&\n            !isEqual(value, originalValue)))\n      ) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n\n      // set data value\n      this.dataValues[key] = value;\n    }\n\n    return this;\n  }\n\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n\n  /**\n   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is\n   * different from the value in `_previousDataValues`.\n   *\n   * If changed is called without an argument, it will return an array of keys that have changed.\n   *\n   * If changed is called without an argument and no keys have changed, it will return `false`.\n   *\n   * Please note that this function will return `false` when a property from a nested (for example JSON) property\n   * was edited manually, you must call `changed('key', true)` manually in these cases.\n   * Writing an entirely new object (eg. deep cloned) will be detected.\n   *\n   * @example\n   * ```\n   * const mdl = await MyModel.findOne();\n   * mdl.myJsonField.a = 1;\n   * console.log(mdl.changed()) => false\n   * mdl.save(); // this will not save anything\n   * mdl.changed('myJsonField', true);\n   * console.log(mdl.changed()) => ['myJsonField']\n   * mdl.save(); // will save\n   * ```\n   *\n   * @param {string} [key] key to check or change status of\n   * @param {any} [value] value to set\n   *\n   * @returns {boolean|Array}\n   */\n  changed(key, value) {\n    if (key === undefined) {\n      if (this._changed.size > 0) {\n        return [...this._changed];\n      }\n\n      return false;\n    }\n\n    if (value === true) {\n      this._changed.add(key);\n\n      return this;\n    }\n\n    if (value === false) {\n      this._changed.delete(key);\n\n      return this;\n    }\n\n    return this._changed.has(key);\n  }\n\n  /**\n   * Returns the previous value for key from `_previousDataValues`.\n   *\n   * If called without a key, returns the previous values for all values which have changed\n   *\n   * @param {string} [key] key to get previous value of\n   *\n   * @returns {any|Array<any>}\n   */\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n\n    return pickBy(this._previousDataValues, (value, key) => this.changed(key));\n  }\n\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n\n    if (value[0] instanceof Model) {\n      value = value.map(instance => instance.dataValues);\n    }\n\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const primaryKeyAttribute = include.model.primaryKeyAttribute;\n    const childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes,\n      comesFromDatabase: options.comesFromDatabase,\n    };\n    let isEmpty;\n\n    if (include.originalAttributes === undefined || include.originalAttributes.length > 0) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n\n        isEmpty = (value && value[primaryKeyAttribute] === null) || value === null;\n        this[key] = this.dataValues[key] = isEmpty\n          ? null\n          : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[key] = this.dataValues[key] = isEmpty\n          ? []\n          : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n\n  /**\n   * Validates this instance, and if the validation passes, persists it to the database.\n   *\n   * Returns a Promise that resolves to the saved instance (or rejects with a {@link ValidationError},\n   * which will have a property for each of the fields for which the validation failed, with the error message for that\n   * field).\n   *\n   * This method is optimized to perform an UPDATE only into the fields that changed.\n   * If nothing has changed, no SQL query will be performed.\n   *\n   * This method is not aware of eager loaded associations.\n   * In other words, if some other model instance (child) was eager loaded with this instance (parent),\n   * and you change something in the child, calling `save()` will simply ignore the change that happened on the child.\n   *\n   * @param {object} [options] save options\n   * @returns {Promise<Model>}\n   */\n  async save(options) {\n    if (arguments.length > 1) {\n      throw new Error('The second argument was removed in favor of the options object.');\n    }\n\n    options = cloneDeep(options) ?? {};\n    options = defaultsLodash(options, {\n      hooks: true,\n      validate: true,\n    });\n\n    setTransactionFromCls(options, this.sequelize);\n\n    const modelDefinition = this.modelDefinition;\n\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Array.from(modelDefinition.attributes.keys());\n      } else {\n        options.fields = intersection(\n          this.changed(),\n          Array.from(modelDefinition.attributes.keys()),\n        );\n      }\n\n      options.defaultFields = options.fields;\n    }\n\n    if (options.returning === undefined) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n\n    // TODO: use modelDefinition.primaryKeyAttributes (plural!)\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && modelDefinition.attributes.get(primaryKeyName);\n    const createdAtAttr = modelDefinition.timestampAttributeNames.createdAt;\n    const versionAttr = modelDefinition.versionAttributeName;\n    const hook = this.isNewRecord ? 'Create' : 'Update';\n    const wasNewRecord = this.isNewRecord;\n    const now = new Date();\n    let updatedAtAttr = modelDefinition.timestampAttributeNames.updatedAt;\n\n    if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {\n      options.fields.push(updatedAtAttr);\n    }\n\n    if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {\n      options.fields.push(versionAttr);\n    }\n\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {\n      // UpdateAtAttr might have been added as a result of Object.keys(Model.rawAttributes). In that case we have to remove it again\n      remove(options.fields, val => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {\n        options.fields.push(createdAtAttr);\n      }\n\n      if (\n        primaryKeyAttribute &&\n        primaryKeyAttribute.defaultValue &&\n        !options.fields.includes(primaryKeyName)\n      ) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n\n    if (\n      this.isNewRecord === false &&\n      primaryKeyName &&\n      this.get(primaryKeyName, { raw: true }) === undefined\n    ) {\n      throw new Error(\n        'You attempted to save an instance with no primary key, this is not allowed since it would result in a global update',\n      );\n    }\n\n    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n\n    // Db2 does not allow NULL values for unique columns.\n    // Add dummy values if not provided by test case or user.\n    if (this.sequelize.dialect.name === 'db2' && this.isNewRecord) {\n      // TODO: remove. This is fishy and is going to be a source of bugs (because it replaces null values with arbitrary values that could be actual data).\n      //  If DB2 doesn't support NULL in unique columns, then it should error if the user tries to insert NULL in one.\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(\n        this.dataValues,\n        modelDefinition.rawAttributes,\n        this.uniqno,\n      );\n    }\n\n    // Validate\n    if (options.validate) {\n      await this.validate(options);\n    }\n\n    // Run before hook\n    if (options.hooks) {\n      const beforeHookValues = pick(this.dataValues, options.fields);\n      let ignoreChanged = difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values\n      let hookChanged;\n      let afterHookValues;\n\n      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {\n        ignoreChanged = without(ignoreChanged, updatedAtAttr);\n      }\n\n      await this.constructor.hooks.runAsync(`before${hook}`, this, options);\n      await this.constructor.hooks.runAsync(`beforeSave`, this, options);\n      if (options.defaultFields && !this.isNewRecord) {\n        afterHookValues = pick(this.dataValues, difference(this.changed(), ignoreChanged));\n\n        hookChanged = [];\n        for (const key of Object.keys(afterHookValues)) {\n          if (afterHookValues[key] !== beforeHookValues[key]) {\n            hookChanged.push(key);\n          }\n        }\n\n        options.fields = uniq(options.fields.concat(hookChanged));\n      }\n\n      if (hookChanged && options.validate) {\n        // Validate again\n\n        options.skip = difference(Array.from(modelDefinition.attributes.keys()), hookChanged);\n        await this.validate(options);\n        delete options.skip;\n      }\n    }\n\n    if (\n      options.fields.length > 0 &&\n      this.isNewRecord &&\n      this._options.include &&\n      this._options.include.length > 0\n    ) {\n      await Promise.all(\n        this._options.include\n          .filter(include => include.association instanceof BelongsToAssociation)\n          .map(async include => {\n            const instance = this.get(include.as);\n            if (!instance) {\n              return;\n            }\n\n            const includeOptions = defaultsLodash(omit(cloneDeep(include), ['association']), {\n              connection: options.connection,\n              transaction: options.transaction,\n              logging: options.logging,\n              parentRecord: this,\n            });\n\n            await instance.save(includeOptions);\n\n            await this[include.association.accessors.set](instance, {\n              save: false,\n              logging: options.logging,\n            });\n          }),\n      );\n    }\n\n    const realFields = options.fields.filter(\n      attributeName => !modelDefinition.virtualAttributeNames.has(attributeName),\n    );\n    if (realFields.length === 0) {\n      return this;\n    }\n\n    const versionColumnName = versionAttr && modelDefinition.getColumnName(versionAttr);\n    const values = mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n    let query;\n    let args;\n    let where;\n\n    if (!this.isNewRecord) {\n      where = this.where(true);\n      if (versionAttr) {\n        values[versionColumnName] = Number.parseInt(values[versionColumnName], 10) + 1;\n      }\n\n      query = 'update';\n      args = [this, this.constructor.table, values, where, options];\n    }\n\n    if (!this.changed() && !this.isNewRecord) {\n      return this;\n    }\n\n    if (this.isNewRecord) {\n      query = 'insert';\n      args = [this, this.constructor.table, values, options];\n    }\n\n    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);\n\n    if (versionAttr) {\n      // Check to see that a row was updated, otherwise it's an optimistic locking error.\n      if (rowsUpdated < 1) {\n        throw new SequelizeErrors.OptimisticLockError({\n          modelName: this.constructor.name,\n          values,\n          where,\n        });\n      } else {\n        result.dataValues[versionAttr] = values[versionColumnName];\n      }\n    }\n\n    // Transfer database generated values (defaults, autoincrement, etc)\n    for (const attribute of modelDefinition.attributes.values()) {\n      if (\n        attribute.columnName &&\n        values[attribute.columnName] !== undefined &&\n        attribute.columnName !== attribute.attributeName\n      ) {\n        values[attribute.attributeName] = values[attribute.columnName];\n        // TODO: if a column uses the same name as an attribute, this will break!\n        delete values[attribute.columnName];\n      }\n    }\n\n    Object.assign(values, result.dataValues);\n\n    Object.assign(result.dataValues, values);\n    if (wasNewRecord && this._options.include && this._options.include.length > 0) {\n      await Promise.all(\n        this._options.include\n          .filter(\n            include =>\n              !(\n                include.association instanceof BelongsToAssociation ||\n                (include.parent && include.parent.association instanceof BelongsToManyAssociation)\n              ),\n          )\n          .map(async include => {\n            let instances = this.get(include.as);\n\n            if (!instances) {\n              return;\n            }\n\n            if (!Array.isArray(instances)) {\n              instances = [instances];\n            }\n\n            const includeOptions = defaultsLodash(omit(cloneDeep(include), ['association']), {\n              connection: options.connection,\n              transaction: options.transaction,\n              logging: options.logging,\n              parentRecord: this,\n            });\n\n            // Instances will be updated in place so we can safely treat HasOne like a HasMany\n            await Promise.all(\n              instances.map(async instance => {\n                if (include.association instanceof BelongsToManyAssociation) {\n                  await instance.save(includeOptions);\n                  const values0 = {\n                    [include.association.foreignKey]: this.get(\n                      this.constructor.primaryKeyAttribute,\n                      { raw: true },\n                    ),\n                    [include.association.otherKey]: instance.get(\n                      instance.constructor.primaryKeyAttribute,\n                      { raw: true },\n                    ),\n                    // Include values defined in the association\n                    ...include.association.through.scope,\n                  };\n\n                  const throughModel = include.association.through.model;\n                  if (instance[throughModel.name]) {\n                    const throughDefinition = throughModel.modelDefinition;\n                    for (const attribute of throughDefinition.attributes.values()) {\n                      const { attributeName } = attribute;\n\n                      if (\n                        attribute._autoGenerated ||\n                        attributeName === include.association.foreignKey ||\n                        attributeName === include.association.otherKey ||\n                        typeof instance[throughModel.name][attributeName] === 'undefined'\n                      ) {\n                        continue;\n                      }\n\n                      values0[attributeName] = instance[throughModel.name][attributeName];\n                    }\n                  }\n\n                  await include.association.throughModel.create(values0, includeOptions);\n                } else {\n                  instance.set(\n                    include.association.foreignKey,\n                    this.get(\n                      include.association.sourceKey || this.constructor.primaryKeyAttribute,\n                      { raw: true },\n                    ),\n                    { raw: true },\n                  );\n                  Object.assign(instance, include.association.scope);\n                  await instance.save(includeOptions);\n                }\n              }),\n            );\n          }),\n      );\n    }\n\n    // Run after hook\n    if (options.hooks) {\n      await this.constructor.hooks.runAsync(`after${hook}`, result, options);\n      await this.constructor.hooks.runAsync(`afterSave`, result, options);\n    }\n\n    for (const field of options.fields) {\n      result._previousDataValues[field] = result.dataValues[field];\n      this.changed(field, false);\n    }\n\n    this.isNewRecord = false;\n\n    return result;\n  }\n\n  /**\n   * Refreshes the current instance in-place, i.e. update the object with current data from the DB and return\n   * the same object. This is different from doing a `find(Instance.id)`, because that would create and\n   * return a new instance. With this method, all references to the Instance are updated with the new data\n   * and no new objects are created.\n   *\n   * @param {object} [options] Options that are passed on to `Model.find`\n   *\n   * @returns {Promise<Model>}\n   */\n  async reload(options) {\n    options = defaults({ where: this.where() }, options, {\n      include: this._options.include || undefined,\n    });\n\n    const reloaded = await this.constructor.findOne(options);\n    if (!reloaded) {\n      throw new SequelizeErrors.InstanceError(\n        'Instance could not be reloaded because it does not exist anymore (find call returned null)',\n      );\n    }\n\n    // update the internal options of the instance\n    this._options = reloaded._options;\n    // re-set instance values\n    this.set(reloaded.dataValues, {\n      raw: true,\n      reset: !options.attributes,\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate the attribute of this instance according to validation rules set in the model definition.\n   *\n   * Emits null if and only if validation successful; otherwise an Error instance containing\n   * { field name : [error msgs] } entries.\n   *\n   * @param {object} [options] Options that are passed to the validator\n   * @returns {Promise}\n   */\n  async validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n\n  /**\n   * This is the same as calling {@link Model#set} followed by calling {@link Model#save},\n   * but it only saves attributes values passed to it, making it safer.\n   *\n   * @param {object} values See `set`\n   * @param {object} options See `save`\n   *\n   * @returns {Promise<Model>}\n   */\n  async update(values, options) {\n    // Clone values so it doesn't get modified for caller scope and ignore undefined values\n    values = omitBy(values, value => value === undefined);\n\n    const changedBefore = this.changed() || [];\n\n    if (this.isNewRecord) {\n      throw new Error('You attempted to update an instance that is not persisted.');\n    }\n\n    options ??= EMPTY_OBJECT;\n    if (Array.isArray(options)) {\n      options = { fields: options };\n    }\n\n    options = cloneDeep(options);\n    const setOptions = cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n\n    // Now we need to figure out which fields were actually affected by the setter.\n    const sideEffects = without(this.changed(), ...changedBefore);\n    const fields = union(Object.keys(values), sideEffects);\n\n    if (!options.fields) {\n      options.fields = intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n\n    return await this.save(options);\n  }\n\n  /**\n   * Destroys the row corresponding to this instance. Depending on your setting for paranoid, the row will either be\n   * completely deleted, or have its deletedAt timestamp set to the current time.\n   *\n   * @param {object} [options={}] destroy options\n   * @returns {Promise}\n   */\n  async destroy(options) {\n    options = {\n      hooks: true,\n      force: false,\n      ...options,\n    };\n\n    setTransactionFromCls(options, this.sequelize);\n\n    const modelDefinition = this.modelDefinition;\n\n    // Run before hook\n    if (options.hooks) {\n      await modelDefinition.hooks.runAsync('beforeDestroy', this, options);\n    }\n\n    let result;\n    if (modelDefinition.timestampAttributeNames.deletedAt && options.force === false) {\n      const attributeName = modelDefinition.timestampAttributeNames.deletedAt;\n      const attribute = modelDefinition.attributes.get(attributeName);\n      const defaultValue = attribute.defaultValue ?? null;\n      const currentValue = this.getDataValue(attributeName);\n      const undefinedOrNull = currentValue == null && defaultValue == null;\n      if (undefinedOrNull || isEqual(currentValue, defaultValue)) {\n        // only update timestamp if it wasn't already set\n        this.setDataValue(attributeName, new Date());\n      }\n\n      result = await this.save({ ...options, hooks: false });\n    } else {\n      // TODO: replace \"hooks\" with \"noHooks\" in this method and call ModelRepository.destroy instead of queryInterface.delete\n      const where = this.where(true);\n\n      result = await this.constructor.queryInterface.bulkDelete(this.constructor, {\n        limit: null,\n        ...options,\n        where,\n      });\n    }\n\n    // Run after hook\n    if (options.hooks) {\n      await modelDefinition.hooks.runAsync('afterDestroy', this, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns true if this instance is \"soft deleted\".\n   * Throws an error if {@link ModelOptions.paranoid} is not enabled.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/paranoid/} to learn more about soft deletion / paranoid models.\n   *\n   * @returns {boolean}\n   */\n  isSoftDeleted() {\n    const modelDefinition = this.modelDefinition;\n\n    const deletedAtAttributeName = modelDefinition.timestampAttributeNames.deletedAt;\n    if (!deletedAtAttributeName) {\n      throw new Error('Model is not paranoid');\n    }\n\n    const deletedAtAttribute = modelDefinition.attributes.get(deletedAtAttributeName);\n    const defaultValue = deletedAtAttribute.defaultValue ?? null;\n    const deletedAt = this.get(deletedAtAttributeName) || null;\n    const isSet = deletedAt !== defaultValue;\n\n    return isSet;\n  }\n\n  /**\n   * Restores the row corresponding to this instance.\n   * Only available for paranoid models.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/paranoid/} to learn more about soft deletion / paranoid models.\n   *\n   * @param {object}      [options={}] restore options\n   * @returns {Promise}\n   */\n  async restore(options) {\n    const modelDefinition = this.modelDefinition;\n    const deletedAtAttributeName = modelDefinition.timestampAttributeNames.deletedAt;\n\n    if (!deletedAtAttributeName) {\n      throw new Error('Model is not paranoid');\n    }\n\n    options = {\n      hooks: true,\n      force: false,\n      ...options,\n    };\n\n    setTransactionFromCls(options, this.sequelize);\n\n    // Run before hook\n    if (options.hooks) {\n      await this.constructor.hooks.runAsync('beforeRestore', this, options);\n    }\n\n    const deletedAtAttribute = modelDefinition.attributes.get(deletedAtAttributeName);\n    const deletedAtDefaultValue = deletedAtAttribute.defaultValue ?? null;\n\n    this.setDataValue(deletedAtAttributeName, deletedAtDefaultValue);\n    const result = await this.save({ ...options, hooks: false, omitNull: false });\n    // Run after hook\n    if (options.hooks) {\n      await this.constructor.hooks.runAsync('afterRestore', this, options);\n\n      return result;\n    }\n\n    return result;\n  }\n\n  /**\n   * Increment the value of one or more columns. This is done in the database, which means it does not use the values\n   * currently stored on the Instance. The increment is done using a\n   * ```sql\n   * SET column = column + X\n   * ```\n   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a\n   * reload to get the new values.\n   *\n   * @example\n   * instance.increment('number') // increment number by 1\n   *\n   * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2\n   *\n   * // increment answer by 42, and tries by 1.\n   * // `by` is ignored, since each column has its own value\n   * instance.increment({ answer: 42, tries: 1}, { by: 2 })\n   *\n   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in\n   *   options. If an array is provided, the same is true for each column. If and object is provided, each column is\n   *   incremented by the value given.\n   * @param {object} [options] options\n   *\n   * @returns {Promise<Model>}\n   * @since 4.0.0\n   */\n  async increment(fields, options) {\n    const identifier = this.where();\n\n    options = cloneDeep(options) ?? {};\n    options.where = { ...options.where, ...identifier };\n    options.instance = this;\n\n    await this.constructor.increment(fields, options);\n\n    return this;\n  }\n\n  /**\n   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values\n   * currently stored on the Instance. The decrement is done using a\n   * ```sql\n   * SET column = column - X\n   * ```\n   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a\n   * reload to get the new values.\n   *\n   * @example\n   * instance.decrement('number') // decrement number by 1\n   *\n   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2\n   *\n   * // decrement answer by 42, and tries by 1.\n   * // `by` is ignored, since each column has its own value\n   * instance.decrement({ answer: 42, tries: 1}, { by: 2 })\n   *\n   * @param {string|Array|object} fields If a string is provided, that column is decremented by the value of `by` given in\n   *   options. If an array is provided, the same is true for each column. If and object is provided, each column is\n   *   decremented by the value given\n   * @param {object}      [options] decrement options\n   * @returns {Promise}\n   */\n  async decrement(fields, options) {\n    return this.increment(fields, {\n      by: 1,\n      ...options,\n      increment: false,\n    });\n  }\n\n  /**\n   * Check whether this and `other` Instance refer to the same row\n   *\n   * @param {Model} other Other instance to compare against\n   *\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!other || !(other instanceof Model)) {\n      return false;\n    }\n\n    const modelDefinition = this.modelDefinition;\n    const otherModelDefinition = this.modelDefinition;\n\n    if (modelDefinition !== otherModelDefinition) {\n      return false;\n    }\n\n    return every(modelDefinition.primaryKeysAttributeNames, attribute => {\n      return this.get(attribute, { raw: true }) === other.get(attribute, { raw: true });\n    });\n  }\n\n  /**\n   * Check if this is equal to one of `others` by calling equals\n   *\n   * @param {Array<Model>} others An array of instances to check against\n   *\n   * @returns {boolean}\n   */\n  equalsOneOf(others) {\n    return others.some(other => this.equals(other));\n  }\n\n  /**\n   * Convert the instance to a JSON representation.\n   * Proxies to calling `get` with no keys.\n   * This means get all values gotten from the DB, and apply all custom getters.\n   *\n   * @see\n   * {@link Model#get}\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    return cloneDeepLodash(\n      this.get({\n        plain: true,\n      }),\n    );\n  }\n\n  /**\n   * Defines a 1:n association between two models.\n   * The foreign key is added on the target model.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/assocs/} to learn more about associations.\n   *\n   * @example\n   * ```javascript\n   * Profile.hasMany(User)\n   * ```\n   *\n   * @param {Model} target The model that will be associated with a hasMany relationship\n   * @param {object} options Options for the association\n   * @returns {HasManyAssociation} The newly defined association (also available in {@link Model.associations}).\n   */\n  static hasMany(target, options) {\n    return HasManyAssociation.associate(AssociationSecret, this, target, options);\n  }\n\n  /**\n   * Create an N:M association with a join table. Defining `through` is required.\n   * The foreign keys are added on the through model.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/assocs/} to learn more about associations.\n   *\n   * @example\n   * ```javascript\n   * // Automagically generated join model\n   * User.belongsToMany(Project, { through: 'UserProjects' })\n   *\n   * // Join model with additional attributes\n   * const UserProjects = sequelize.define('UserProjects', {\n   *   started: DataTypes.BOOLEAN\n   * })\n   * User.belongsToMany(Project, { through: UserProjects })\n   * ```\n   *\n   * @param {Model} target Target model\n   * @param {object} options belongsToMany association options\n   * @returns {BelongsToManyAssociation} The newly defined association (also available in {@link Model.associations}).\n   */\n  static belongsToMany(target, options) {\n    return BelongsToManyAssociation.associate(AssociationSecret, this, target, options);\n  }\n\n  /**\n   * Creates a 1:1 association between this model (the source) and the provided target.\n   * The foreign key is added on the target model.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/assocs/} to learn more about associations.\n   *\n   * @example\n   * ```javascript\n   * User.hasOne(Profile)\n   * ```\n   *\n   * @param {Model} target The model that will be associated with hasOne relationship\n   * @param {object} [options] hasOne association options\n   * @returns {HasOneAssociation} The newly defined association (also available in {@link Model.associations}).\n   */\n  static hasOne(target, options) {\n    return HasOneAssociation.associate(AssociationSecret, this, target, options);\n  }\n\n  /**\n   * Creates an association between this (the source) and the provided target.\n   * The foreign key is added on the source Model.\n   *\n   * See {@link https://sequelize.org/docs/v7/core-concepts/assocs/} to learn more about associations.\n   *\n   * @example\n   * ```javascript\n   * Profile.belongsTo(User)\n   * ```\n   *\n   * @param {Model} target The target model\n   * @param {object} [options] belongsTo association options\n   * @returns {BelongsToAssociation} The newly defined association (also available in {@link Model.associations}).\n   */\n  static belongsTo(target, options) {\n    return BelongsToAssociation.associate(AssociationSecret, this, target, options);\n  }\n}\n\n/**\n * Unpacks an object that only contains a single Op.and key to the value of Op.and\n *\n * Internal method used by {@link combineWheresWithAnd}\n *\n * @param {WhereOptions} where The object to unpack\n * @example `{ [Op.and]: [a, b] }` becomes `[a, b]`\n * @example `{ [Op.and]: { key: val } }` becomes `{ key: val }`\n * @example `{ [Op.or]: [a, b] }` remains as `{ [Op.or]: [a, b] }`\n * @example `{ [Op.and]: [a, b], key: c }` remains as `{ [Op.and]: [a, b], key: c }`\n * @private\n */\nfunction unpackAnd(where) {\n  if (!isObject(where)) {\n    return where;\n  }\n\n  const keys = getComplexKeys(where);\n\n  // object is empty, remove it.\n  if (keys.length === 0) {\n    return;\n  }\n\n  // we have more than just Op.and, keep as-is\n  if (keys.length !== 1 || keys[0] !== Op.and) {\n    return where;\n  }\n\n  const andParts = where[Op.and];\n\n  return andParts;\n}\n\nfunction combineWheresWithAnd(whereA, whereB) {\n  const unpackedA = unpackAnd(whereA);\n\n  if (unpackedA === undefined) {\n    return whereB;\n  }\n\n  const unpackedB = unpackAnd(whereB);\n\n  if (unpackedB === undefined) {\n    return whereA;\n  }\n\n  return {\n    [Op.and]: [unpackedA, unpackedB].flat(),\n  };\n}\n"],
  "mappings": "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",
  "names": ["omit", "defaults", "mapValues", "cloneDeepLodash", "get", "NodeUtil", "isPlainObject", "includes", "forEach", "each", "defaultsLodash", "flattenDepth", "assignWith", "union", "objValue", "srcValue", "isEqual", "isEmpty", "intersection", "uniq", "unionBy", "pick", "instances", "options", "without", "omitBy", "difference", "forIn", "assert", "key", "Dottie", "pickBy", "remove", "isObject"]
}
