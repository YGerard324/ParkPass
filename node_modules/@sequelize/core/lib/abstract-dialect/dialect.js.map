{
  "version": 3,
  "sources": ["../../src/abstract-dialect/dialect.ts"],
  "sourcesContent": ["import { EMPTY_OBJECT, freezeDeep, getImmutablePojo, isFunction, isString } from '@sequelize/utils';\nimport cloneDeep from 'lodash/cloneDeep';\nimport merge from 'lodash/merge';\nimport type { Class } from 'type-fest';\nimport type { DialectName, Sequelize } from '../sequelize.js';\nimport { logger } from '../utils/logger.js';\nimport type { DeepPartial } from '../utils/types.js';\nimport type { AbstractConnectionManager } from './connection-manager.js';\nimport type { AbstractDataType } from './data-types.js';\nimport * as BaseDataTypes from './data-types.js';\nimport type { AbstractQueryGenerator } from './query-generator.js';\nimport type { AbstractQueryInterface } from './query-interface.js';\nimport type { AbstractQuery } from './query.js';\n\nexport interface SupportableNumericOptions {\n  zerofill: boolean;\n  /** Whether this dialect supports the unsigned option natively */\n  unsigned: boolean;\n}\n\nexport interface SupportableDecimalNumberOptions extends SupportableNumericOptions {\n  /** Whether NaN can be inserted in a column that uses this DataType. */\n  NaN: boolean;\n  /** Whether Infinity/-Infinity can be inserted in a column that uses this DataType. */\n  infinity: boolean;\n}\n\nexport interface SupportableFloatOptions extends SupportableDecimalNumberOptions {\n  /** Whether scale & precision can be specified as parameters */\n  scaleAndPrecision: boolean;\n}\n\nexport interface SupportableExactDecimalOptions extends SupportableDecimalNumberOptions {\n  /**\n   * Whether this dialect supports unconstrained numeric/decimal columns. i.e. columns where numeric values of any length can be stored.\n   * The SQL standard requires that \"NUMERIC\" with no option be equal to \"NUMERIC(0,0)\", but some dialects (postgres)\n   * interpret it as an unconstrained numeric.\n   */\n  unconstrained: boolean;\n\n  /**\n   * Whether this dialect supports constrained numeric/decimal columns. i.e. columns where numeric values of any length can be stored.\n   */\n  constrained: boolean;\n}\n\nexport type DialectSupports = {\n  DEFAULT: boolean;\n  'DEFAULT VALUES': boolean;\n  'VALUES ()': boolean;\n  // TODO: rename to `update.limit`\n  'LIMIT ON UPDATE': boolean;\n  'ON DUPLICATE KEY': boolean;\n  'ORDER NULLS': boolean;\n  UNION: boolean;\n  'UNION ALL': boolean;\n  'RIGHT JOIN': boolean;\n  EXCEPTION: boolean;\n\n  forShare?: 'LOCK IN SHARE MODE' | 'FOR SHARE' | undefined;\n  lock: boolean;\n  lockOf: boolean;\n  lockKey: boolean;\n  lockOuterJoinFailure: boolean;\n  skipLocked: boolean;\n  finalTable: boolean;\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false | 'output' | 'returning';\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: boolean;\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: boolean;\n\n    /* does the dialect support updating autoincrement fields */\n    update: boolean;\n  };\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: boolean;\n  /**\n   * Whether this dialect has native support for schemas.\n   * For the purposes of Sequelize, a Schema is considered to be a grouping of tables.\n   * For instance, in MySQL, \"CREATE DATABASE\" creates what we consider to be a schema.\n   */\n  schemas: boolean;\n  /**\n   * Whether this dialect has native support for having multiple databases per instance (in the postgres or mssql sense).\n   * For the purposes of Sequelize, a database is considered to be a grouping of schemas.\n   * For instance, in MySQL, \"CREATE DATABASE\" creates what we consider to be a schema,\n   * so we do not consider that MySQL supports this option.\n   */\n  multiDatabases: boolean;\n  transactions: boolean;\n  savepoints: boolean;\n  isolationLevels: boolean;\n  connectionTransactionMethods: boolean;\n  settingIsolationLevelDuringTransaction: boolean;\n  startTransaction: {\n    useBegin: boolean;\n    readOnly: boolean;\n    transactionType: boolean;\n  };\n  migrations: boolean;\n  upserts: boolean;\n  inserts: {\n    ignoreDuplicates: string /* dialect specific words for INSERT IGNORE or DO NOTHING */;\n    updateOnDuplicate: boolean | string /* whether dialect supports ON DUPLICATE KEY UPDATE */;\n    onConflictDoNothing: string /* dialect specific words for ON CONFLICT DO NOTHING */;\n    onConflictWhere: boolean /* whether dialect supports ON CONFLICT WHERE */;\n    conflictFields: boolean /* whether the dialect supports specifying conflict fields or not */;\n  };\n  constraints: {\n    restrict: boolean;\n    /**\n     * This dialect supports marking a column's constraints as deferrable.\n     * e.g. 'DEFERRABLE' and 'INITIALLY DEFERRED'\n     */\n    deferrable: boolean;\n    unique: boolean;\n    default: boolean;\n    check: boolean;\n    foreignKey: boolean;\n    /** Whether this dialect supports disabling foreign key checks for the current session */\n    foreignKeyChecksDisableable: boolean;\n    primaryKey: boolean;\n    onUpdate: boolean;\n    add: boolean;\n    remove: boolean;\n    removeOptions: {\n      cascade: boolean;\n      ifExists: boolean;\n    };\n  };\n  index: {\n    collate: boolean;\n    length: boolean;\n    parser: boolean;\n    concurrently: boolean;\n    type: boolean;\n    using: boolean | number;\n    functionBased: boolean;\n    operator: boolean;\n    where: boolean;\n    include: boolean;\n  };\n  groupedLimit: boolean;\n  indexViaAlter: boolean;\n  alterColumn: {\n    /**\n     * Can \"ALTER TABLE x ALTER COLUMN y\" add UNIQUE to the column in this dialect?\n     */\n    unique: boolean;\n  };\n  dataTypes: {\n    CHAR: boolean;\n    /**\n     * Whether this dialect provides a binary collation on text, varchar & char columns.\n     */\n    COLLATE_BINARY: boolean;\n    /** This dialect supports case-insensitive text */\n    CITEXT: boolean;\n    /** Options supportable by all int types (from tinyint to bigint) */\n    INTS: SupportableNumericOptions;\n    /** @deprecated */\n    REAL: SupportableFloatOptions;\n    /** This dialect supports 4 byte long floating point numbers */\n    FLOAT: SupportableFloatOptions;\n    /** This dialect supports 8 byte long floating point numbers */\n    DOUBLE: SupportableFloatOptions;\n    /** This dialect supports arbitrary precision numbers */\n    DECIMAL: false | SupportableExactDecimalOptions;\n    /** This dialect supports big integers */\n    BIGINT: boolean;\n    /**\n     * The dialect is considered to support JSON if it provides either:\n     * - A JSON data type.\n     * - An SQL function that can be used as a CHECK constraint on a text column, to ensure its contents are valid JSON.\n     */\n    JSON: boolean;\n    JSONB: boolean;\n    ARRAY: boolean;\n    RANGE: boolean;\n    GEOMETRY: boolean;\n    GEOGRAPHY: boolean;\n    HSTORE: boolean;\n    TSVECTOR: boolean;\n    CIDR: boolean;\n    INET: boolean;\n    MACADDR: boolean;\n    MACADDR8: boolean;\n    DATETIME: {\n      /** Whether \"infinity\" is a valid value in this dialect's DATETIME data type */\n      infinity: boolean;\n    };\n    DATEONLY: {\n      /** Whether \"infinity\" is a valid value in this dialect's DATEONLY data type */\n      infinity: boolean;\n    };\n    TIME: {\n      /** Whether the dialect supports TIME(precision) */\n      precision: boolean;\n    };\n  };\n  REGEXP: boolean;\n  /**\n   * Case-insensitive regexp operator support ('~*' in postgres).\n   */\n  IREGEXP: boolean;\n  /** Whether this dialect supports SQL JSON functions */\n  jsonOperations: boolean;\n  /** Whether this dialect supports returning quoted & unquoted JSON strings  */\n  jsonExtraction: {\n    unquoted: boolean;\n    quoted: boolean;\n  };\n  tmpTableTrigger: boolean;\n  indexHints: boolean;\n  tableHints: boolean;\n  searchPath: boolean;\n  /**\n   * This dialect supports E-prefixed strings, e.g. \"E'foo'\", which\n   * enables the ability to use backslash escapes inside the string.\n   */\n  escapeStringConstants: boolean;\n\n  /** Whether this dialect supports changing the global timezone option */\n  globalTimeZoneConfig: boolean;\n  /** Whether this dialect provides a native way to generate UUID v1 values */\n  uuidV1Generation: boolean;\n  /** Whether this dialect provides a native way to generate UUID v4 values */\n  uuidV4Generation: boolean;\n  dropTable: {\n    cascade: boolean;\n  };\n  maxExecutionTimeHint: {\n    select: boolean;\n  };\n  truncate: {\n    cascade: boolean;\n    restartIdentity: boolean;\n  };\n  removeColumn: {\n    cascade: boolean;\n    ifExists: boolean;\n  };\n  renameTable: {\n    changeSchema: boolean;\n    changeSchemaAndTable: boolean;\n  };\n  createSchema: {\n    authorization: boolean;\n    charset: boolean;\n    collate: boolean;\n    comment: boolean;\n    ifNotExists: boolean;\n    replace: boolean;\n  };\n  dropSchema: {\n    cascade: boolean;\n    ifExists: boolean;\n  };\n  delete: {\n    limit: boolean;\n  };\n};\n\ntype TypeParser = (...params: any[]) => unknown;\n\ndeclare const OptionType: unique symbol;\ndeclare const ConnectionOptionType: unique symbol;\n\nexport type DialectOptions<Dialect extends AbstractDialect> = Dialect[typeof OptionType];\nexport type ConnectionOptions<Dialect extends AbstractDialect> =\n  Dialect[typeof ConnectionOptionType];\n\nexport type AbstractDialectParams<Options> = {\n  dataTypeOverrides: Record<string, Class<AbstractDataType<any>>>;\n  dataTypesDocumentationUrl: string;\n  /**\n   * The character used to delimit identifiers in SQL queries.\n   *\n   * This can be a string, in which case the character will be used for both the start & end of the identifier,\n   * or an object with `start` and `end` properties.\n   */\n  identifierDelimiter: string | { start: string; end: string };\n  minimumDatabaseVersion: string;\n  name: DialectName;\n  options: Options | undefined;\n  sequelize: Sequelize;\n};\n\nexport abstract class AbstractDialect<\n  Options extends object = object,\n  TConnectionOptions extends object = object,\n> {\n  declare [OptionType]: Options;\n  declare [ConnectionOptionType]: TConnectionOptions;\n\n  /**\n   * List of features this dialect supports.\n   *\n   * Important: Dialect implementations inherit these values.\n   * When changing a default, ensure the implementations still properly declare which feature they support.\n   */\n  static readonly supports: DialectSupports = freezeDeep({\n    DEFAULT: true,\n    'DEFAULT VALUES': false,\n    'VALUES ()': false,\n    'LIMIT ON UPDATE': false,\n    'ON DUPLICATE KEY': true,\n    'ORDER NULLS': false,\n    UNION: true,\n    'UNION ALL': true,\n    'RIGHT JOIN': true,\n    EXCEPTION: false,\n    lock: false,\n    lockOf: false,\n    lockKey: false,\n    lockOuterJoinFailure: false,\n    skipLocked: false,\n    finalTable: false,\n    returnValues: false,\n    autoIncrement: {\n      identityInsert: false,\n      defaultValue: true,\n      update: true,\n    },\n    bulkDefault: false,\n    schemas: false,\n    multiDatabases: false,\n    transactions: true,\n    savepoints: true,\n    isolationLevels: true,\n    connectionTransactionMethods: false,\n    settingIsolationLevelDuringTransaction: true,\n    startTransaction: {\n      useBegin: false,\n      readOnly: false,\n      transactionType: false,\n    },\n    migrations: true,\n    upserts: true,\n    inserts: {\n      ignoreDuplicates: '',\n      updateOnDuplicate: false,\n      onConflictDoNothing: '',\n      onConflictWhere: false,\n      conflictFields: false,\n    },\n    constraints: {\n      restrict: true,\n      deferrable: false,\n      unique: true,\n      default: false,\n      check: true,\n      foreignKey: true,\n      foreignKeyChecksDisableable: false,\n      primaryKey: true,\n      onUpdate: true,\n      add: true,\n      remove: true,\n      removeOptions: {\n        cascade: false,\n        ifExists: false,\n      },\n    },\n    index: {\n      collate: true,\n      length: false,\n      parser: false,\n      concurrently: false,\n      type: false,\n      using: true,\n      functionBased: false,\n      operator: false,\n      where: false,\n      include: false,\n    },\n    groupedLimit: true,\n    indexViaAlter: false,\n    alterColumn: {\n      unique: true,\n    },\n    dataTypes: {\n      CHAR: true,\n      COLLATE_BINARY: false,\n      CITEXT: false,\n      INTS: { zerofill: false, unsigned: false },\n      FLOAT: {\n        NaN: false,\n        infinity: false,\n        zerofill: false,\n        unsigned: false,\n        scaleAndPrecision: false,\n      },\n      REAL: {\n        NaN: false,\n        infinity: false,\n        zerofill: false,\n        unsigned: false,\n        scaleAndPrecision: false,\n      },\n      DOUBLE: {\n        NaN: false,\n        infinity: false,\n        zerofill: false,\n        unsigned: false,\n        scaleAndPrecision: false,\n      },\n      DECIMAL: {\n        constrained: true,\n        unconstrained: false,\n        NaN: false,\n        infinity: false,\n        zerofill: false,\n        unsigned: false,\n      },\n      BIGINT: true,\n      CIDR: false,\n      MACADDR: false,\n      MACADDR8: false,\n      INET: false,\n      JSON: false,\n      JSONB: false,\n      ARRAY: false,\n      RANGE: false,\n      GEOMETRY: false,\n      GEOGRAPHY: false,\n      HSTORE: false,\n      TSVECTOR: false,\n      DATETIME: {\n        infinity: false,\n      },\n      DATEONLY: {\n        infinity: false,\n      },\n      TIME: {\n        precision: true,\n      },\n    },\n    jsonOperations: false,\n    jsonExtraction: {\n      unquoted: false,\n      quoted: false,\n    },\n    REGEXP: false,\n    IREGEXP: false,\n    tmpTableTrigger: false,\n    indexHints: false,\n    tableHints: false,\n    searchPath: false,\n    escapeStringConstants: false,\n    globalTimeZoneConfig: false,\n    uuidV1Generation: false,\n    uuidV4Generation: false,\n    dropTable: {\n      cascade: false,\n    },\n    maxExecutionTimeHint: {\n      select: false,\n    },\n    truncate: {\n      cascade: false,\n      restartIdentity: false,\n    },\n    removeColumn: {\n      cascade: false,\n      ifExists: false,\n    },\n    renameTable: {\n      changeSchema: true,\n      changeSchemaAndTable: true,\n    },\n    createSchema: {\n      authorization: false,\n      charset: false,\n      collate: false,\n      comment: false,\n      ifNotExists: false,\n      replace: false,\n    },\n    dropSchema: {\n      cascade: false,\n      ifExists: false,\n    },\n    delete: {\n      limit: true,\n    },\n  });\n\n  protected static extendSupport(supportsOverwrite: DeepPartial<DialectSupports>): DialectSupports {\n    return merge(cloneDeep(this.supports) ?? {}, supportsOverwrite);\n  }\n\n  readonly sequelize: Sequelize;\n\n  abstract readonly Query: typeof AbstractQuery;\n  abstract readonly queryGenerator: AbstractQueryGenerator;\n  abstract readonly queryInterface: AbstractQueryInterface;\n  abstract readonly connectionManager: AbstractConnectionManager<any, any>;\n\n  /**\n   * @deprecated use {@link minimumDatabaseVersion}\n   */\n  get defaultVersion(): string {\n    return this.minimumDatabaseVersion;\n  }\n\n  /**\n   * @deprecated use {@link identifierDelimiter}.start\n   */\n  get TICK_CHAR_LEFT(): string {\n    return this.identifierDelimiter.start;\n  }\n\n  /**\n   * @deprecated use {@link identifierDelimiter}.end\n   */\n  get TICK_CHAR_RIGHT(): string {\n    return this.identifierDelimiter.end;\n  }\n\n  readonly identifierDelimiter: { readonly start: string; readonly end: string };\n  readonly minimumDatabaseVersion: string;\n  readonly dataTypesDocumentationUrl: string;\n  readonly options: Options;\n  readonly name: DialectName;\n\n  /** dialect-specific implementation of shared data types */\n  readonly #dataTypeOverrides: Map<string, Class<AbstractDataType<any>>>;\n  /** base implementations of shared data types */\n  readonly #baseDataTypes: Map<string, Class<AbstractDataType<any>>>;\n  readonly #dataTypeParsers = new Map<unknown, TypeParser>();\n\n  get supports(): DialectSupports {\n    const Dialect = this.constructor as typeof AbstractDialect;\n\n    return Dialect.supports;\n  }\n\n  constructor(params: AbstractDialectParams<Options>) {\n    this.sequelize = params.sequelize;\n    this.name = params.name;\n    this.dataTypesDocumentationUrl = params.dataTypesDocumentationUrl;\n    this.options = params.options ? getImmutablePojo(params.options) : EMPTY_OBJECT;\n\n    this.identifierDelimiter = isString(params.identifierDelimiter)\n      ? Object.freeze({\n          start: params.identifierDelimiter,\n          end: params.identifierDelimiter,\n        })\n      : getImmutablePojo(params.identifierDelimiter);\n\n    this.minimumDatabaseVersion = params.minimumDatabaseVersion;\n\n    const baseDataTypes = new Map<string, Class<AbstractDataType<any>>>();\n    for (const dataType of Object.values(BaseDataTypes) as Array<Class<AbstractDataType<any>>>) {\n      // Some exports are not Data Types\n      if (!isFunction(dataType)) {\n        continue;\n      }\n\n      const dataTypeId: string = (dataType as unknown as typeof AbstractDataType).getDataTypeId();\n\n      // intermediary data type\n      if (!dataTypeId) {\n        continue;\n      }\n\n      if (baseDataTypes.has(dataTypeId)) {\n        throw new Error(\n          `Internal Error: Sequelize declares more than one base implementation for DataType ID ${dataTypeId}.`,\n        );\n      }\n\n      baseDataTypes.set(dataTypeId, dataType);\n    }\n\n    const dataTypeOverrides = new Map<string, Class<AbstractDataType<any>>>();\n    for (const dataType of Object.values(params.dataTypeOverrides)) {\n      const replacedDataTypeId: string = (\n        dataType as unknown as typeof AbstractDataType\n      ).getDataTypeId();\n\n      if (dataTypeOverrides.has(replacedDataTypeId)) {\n        throw new Error(\n          `Dialect ${this.name} declares more than one implementation for DataType ID ${replacedDataTypeId}.`,\n        );\n      }\n\n      dataTypeOverrides.set(replacedDataTypeId, dataType);\n    }\n\n    this.#dataTypeOverrides = dataTypeOverrides;\n    this.#baseDataTypes = baseDataTypes;\n  }\n\n  /**\n   * Returns the dialect-specific implementation of a shared data type, or null if no such implementation exists\n   * (in which case you need to use the base implementation).\n   *\n   * @param dataType The shared data type.\n   */\n  getDataTypeForDialect(\n    dataType: Class<AbstractDataType<any>>,\n  ): Class<AbstractDataType<any>> | null {\n    const typeId = (dataType as unknown as typeof AbstractDataType).getDataTypeId();\n    const baseType = this.#baseDataTypes.get(typeId);\n\n    // this is not one of our types. May be a custom type by a user. We don't replace it.\n    if (baseType != null && baseType !== dataType) {\n      return null;\n    }\n\n    return this.#dataTypeOverrides.get(typeId) ?? null;\n  }\n\n  readonly #printedWarnings = new Set<string>();\n  warnDataTypeIssue(text: string): void {\n    // TODO: log this to sequelize's log option instead (requires a logger with multiple log levels first)\n    if (this.#printedWarnings.has(text)) {\n      return;\n    }\n\n    this.#printedWarnings.add(text);\n    logger.warn(`${text} \\n>> Check: ${this.dataTypesDocumentationUrl}`);\n  }\n\n  abstract createBindCollector(): BindCollector;\n\n  /**\n   * Produces a safe representation of a Buffer for this dialect, that can be inlined in a SQL string.\n   * Used mainly by DataTypes.\n   *\n   * @param buffer The buffer to escape\n   * @returns The string, escaped for SQL.\n   */\n  escapeBuffer(buffer: Buffer): string {\n    const hex = buffer.toString('hex');\n\n    return `X'${hex}'`;\n  }\n\n  /**\n   * Produces a safe representation of a string for this dialect, that can be inlined in a SQL string.\n   * Used mainly by DataTypes.\n   *\n   * @param value The string to escape\n   * @returns The string, escaped for SQL.\n   */\n  escapeString(value: string): string {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    value = value.replaceAll(\"'\", \"''\");\n\n    return `'${value}'`;\n  }\n\n  // Keep the logic of this class synchronized with the logic in the JSON DataType.\n  escapeJson(value: unknown): string {\n    return this.escapeString(JSON.stringify(value));\n  }\n\n  /**\n   * Whether this dialect can use \\ in strings to escape string delimiters.\n   *\n   * @returns\n   */\n  canBackslashEscape(): boolean {\n    return false;\n  }\n\n  /**\n   * Used to register a base parser for a Database type.\n   * Parsers are based on the Database Type, not the JS type.\n   * Only one parser can be assigned as the parser for a Database Type.\n   * For this reason, prefer neutral implementations.\n   *\n   * For instance, when implementing \"parse\" for a Date type,\n   * prefer returning a String rather than a Date object.\n   *\n   * The {@link DataTypes.ABSTRACT#parseDatabaseValue} method will then be called on the DataType instance defined by the user,\n   * which can decide on a more specific JS type (e.g. parse the date string & return a Date instance or a Temporal instance).\n   *\n   * You typically do not need to implement this method. This is used to provide default parsers when no DataType\n   * is provided (e.g. raw queries that don't specify a model). Sequelize already provides a default parser for most types.\n   * For a custom Data Type, implementing {@link DataTypes.ABSTRACT#parseDatabaseValue} is typically what you want.\n   *\n   * @param databaseDataTypes Dialect-specific DB data type identifiers that will use this parser.\n   * @param parser The parser function to call when parsing the data type. Parameters are dialect-specific.\n   */\n  registerDataTypeParser(databaseDataTypes: unknown[], parser: TypeParser) {\n    for (const databaseDataType of databaseDataTypes) {\n      if (this.#dataTypeParsers.has(databaseDataType)) {\n        throw new Error(\n          `Sequelize DataType for DB DataType ${databaseDataType} already registered for dialect ${this.name}`,\n        );\n      }\n\n      this.#dataTypeParsers.set(databaseDataType, parser);\n    }\n  }\n\n  getParserForDatabaseDataType(databaseDataType: unknown): TypeParser | undefined {\n    return this.#dataTypeParsers.get(databaseDataType);\n  }\n\n  abstract getDefaultSchema(): string;\n\n  abstract parseConnectionUrl(url: string): TConnectionOptions;\n\n  static getSupportedOptions(): readonly string[] {\n    throw new Error(\n      `Dialect ${this.name} does not implement the static method getSupportedOptions.\nIt must return the list of option names that can be passed to the dialect constructor.`,\n    );\n  }\n\n  static getSupportedConnectionOptions(): readonly string[] {\n    throw new Error(\n      `Dialect ${this.name} does not implement the static method getSupportedConnectionOptions.\nIt must return the list of connection option names that will be passed to its ConnectionManager's getConnection.`,\n    );\n  }\n\n  getSupportedOptions(): readonly string[] {\n    return (this.constructor as typeof AbstractDialect).getSupportedOptions();\n  }\n\n  getSupportedConnectionOptions(): readonly string[] {\n    return (this.constructor as typeof AbstractDialect).getSupportedConnectionOptions();\n  }\n}\n\nexport type BindCollector = {\n  /**\n   *\n   *\n   * @param {string} bindParameterName The name of the bind parameter\n   * @returns {string}\n   */\n  collect(bindParameterName: string): string;\n\n  /**\n   * Returns either an array of orders if the bind parameters are mapped to numeric parameters (e.g. '?', $1, @1),\n   * or null if no mapping was necessary because the dialect supports named parameters.\n   */\n  getBindParameterOrder(): string[] | null;\n};\n"],
  "mappings": "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",
  "names": ["merge", "cloneDeep"]
}
