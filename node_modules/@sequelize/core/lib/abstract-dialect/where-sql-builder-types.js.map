{
  "version": 3,
  "sources": ["../../src/abstract-dialect/where-sql-builder-types.ts"],
  "sourcesContent": ["import type { AllowArray } from '@sequelize/utils';\nimport type { DynamicSqlExpression } from '../expression-builders/base-sql-expression.js';\nimport type { WhereOperators } from '../model.js';\nimport type { Op } from '../operators.js';\n\n/**\n * This type allows using `Op.or`, `Op.and`, and `Op.not` recursively around another type.\n * It also supports using a plain Array as an alias for `Op.and`. (unlike {@link AllowNotOrAndRecursive}).\n *\n * Example of plain-array treated as `Op.and`:\n * ```ts\n * User.findAll({ where: [{ id: 1 }, { id: 2 }] });\n * ```\n *\n * Meant to be used by {@link WhereOptions}.\n */\nexport type AllowNotOrAndWithImplicitAndArrayRecursive<T> = AllowArray<\n  // this is the equivalent of Op.and\n  | T\n  | { [Op.or]: AllowArray<AllowNotOrAndWithImplicitAndArrayRecursive<T>> }\n  | { [Op.and]: AllowArray<AllowNotOrAndWithImplicitAndArrayRecursive<T>> }\n  | { [Op.not]: AllowNotOrAndWithImplicitAndArrayRecursive<T> }\n>;\n\n/**\n * The type accepted by every `where` option\n */\nexport type WhereOptions<TAttributes = any> =\n  // \"where\" is typically optional. If the user sets it to undefined, we treat is as if the option was not set.\n  | undefined\n  | AllowNotOrAndWithImplicitAndArrayRecursive<\n      WhereAttributeHash<TAttributes> | DynamicSqlExpression\n    >;\n\n/**\n * This type allows using `Op.or`, `Op.and`, and `Op.not` recursively around another type.\n * Unlike {@link AllowNotOrAndWithImplicitAndArrayRecursive}, it does not allow the 'implicit AND Array'.\n *\n * Example of plain-array NOT treated as Op.and:\n * ```ts\n * User.findAll({ where: { id: [1, 2] } });\n * ```\n *\n * Meant to be used by {@link WhereAttributeHashValue}.\n */\ntype AllowNotOrAndRecursive<T> =\n  | T\n  | { [Op.or]: AllowArray<AllowNotOrAndRecursive<T>> }\n  | { [Op.and]: AllowArray<AllowNotOrAndRecursive<T>> }\n  | { [Op.not]: AllowNotOrAndRecursive<T> };\n\n/**\n * Types that can be compared to an attribute in a WHERE context.\n */\nexport type WhereAttributeHashValue<AttributeType> =\n  | AllowNotOrAndRecursive<\n      // if the right-hand side is an array, it will be equal to Op.in\n      // otherwise it will be equal to Op.eq\n      // Exception: array attribtues always use Op.eq, never Op.in.\n      AttributeType extends any[]\n        ? WhereOperators<AttributeType>[typeof Op.eq] | WhereOperators<AttributeType>\n        :\n            | WhereOperators<AttributeType>[typeof Op.in]\n            | WhereOperators<AttributeType>[typeof Op.eq]\n            | WhereOperators<AttributeType>\n    >\n  // TODO: this needs a simplified version just for JSON columns\n  | WhereAttributeHash<any>; // for JSON columns\n\n/**\n * A hash of attributes to describe your search.\n *\n * Possible key values:\n *\n * - An attribute name: `{ id: 1 }`\n * - A nested attribute: `{ '$projects.id$': 1 }`\n * - A JSON key: `{ 'object.key': 1 }`\n * - A cast: `{ 'id::integer': 1 }`\n *\n * - A combination of the above: `{ '$join.attribute$.json.path::integer': 1 }`\n */\nexport type WhereAttributeHash<TAttributes = any> = {\n  // support 'attribute' & '$attribute$'\n  [AttributeName in keyof TAttributes as AttributeName extends string\n    ? AttributeName | `$${AttributeName}$`\n    : never]?: WhereAttributeHashValue<TAttributes[AttributeName]>;\n} & {\n  [AttributeName in keyof TAttributes as AttributeName extends string\n    ? // support 'json.path', '$json$.path', json[index]', '$json$[index]'\n      | `${AttributeName}.${string}`\n        | `$${AttributeName}$.${string}`\n        | `${AttributeName}[${string}`\n        | `$${AttributeName}$[${string}`\n        // support 'attribute::cast', '$attribute$::cast', 'json.path::cast' & '$json$.path::cast'\n        | `${AttributeName | `$${AttributeName}$` | `${AttributeName}.${string}` | `$${AttributeName}$.${string}`}:${string}`\n    : never]?: WhereAttributeHashValue<any>;\n} & {\n  // support '$nested.attribute$', '$nested.attribute$::cast', '$nested.attribute$.json.path', & '$nested.attribute$.json.path::cast', '$nested.attribute$[index]', & '$nested.attribute$[index]::cast'\n  [\n    attribute:\n      | `$${string}.${string}$`\n      | `$${string}.${string}$::${string}`\n      | `$${string}.${string}$.${string}`\n      | `$${string}.${string}$.${string}:${string}`\n      | `$${string}.${string}$[${string}`\n      | `$${string}.${string}$[${string}:${string}`\n  ]: WhereAttributeHashValue<any>;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
