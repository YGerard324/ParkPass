{
  "version": 3,
  "sources": ["../../src/abstract-dialect/data-types-utils.ts"],
  "sourcesContent": ["import NodeUtils from 'node:util';\nimport { BaseError, ValidationErrorItem } from '../errors/index.js';\nimport type { Model } from '../model.js';\nimport type {\n  DataType,\n  DataTypeClass,\n  DataTypeClassOrInstance,\n  DataTypeInstance,\n} from './data-types.js';\nimport { AbstractDataType } from './data-types.js';\nimport type { AbstractDialect } from './dialect.js';\n\nexport function isDataType(value: any): value is DataType {\n  return isDataTypeClass(value) || value instanceof AbstractDataType;\n}\n\nexport function isDataTypeClass(value: any): value is DataTypeClass {\n  return typeof value === 'function' && value.prototype instanceof AbstractDataType;\n}\n\nexport function cloneDataType(value: DataTypeInstance | string): DataTypeInstance | string {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  return value.clone();\n}\n\nexport function normalizeDataType(\n  Type: DataTypeClassOrInstance,\n  dialect: AbstractDialect,\n): AbstractDataType<unknown>;\nexport function normalizeDataType(Type: string, dialect: AbstractDialect): string;\nexport function normalizeDataType(\n  Type: DataTypeClassOrInstance | string,\n  dialect: AbstractDialect,\n): AbstractDataType<unknown> | string;\nexport function normalizeDataType(\n  Type: DataTypeClassOrInstance | string,\n  dialect: AbstractDialect,\n): AbstractDataType<unknown> | string {\n  if (typeof Type === 'string') {\n    return Type;\n  }\n\n  if (typeof Type !== 'function' && !(Type instanceof AbstractDataType)) {\n    throw new TypeError(\n      `Expected type to be a string, a DataType class, or a DataType instance, but got ${NodeUtils.inspect(Type)}.`,\n    );\n  }\n\n  const type = dataTypeClassOrInstanceToInstance(Type);\n\n  if (!type.belongsToDialect(dialect)) {\n    return type.toDialectDataType(dialect);\n  }\n\n  return type;\n}\n\nexport function dataTypeClassOrInstanceToInstance(Type: DataTypeClassOrInstance): DataTypeInstance {\n  return typeof Type === 'function' ? new Type() : Type;\n}\n\nexport function validateDataType(\n  value: unknown,\n  type: AbstractDataType<any>,\n  attributeName: string = '[unnamed]',\n  modelInstance: Model<any> | null = null,\n): ValidationErrorItem | null {\n  try {\n    type.validate(value);\n\n    return null;\n  } catch (error) {\n    if (!(error instanceof ValidationErrorItem)) {\n      throw new BaseError(\n        `Validation encountered an unexpected error while validating attribute ${attributeName}. (Note: If this error is intended, ${type.constructor.name}#validate must throw an instance of ValidationErrorItem instead)`,\n        {\n          cause: error,\n        },\n      );\n    }\n\n    error.path = attributeName;\n    error.value = value;\n    error.instance = modelInstance;\n    // @ts-expect-error -- untyped constructor\n    error.validatorKey = `${type.constructor.getDataTypeId()} validator`;\n\n    return error;\n  }\n}\n\nexport function attributeTypeToSql(type: AbstractDataType<any> | string): string {\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  if (type instanceof AbstractDataType) {\n    return type.toSql();\n  }\n\n  throw new Error(\n    'attributeTypeToSql received a type that is neither a string or an instance of AbstractDataType',\n  );\n}\n\nexport function getDataTypeParser(\n  dialect: AbstractDialect,\n  dataType: DataTypeClassOrInstance,\n): (value: unknown) => unknown {\n  const type = normalizeDataType(dataType, dialect);\n\n  return (value: unknown) => {\n    return type.parseDatabaseValue(value);\n  };\n}\n\nexport function throwUnsupportedDataType(dialect: AbstractDialect, typeName: string): never {\n  throw new Error(`${dialect.name} does not support the ${typeName} data type.\nSee https://sequelize.org/docs/v7/models/data-types/ for a list of supported data types.`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAsB;AACtB,oBAA+C;AAQ/C,wBAAiC;AAG1B,SAAS,WAAW,OAA+B;AACxD,SAAO,gBAAgB,KAAK,KAAK,iBAAiB;AACpD;AAEO,SAAS,gBAAgB,OAAoC;AAClE,SAAO,OAAO,UAAU,cAAc,MAAM,qBAAqB;AACnE;AAEO,SAAS,cAAc,OAA6D;AACzF,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO,MAAM,MAAM;AACrB;AAWO,SAAS,kBACd,MACA,SACoC;AACpC,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,SAAS,cAAc,EAAE,gBAAgB,qCAAmB;AACrE,UAAM,IAAI;AAAA,MACR,mFAAmF,iBAAAA,QAAU,QAAQ,IAAI;AAAA,IAC3G;AAAA,EACF;AAEA,QAAM,OAAO,kCAAkC,IAAI;AAEnD,MAAI,CAAC,KAAK,iBAAiB,OAAO,GAAG;AACnC,WAAO,KAAK,kBAAkB,OAAO;AAAA,EACvC;AAEA,SAAO;AACT;AAEO,SAAS,kCAAkC,MAAiD;AACjG,SAAO,OAAO,SAAS,aAAa,IAAI,KAAK,IAAI;AACnD;AAEO,SAAS,iBACd,OACA,MACA,gBAAwB,aACxB,gBAAmC,MACP;AAC5B,MAAI;AACF,SAAK,SAAS,KAAK;AAEnB,WAAO;AAAA,EACT,SAAS,OAAP;AACA,QAAI,EAAE,iBAAiB,oCAAsB;AAC3C,YAAM,IAAI;AAAA,QACR,yEAAyE,oDAAoD,KAAK,YAAY;AAAA,QAC9I;AAAA,UACE,OAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,WAAW;AAEjB,UAAM,eAAe,GAAG,KAAK,YAAY,cAAc;AAEvD,WAAO;AAAA,EACT;AACF;AAEO,SAAS,mBAAmB,MAA8C;AAC/E,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,gBAAgB,oCAAkB;AACpC,WAAO,KAAK,MAAM;AAAA,EACpB;AAEA,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAEO,SAAS,kBACd,SACA,UAC6B;AAC7B,QAAM,OAAO,kBAAkB,UAAU,OAAO;AAEhD,SAAO,CAAC,UAAmB;AACzB,WAAO,KAAK,mBAAmB,KAAK;AAAA,EACtC;AACF;AAEO,SAAS,yBAAyB,SAA0B,UAAyB;AAC1F,QAAM,IAAI,MAAM,GAAG,QAAQ,6BAA6B;AAAA,yFAC+B;AACzF;",
  "names": ["NodeUtils"]
}
