{
  "version": 3,
  "sources": ["../../src/abstract-dialect/replication-pool.ts"],
  "sourcesContent": ["import { pojo, shallowClonePojo } from '@sequelize/utils';\nimport { Pool, TimeoutError } from 'sequelize-pool';\nimport type { Class } from 'type-fest';\nimport { logger } from '../utils/logger.js';\n\nconst debug = logger.debugContext('pool');\n\nexport type ConnectionType = 'read' | 'write';\n\nexport interface ReplicationPoolOptions {\n  /**\n   * Maximum number of connections in pool. Default is 5\n   */\n  max: number;\n\n  /**\n   * Minimum number of connections in pool. Default is 0\n   */\n  min: number;\n\n  /**\n   * The maximum time, in milliseconds, that a connection can be idle before being released\n   */\n  idle: number;\n\n  /**\n   * The maximum time, in milliseconds, that pool will try to get connection before throwing error\n   */\n  acquire: number;\n\n  /**\n   * The time interval, in milliseconds, after which sequelize-pool will remove idle connections.\n   */\n  evict: number;\n\n  /**\n   * The number of times to use a connection before closing and replacing it.  Default is Infinity\n   */\n  maxUses: number;\n}\n\nexport interface AcquireConnectionOptions {\n  /**\n   * Set which replica to use. Available options are `read` and `write`\n   */\n  type?: 'read' | 'write';\n\n  /**\n   * Force master or write replica to get connection from\n   */\n  useMaster?: boolean;\n}\n\ninterface ReplicationPoolConfig<Connection extends object, ConnectionOptions extends object> {\n  readConfig: readonly ConnectionOptions[] | null;\n  writeConfig: ConnectionOptions;\n  pool: ReplicationPoolOptions;\n\n  // TODO: move this option to sequelize-pool so it applies to sub-pools as well\n  timeoutErrorClass?: Class<Error>;\n\n  connect(options: ConnectionOptions): Promise<Connection>;\n\n  disconnect(connection: Connection): Promise<void>;\n\n  validate(connection: Connection): boolean;\n\n  beforeAcquire?(options: AcquireConnectionOptions): Promise<void>;\n  afterAcquire?(connection: Connection, options: AcquireConnectionOptions): Promise<void>;\n}\n\nconst owningPools = new WeakMap<object, 'read' | 'write'>();\n\nexport class ReplicationPool<Connection extends object, ConnectionOptions extends object> {\n  /**\n   * Replication read pool. Will only be used if the 'read' replication option has been provided,\n   * otherwise the {@link write} will be used instead.\n   */\n  readonly read: Pool<Connection> | null;\n  readonly write: Pool<Connection>;\n\n  readonly #timeoutErrorClass: Class<TimeoutError> | undefined;\n  readonly #beforeAcquire: ((options: AcquireConnectionOptions) => Promise<void>) | undefined;\n  readonly #afterAcquire:\n    | ((connection: Connection, options: AcquireConnectionOptions) => Promise<void>)\n    | undefined;\n\n  constructor(config: ReplicationPoolConfig<Connection, ConnectionOptions>) {\n    const {\n      connect,\n      disconnect,\n      validate,\n      beforeAcquire,\n      afterAcquire,\n      timeoutErrorClass,\n      readConfig,\n      writeConfig,\n    } = config;\n\n    this.#beforeAcquire = beforeAcquire;\n    this.#afterAcquire = afterAcquire;\n    this.#timeoutErrorClass = timeoutErrorClass;\n\n    if (!readConfig || readConfig.length === 0) {\n      // no replication, the write pool will always be used instead\n      this.read = null;\n    } else {\n      let reads = 0;\n\n      this.read = new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % readConfig.length;\n          const connection = await connect(readConfig[nextRead]);\n\n          owningPools.set(connection, 'read');\n\n          return connection;\n        },\n        destroy: disconnect,\n        validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses,\n      });\n    }\n\n    this.write = new Pool({\n      name: 'sequelize:write',\n      create: async () => {\n        const connection = await connect(writeConfig);\n\n        owningPools.set(connection, 'write');\n\n        return connection;\n      },\n      destroy: disconnect,\n      validate,\n      max: config.pool.max,\n      min: config.pool.min,\n      acquireTimeoutMillis: config.pool.acquire,\n      idleTimeoutMillis: config.pool.idle,\n      reapIntervalMillis: config.pool.evict,\n      maxUses: config.pool.maxUses,\n    });\n\n    if (!this.read) {\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n    } else {\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n    }\n  }\n\n  async acquire(options?: AcquireConnectionOptions | undefined) {\n    options = options ? shallowClonePojo(options) : pojo();\n    await this.#beforeAcquire?.(options);\n    Object.freeze(options);\n\n    const { useMaster = false, type = 'write' } = options;\n\n    if (type !== 'read' && type !== 'write') {\n      throw new Error(`Expected queryType to be either read or write. Received ${type}`);\n    }\n\n    const pool = this.read != null && type === 'read' && !useMaster ? this.read : this.write;\n\n    let connection;\n    try {\n      connection = await pool.acquire();\n    } catch (error) {\n      if (this.#timeoutErrorClass && error instanceof TimeoutError) {\n        throw new this.#timeoutErrorClass(error.message, { cause: error });\n      }\n\n      throw error;\n    }\n\n    await this.#afterAcquire?.(connection, options);\n\n    return connection;\n  }\n\n  release(client: Connection): void {\n    const connectionType = owningPools.get(client);\n    if (!connectionType) {\n      throw new Error('Unable to determine to which pool the connection belongs');\n    }\n\n    this.getPool(connectionType).release(client);\n  }\n\n  async destroy(client: Connection): Promise<void> {\n    const connectionType = owningPools.get(client);\n    if (!connectionType) {\n      throw new Error('Unable to determine to which pool the connection belongs');\n    }\n\n    await this.getPool(connectionType).destroy(client);\n    debug('connection destroy');\n  }\n\n  async destroyAllNow() {\n    await Promise.all([this.read?.destroyAllNow(), this.write.destroyAllNow()]);\n\n    debug('all connections destroyed');\n  }\n\n  async drain() {\n    await Promise.all([this.write.drain(), this.read?.drain()]);\n  }\n\n  getPool(poolType: ConnectionType): Pool<Connection> {\n    if (poolType === 'read' && this.read != null) {\n      return this.read;\n    }\n\n    return this.write;\n  }\n\n  get size(): number {\n    return (this.read?.size ?? 0) + this.write.size;\n  }\n\n  get available(): number {\n    return (this.read?.available ?? 0) + this.write.available;\n  }\n\n  get using(): number {\n    return (this.read?.using ?? 0) + this.write.using;\n  }\n\n  get waiting(): number {\n    return (this.read?.waiting ?? 0) + this.write.waiting;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
