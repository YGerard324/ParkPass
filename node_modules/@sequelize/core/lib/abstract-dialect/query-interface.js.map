{
  "version": 3,
  "sources": ["../../src/abstract-dialect/query-interface.js"],
  "sourcesContent": ["'use strict';\n\nimport { map } from '@sequelize/utils';\nimport defaults from 'lodash/defaults';\nimport find from 'lodash/find';\nimport intersection from 'lodash/intersection';\nimport isObject from 'lodash/isObject';\nimport mapValues from 'lodash/mapValues';\nimport uniq from 'lodash/uniq';\nimport * as DataTypes from '../data-types';\nimport { QueryTypes } from '../query-types';\nimport { cloneDeep, getObjectFromMap } from '../utils/object';\nimport { assertNoReservedBind, combineBinds } from '../utils/sql';\nimport { AbstractDataType } from './data-types';\nimport { AbstractQueryInterfaceTypeScript } from './query-interface-typescript';\n\n/**\n * The interface that Sequelize uses to talk to all databases\n */\nexport class AbstractQueryInterface extends AbstractQueryInterfaceTypeScript {\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: DataTypes.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: DataTypes.DATE\n   *     },\n   *     updatedAt: {\n   *       type: DataTypes.DATE\n   *     },\n   *     attr1: DataTypes.STRING,\n   *     attr2: DataTypes.INTEGER,\n   *     attr3: {\n   *       type: DataTypes.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: DataTypes.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of table attributes to create\n   * @param {object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  // TODO: remove \"schema\" option from the option bag, it must be passed as part of \"tableName\" instead\n  async createTable(tableName, attributes, options, model) {\n    options = { ...options };\n\n    // TODO: the sqlite implementation of createTableQuery should be improved so it also generates a CREATE UNIQUE INDEX query\n    if (model && this.sequelize.dialect.name !== 'sqlite3') {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    const modelTable = model?.table;\n\n    if (!tableName.schema && (options.schema || modelTable?.schema)) {\n      tableName = this.queryGenerator.extractTableDetails(tableName);\n      tableName.schema = modelTable?.schema || options.schema;\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: 'createTable',\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints,\n      // schema override for multi-tenancy\n      schema: options.schema,\n    });\n\n    const sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', DataTypes.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {object} attribute Attribute definition\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async addColumn(table, key, attribute, options = {}) {\n    if (!table || !key || !attribute) {\n      throw new Error(\n        'addColumn takes at least 3 arguments (table, attribute name, attribute definition)',\n      );\n    }\n\n    attribute = this.sequelize.normalizeAttribute(attribute);\n\n    if (\n      attribute.type instanceof AbstractDataType &&\n      // we don't give a context if it already has one, because it could come from a Model.\n      !attribute.type.usageContext\n    ) {\n      attribute.type.attachUsageContext({\n        tableName: table,\n        columnName: key,\n        sequelize: this.sequelize,\n      });\n    }\n\n    const { ifNotExists, ...rawQueryOptions } = options;\n    const addColumnQueryOptions = ifNotExists ? { ifNotExists } : undefined;\n\n    return await this.sequelize.queryRaw(\n      this.queryGenerator.addColumnQuery(table, key, attribute, addColumnQueryOptions),\n      rawQueryOptions,\n    );\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {object} [options]      Query options\n   */\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return this.queryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * @param {string} identifiers\n   *\n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {object} dataTypeOrOptions  Attribute definition for new column\n   * @param {object} [options]          Query options\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options ||= {};\n\n    const query = this.queryGenerator.attributesToSQL(\n      {\n        [attributeName]: this.normalizeAttribute(dataTypeOrOptions),\n      },\n      {\n        context: 'changeColumn',\n        table: tableName,\n      },\n    );\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.queryRaw(sql, options);\n  }\n\n  /**\n   * Rejects if the table doesn't have the specified column, otherwise returns the column description.\n   *\n   * @param {string} tableName\n   * @param {string} columnName\n   * @param {object} options\n   * @private\n   */\n  // TODO: rename to \"describeColumn\"\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options ||= {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[\n      attrNameBefore\n    ];\n\n    const _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue,\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(\n      tableName,\n      attrNameBefore,\n      this.queryGenerator.attributesToSQL(_options),\n    );\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  async addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = cloneDeep(options) ?? {};\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n\n    return await this.sequelize.queryRaw(sql, { ...options, supportsSearchPath: false });\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {TableOrModel} tableName\n   * @param {object}    [options] Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n\n    return await this.sequelize.queryRaw(sql, { ...options, type: QueryTypes.SHOWINDEXES });\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName                    Table name to drop index from\n   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index\n   * @param {object} [options]                    Query options\n   * @param {boolean} [options.concurrently]      Pass CONCURRENTLY so other operations run while the index is created\n   *\n   * @returns {Promise}\n   */\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options ||= {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    if (options?.bind) {\n      assertNoReservedBind(options.bind);\n    }\n\n    options = cloneDeep(options) ?? {};\n    const modelDefinition = instance?.modelDefinition;\n\n    options.hasTrigger = modelDefinition?.options.hasTrigger;\n    const { bind, query } = this.queryGenerator.insertQuery(\n      tableName,\n      values,\n      modelDefinition && getObjectFromMap(modelDefinition.attributes),\n      options,\n    );\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacements;\n    options.bind = combineBinds(options.bind, bind);\n\n    const results = await this.sequelize.queryRaw(query, options);\n    if (instance) {\n      results[0].isNewRecord = false;\n    }\n\n    return results;\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  // Note: \"where\" is only used by DB2 and MSSQL. This is because these dialects do not propose any \"ON CONFLICT UPDATE\" mechanisms\n  // The UPSERT pattern in SQL server requires providing a WHERE clause\n  // TODO: the user should be able to configure the WHERE clause for upsert instead of the current default which\n  //  is using the primary keys.\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    if (!this.dialect.name) {\n      throw new Error(`Upserts are not supported by the ${this.dialect.name} dialect.`);\n    }\n\n    if (options?.bind) {\n      assertNoReservedBind(options.bind);\n    }\n\n    options = { ...options };\n\n    const model = options.model;\n    const modelDefinition = model.modelDefinition;\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Array.from(\n        map(\n          modelDefinition.primaryKeysAttributeNames,\n          pkAttrName => modelDefinition.attributes.get(pkAttrName).columnName,\n        ),\n      );\n\n      const uniqueColumnNames = Object.values(model.getIndexes())\n        .filter(c => c.unique && c.fields.length > 0)\n        .map(c => c.fields);\n      // For fields in updateValues, try to find a constraint or unique index\n      // that includes given field. Only first matching upsert key is used.\n      for (const field of options.updateOnDuplicate) {\n        const indexKey = uniqueColumnNames.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n\n      // Always use PK, if no constraint available OR update data contains PK\n      if (\n        options.upsertKeys.length === 0 ||\n        intersection(options.updateOnDuplicate, primaryKeys).length > 0\n      ) {\n        options.upsertKeys = primaryKeys;\n      }\n\n      options.upsertKeys = uniq(options.upsertKeys);\n    }\n\n    const { bind, query } = this.queryGenerator.insertQuery(\n      tableName,\n      insertValues,\n      getObjectFromMap(modelDefinition.attributes),\n      options,\n    );\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacement;\n    options.bind = combineBinds(options.bind, bind);\n\n    return await this.sequelize.queryRaw(query, options);\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {object} options     Various options, please see Model.bulkCreate options\n   * @param {object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  async bulkInsert(tableName, records, options, attributes) {\n    options = { ...options, type: QueryTypes.INSERT };\n\n    const sql = this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes);\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacements;\n\n    const results = await this.sequelize.queryRaw(sql, options);\n\n    return results[0];\n  }\n\n  async update(instance, tableName, values, where, options) {\n    if (options?.bind) {\n      assertNoReservedBind(options.bind);\n    }\n\n    const modelDefinition = instance?.modelDefinition;\n\n    options = { ...options, model: instance?.constructor };\n    options.hasTrigger = modelDefinition?.options.hasTrigger;\n\n    const { bind, query } = this.queryGenerator.updateQuery(\n      tableName,\n      values,\n      where,\n      options,\n      modelDefinition && getObjectFromMap(modelDefinition.attributes),\n    );\n\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n\n    delete options.replacements;\n\n    options.bind = combineBinds(options.bind, bind);\n\n    return await this.sequelize.queryRaw(query, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {object} values        Values to be inserted, mapped to field name\n   * @param {object} where    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {object} [options]     Various options, please see Model.bulkCreate options\n   * @param {object} [columnDefinitions]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  async bulkUpdate(tableName, values, where, options, columnDefinitions) {\n    if (options?.bind) {\n      assertNoReservedBind(options.bind);\n    }\n\n    options = cloneDeep(options) ?? {};\n    if (typeof where === 'object') {\n      where = cloneDeep(where) ?? {};\n    }\n\n    const { bind, query } = this.queryGenerator.updateQuery(\n      tableName,\n      values,\n      where,\n      options,\n      columnDefinitions,\n    );\n    const table = isObject(tableName) ? tableName : { tableName };\n    const model = options.model\n      ? options.model\n      : find(this.sequelize.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    options.bind = combineBinds(options.bind, bind);\n\n    return await this.sequelize.queryRaw(query, options);\n  }\n\n  async select(model, tableName, optionsArg) {\n    const minifyAliases = optionsArg.minifyAliases ?? this.sequelize.options.minifyAliases;\n    const options = { ...optionsArg, type: QueryTypes.SELECT, model, minifyAliases };\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, model);\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacements;\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  async increment(\n    model,\n    tableName,\n    where,\n    incrementAmountsByField,\n    extraAttributesToBeUpdated,\n    options,\n  ) {\n    return this.#arithmeticQuery(\n      '+',\n      model,\n      tableName,\n      where,\n      incrementAmountsByField,\n      extraAttributesToBeUpdated,\n      options,\n    );\n  }\n\n  async decrement(\n    model,\n    tableName,\n    where,\n    incrementAmountsByField,\n    extraAttributesToBeUpdated,\n    options,\n  ) {\n    return this.#arithmeticQuery(\n      '-',\n      model,\n      tableName,\n      where,\n      incrementAmountsByField,\n      extraAttributesToBeUpdated,\n      options,\n    );\n  }\n\n  async #arithmeticQuery(\n    operator,\n    model,\n    tableName,\n    where,\n    incrementAmountsByAttribute,\n    extraAttributesToBeUpdated,\n    options,\n  ) {\n    options = cloneDeep(options) ?? {};\n    options.model = model;\n\n    const sql = this.queryGenerator.arithmeticQuery(\n      operator,\n      tableName,\n      where,\n      incrementAmountsByAttribute,\n      extraAttributesToBeUpdated,\n      options,\n    );\n\n    options.type = QueryTypes.UPDATE;\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacements;\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = cloneDeep(options) ?? {};\n    options = defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT,\n    });\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    // unlike bind, replacements are handled by QueryGenerator, not QueryRaw\n    delete options.replacements;\n\n    const data = await this.sequelize.queryRaw(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    // TODO: DECIMAL is not safely representable as a float!\n    //  Use the DataType's parse method instead.\n    if (\n      (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) &&\n      result !== null\n    ) {\n      return Number.parseFloat(result);\n    }\n\n    // TODO: BIGINT is not safely representable as an int!\n    //  Use the DataType's parse method instead.\n    if (\n      (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) &&\n      result !== null\n    ) {\n      return Number.parseInt(result, 10);\n    }\n\n    if (dataType instanceof DataTypes.DATE && result !== null && !(result instanceof Date)) {\n      return new Date(result);\n    }\n\n    return result;\n  }\n\n  async createTrigger(\n    tableName,\n    triggerName,\n    timingType,\n    fireOnArray,\n    functionName,\n    functionParams,\n    optionsArray,\n    options,\n  ) {\n    const sql = this.queryGenerator.createTrigger(\n      tableName,\n      triggerName,\n      timingType,\n      fireOnArray,\n      functionName,\n      functionParams,\n      optionsArray,\n    );\n    options ||= {};\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options ||= {};\n\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options ||= {};\n\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(\n      functionName,\n      params,\n      returnType,\n      language,\n      body,\n      optionsArray,\n      options,\n    );\n    options ||= {};\n\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options ||= {};\n\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options ||= {};\n\n    if (sql) {\n      return await this.sequelize.queryRaw(sql, options);\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * @private\n   */\n  ensureEnums() {\n    // noop by default\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,mBAAoB;AACpB,sBAAqB;AACrB,kBAAiB;AACjB,0BAAyB;AACzB,sBAAqB;AACrB,uBAAsB;AACtB,kBAAiB;AACjB,gBAA2B;AAC3B,yBAA2B;AAC3B,oBAA4C;AAC5C,iBAAmD;AACnD,wBAAiC;AACjC,wCAAiD;AAK1C,MAAM,+BAA+B,mEAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuD3E,MAAM,YAAY,WAAW,YAAY,SAAS,OAAO;AACvD,cAAU,EAAE,GAAG,QAAQ;AAGvB,QAAI,SAAS,KAAK,UAAU,QAAQ,SAAS,WAAW;AACtD,cAAQ,aAAa,QAAQ,cAAc,MAAM;AAAA,IACnD;AAEA,qBAAa,iBAAAA,SAAU,YAAY,eAAa,KAAK,UAAU,mBAAmB,SAAS,CAAC;AAG5F,UAAM,KAAK,YAAY,WAAW,YAAY,SAAS,KAAK;AAE5D,UAAM,aAAa,OAAO;AAE1B,QAAI,CAAC,UAAU,WAAW,QAAQ,UAAU,YAAY,SAAS;AAC/D,kBAAY,KAAK,eAAe,oBAAoB,SAAS;AAC7D,gBAAU,SAAS,YAAY,UAAU,QAAQ;AAAA,IACnD;AAEA,iBAAa,KAAK,eAAe,gBAAgB,YAAY;AAAA,MAC3D,OAAO;AAAA,MACP,SAAS;AAAA,MACT,8BAA8B,QAAQ;AAAA;AAAA,MAEtC,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,UAAM,MAAM,KAAK,eAAe,iBAAiB,WAAW,YAAY,OAAO;AAE/E,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAM,UAAU,OAAO,KAAK,WAAW,UAAU,CAAC,GAAG;AACnD,QAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW;AAChC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,gBAAY,KAAK,UAAU,mBAAmB,SAAS;AAEvD,QACE,UAAU,gBAAgB;AAAA,IAE1B,CAAC,UAAU,KAAK,cAChB;AACA,gBAAU,KAAK,mBAAmB;AAAA,QAChC,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,WAAW,KAAK;AAAA,MAClB,CAAC;AAAA,IACH;AAEA,UAAM,EAAE,aAAa,GAAG,gBAAgB,IAAI;AAC5C,UAAM,wBAAwB,cAAc,EAAE,YAAY,IAAI;AAE9D,WAAO,MAAM,KAAK,UAAU;AAAA,MAC1B,KAAK,eAAe,eAAe,OAAO,KAAK,WAAW,qBAAqB;AAAA,MAC/E;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,mBAAmB,mBAAmB;AACpC,QAAI;AACJ,QAAI,OAAO,OAAO,SAAS,EAAE,SAAS,iBAAiB,GAAG;AACxD,kBAAY,EAAE,MAAM,mBAAmB,WAAW,KAAK;AAAA,IACzD,OAAO;AACL,kBAAY;AAAA,IACd;AAEA,WAAO,KAAK,UAAU,mBAAmB,SAAS;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,YAAY,OAAO;AACjC,WAAO,KAAK,eAAe,gBAAgB,YAAY,KAAK;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,iBAAiB,aAAa;AAC5B,WAAO,KAAK,eAAe,iBAAiB,WAAW;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,aAAa,WAAW,eAAe,mBAAmB,SAAS;AACvE,gBAAY,CAAC;AAEb,UAAM,QAAQ,KAAK,eAAe;AAAA,MAChC;AAAA,QACE,CAAC,aAAa,GAAG,KAAK,mBAAmB,iBAAiB;AAAA,MAC5D;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM,MAAM,KAAK,eAAe,kBAAkB,WAAW,KAAK;AAElE,WAAO,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,qBAAqB,WAAW,YAAY,SAAS;AACzD,UAAM,cAAc,MAAM,KAAK,cAAc,WAAW,OAAO;AAC/D,QAAI,YAAY,UAAU,GAAG;AAC3B,aAAO;AAAA,IACT;AAEA,UAAM,IAAI,MAAM,SAAS,qCAAqC,YAAY;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,aAAa,WAAW,gBAAgB,eAAe,SAAS;AACpE,gBAAY,CAAC;AACb,UAAM,QAAQ,MAAM,KAAK,qBAAqB,WAAW,gBAAgB,OAAO,GAC9E,cACF;AAEA,UAAM,WAAW,CAAC;AAElB,aAAS,aAAa,IAAI;AAAA,MACxB,WAAW;AAAA,MACX,MAAM,KAAK;AAAA,MACX,WAAW,KAAK;AAAA,MAChB,cAAc,KAAK;AAAA,IACrB;AAGA,QAAI,KAAK,iBAAiB,QAAQ,CAAC,KAAK,WAAW;AACjD,aAAO,SAAS,aAAa,EAAE;AAAA,IACjC;AAEA,UAAM,MAAM,KAAK,eAAe;AAAA,MAC9B;AAAA,MACA;AAAA,MACA,KAAK,eAAe,gBAAgB,QAAQ;AAAA,IAC9C;AAEA,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,MAAM,SAAS,WAAW,YAAY,SAAS,cAAc;AAE3D,QAAI,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC9B,qBAAe;AACf,gBAAU;AACV,mBAAa,QAAQ;AAAA,IACvB;AAEA,QAAI,CAAC,cAAc;AAEjB,qBAAe;AAAA,IACjB;AAEA,kBAAU,yBAAU,OAAO,KAAK,CAAC;AACjC,YAAQ,SAAS;AACjB,UAAM,MAAM,KAAK,eAAe,cAAc,WAAW,SAAS,YAAY;AAE9E,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,EAAE,GAAG,SAAS,oBAAoB,MAAM,CAAC;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,UAAU,WAAW,SAAS;AAClC,UAAM,MAAM,KAAK,eAAe,iBAAiB,WAAW,OAAO;AAEnE,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,EAAE,GAAG,SAAS,MAAM,8BAAW,YAAY,CAAC;AAAA,EACxF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,YAAY,WAAW,uBAAuB,SAAS;AAC3D,gBAAY,CAAC;AACb,UAAM,MAAM,KAAK,eAAe,iBAAiB,WAAW,uBAAuB,OAAO;AAE1F,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EACnD;AAAA,EAEA,MAAM,OAAO,UAAU,WAAW,QAAQ,SAAS;AACjD,QAAI,SAAS,MAAM;AACjB,2CAAqB,QAAQ,IAAI;AAAA,IACnC;AAEA,kBAAU,yBAAU,OAAO,KAAK,CAAC;AACjC,UAAM,kBAAkB,UAAU;AAElC,YAAQ,aAAa,iBAAiB,QAAQ;AAC9C,UAAM,EAAE,MAAM,MAAM,IAAI,KAAK,eAAe;AAAA,MAC1C;AAAA,MACA;AAAA,MACA,uBAAmB,gCAAiB,gBAAgB,UAAU;AAAA,MAC9D;AAAA,IACF;AAEA,YAAQ,OAAO,8BAAW;AAC1B,YAAQ,WAAW;AAGnB,WAAO,QAAQ;AACf,YAAQ,WAAO,yBAAa,QAAQ,MAAM,IAAI;AAE9C,UAAM,UAAU,MAAM,KAAK,UAAU,SAAS,OAAO,OAAO;AAC5D,QAAI,UAAU;AACZ,cAAQ,CAAC,EAAE,cAAc;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,MAAM,OAAO,WAAW,cAAc,cAAc,OAAO,SAAS;AAClE,QAAI,CAAC,KAAK,QAAQ,MAAM;AACtB,YAAM,IAAI,MAAM,oCAAoC,KAAK,QAAQ,eAAe;AAAA,IAClF;AAEA,QAAI,SAAS,MAAM;AACjB,2CAAqB,QAAQ,IAAI;AAAA,IACnC;AAEA,cAAU,EAAE,GAAG,QAAQ;AAEvB,UAAM,QAAQ,QAAQ;AACtB,UAAM,kBAAkB,MAAM;AAE9B,YAAQ,OAAO,8BAAW;AAC1B,YAAQ,oBAAoB,OAAO,KAAK,YAAY;AACpD,YAAQ,aAAa,QAAQ,kBAAkB,CAAC;AAEhD,QAAI,QAAQ,WAAW,WAAW,GAAG;AACnC,YAAM,cAAc,MAAM;AAAA,YACxB;AAAA,UACE,gBAAgB;AAAA,UAChB,gBAAc,gBAAgB,WAAW,IAAI,UAAU,EAAE;AAAA,QAC3D;AAAA,MACF;AAEA,YAAM,oBAAoB,OAAO,OAAO,MAAM,WAAW,CAAC,EACvD,OAAO,OAAK,EAAE,UAAU,EAAE,OAAO,SAAS,CAAC,EAC3C,IAAI,OAAK,EAAE,MAAM;AAGpB,iBAAW,SAAS,QAAQ,mBAAmB;AAC7C,cAAM,WAAW,kBAAkB,KAAK,YAAU,OAAO,SAAS,KAAK,CAAC;AACxE,YAAI,UAAU;AACZ,kBAAQ,aAAa;AACrB;AAAA,QACF;AAAA,MACF;AAGA,UACE,QAAQ,WAAW,WAAW,SAC9B,oBAAAC,SAAa,QAAQ,mBAAmB,WAAW,EAAE,SAAS,GAC9D;AACA,gBAAQ,aAAa;AAAA,MACvB;AAEA,cAAQ,iBAAa,YAAAC,SAAK,QAAQ,UAAU;AAAA,IAC9C;AAEA,UAAM,EAAE,MAAM,MAAM,IAAI,KAAK,eAAe;AAAA,MAC1C;AAAA,MACA;AAAA,UACA,gCAAiB,gBAAgB,UAAU;AAAA,MAC3C;AAAA,IACF;AAGA,WAAO,QAAQ;AACf,YAAQ,WAAO,yBAAa,QAAQ,MAAM,IAAI;AAE9C,WAAO,MAAM,KAAK,UAAU,SAAS,OAAO,OAAO;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBA,MAAM,WAAW,WAAW,SAAS,SAAS,YAAY;AACxD,cAAU,EAAE,GAAG,SAAS,MAAM,8BAAW,OAAO;AAEhD,UAAM,MAAM,KAAK,eAAe,gBAAgB,WAAW,SAAS,SAAS,UAAU;AAGvF,WAAO,QAAQ;AAEf,UAAM,UAAU,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAE1D,WAAO,QAAQ,CAAC;AAAA,EAClB;AAAA,EAEA,MAAM,OAAO,UAAU,WAAW,QAAQ,OAAO,SAAS;AACxD,QAAI,SAAS,MAAM;AACjB,2CAAqB,QAAQ,IAAI;AAAA,IACnC;AAEA,UAAM,kBAAkB,UAAU;AAElC,cAAU,EAAE,GAAG,SAAS,OAAO,UAAU,YAAY;AACrD,YAAQ,aAAa,iBAAiB,QAAQ;AAE9C,UAAM,EAAE,MAAM,MAAM,IAAI,KAAK,eAAe;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,uBAAmB,gCAAiB,gBAAgB,UAAU;AAAA,IAChE;AAEA,YAAQ,OAAO,8BAAW;AAC1B,YAAQ,WAAW;AAEnB,WAAO,QAAQ;AAEf,YAAQ,WAAO,yBAAa,QAAQ,MAAM,IAAI;AAE9C,WAAO,MAAM,KAAK,UAAU,SAAS,OAAO,OAAO;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,MAAM,WAAW,WAAW,QAAQ,OAAO,SAAS,mBAAmB;AACrE,QAAI,SAAS,MAAM;AACjB,2CAAqB,QAAQ,IAAI;AAAA,IACnC;AAEA,kBAAU,yBAAU,OAAO,KAAK,CAAC;AACjC,QAAI,OAAO,UAAU,UAAU;AAC7B,kBAAQ,yBAAU,KAAK,KAAK,CAAC;AAAA,IAC/B;AAEA,UAAM,EAAE,MAAM,MAAM,IAAI,KAAK,eAAe;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,YAAQ,gBAAAC,SAAS,SAAS,IAAI,YAAY,EAAE,UAAU;AAC5D,UAAM,QAAQ,QAAQ,QAClB,QAAQ,YACR,YAAAC,SAAK,KAAK,UAAU,QAAQ,EAAE,WAAW,MAAM,UAAU,CAAC;AAE9D,YAAQ,OAAO,8BAAW;AAC1B,YAAQ,QAAQ;AAChB,YAAQ,WAAO,yBAAa,QAAQ,MAAM,IAAI;AAE9C,WAAO,MAAM,KAAK,UAAU,SAAS,OAAO,OAAO;AAAA,EACrD;AAAA,EAEA,MAAM,OAAO,OAAO,WAAW,YAAY;AACzC,UAAM,gBAAgB,WAAW,iBAAiB,KAAK,UAAU,QAAQ;AACzE,UAAM,UAAU,EAAE,GAAG,YAAY,MAAM,8BAAW,QAAQ,OAAO,cAAc;AAE/E,UAAM,MAAM,KAAK,eAAe,YAAY,WAAW,SAAS,KAAK;AAGrE,WAAO,QAAQ;AAEf,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EACnD;AAAA,EAEA,MAAM,UACJ,OACA,WACA,OACA,yBACA,4BACA,SACA;AACA,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,UACJ,OACA,WACA,OACA,yBACA,4BACA,SACA;AACA,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,iBACJ,UACA,OACA,WACA,OACA,6BACA,4BACA,SACA;AACA,kBAAU,yBAAU,OAAO,KAAK,CAAC;AACjC,YAAQ,QAAQ;AAEhB,UAAM,MAAM,KAAK,eAAe;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,YAAQ,OAAO,8BAAW;AAG1B,WAAO,QAAQ;AAEf,WAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,EACnD;AAAA,EAEA,MAAM,UAAU,WAAW,SAAS,mBAAmB,OAAO;AAC5D,kBAAU,yBAAU,OAAO,KAAK,CAAC;AACjC,kBAAU,gBAAAC,SAAS,SAAS;AAAA,MAC1B,KAAK;AAAA,MACL,OAAO;AAAA,MACP,MAAM,8BAAW;AAAA,IACnB,CAAC;AAED,UAAM,MAAM,KAAK,eAAe,YAAY,WAAW,SAAS,KAAK;AAErE,QAAI,sBAAsB,QAAW;AACnC,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAGA,WAAO,QAAQ;AAEf,UAAM,OAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AACvD,QAAI,CAAC,QAAQ,OAAO;AAClB,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,OAAO,KAAK,iBAAiB,IAAI;AAEhD,QAAI,CAAC,WAAW,CAAC,QAAQ,UAAU;AACjC,aAAO;AAAA,IACT;AAEA,UAAM,WAAW,QAAQ;AAIzB,SACG,oBAAoB,UAAU,WAAW,oBAAoB,UAAU,UACxE,WAAW,MACX;AACA,aAAO,OAAO,WAAW,MAAM;AAAA,IACjC;AAIA,SACG,oBAAoB,UAAU,WAAW,oBAAoB,UAAU,WACxE,WAAW,MACX;AACA,aAAO,OAAO,SAAS,QAAQ,EAAE;AAAA,IACnC;AAEA,QAAI,oBAAoB,UAAU,QAAQ,WAAW,QAAQ,EAAE,kBAAkB,OAAO;AACtF,aAAO,IAAI,KAAK,MAAM;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,cACJ,WACA,aACA,YACA,aACA,cACA,gBACA,cACA,SACA;AACA,UAAM,MAAM,KAAK,eAAe;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,gBAAY,CAAC;AACb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,MAAM,YAAY,WAAW,aAAa,SAAS;AACjD,UAAM,MAAM,KAAK,eAAe,YAAY,WAAW,WAAW;AAClE,gBAAY,CAAC;AAEb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,MAAM,cAAc,WAAW,gBAAgB,gBAAgB,SAAS;AACtE,UAAM,MAAM,KAAK,eAAe,cAAc,WAAW,gBAAgB,cAAc;AACvF,gBAAY,CAAC;AAEb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,MAAM,eAAe,cAAc,QAAQ,YAAY,UAAU,MAAM,cAAc,SAAS;AAC5F,UAAM,MAAM,KAAK,eAAe;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,gBAAY,CAAC;AAEb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,MAAM,aAAa,cAAc,QAAQ,SAAS;AAChD,UAAM,MAAM,KAAK,eAAe,aAAa,cAAc,MAAM;AACjE,gBAAY,CAAC;AAEb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,MAAM,eAAe,iBAAiB,QAAQ,iBAAiB,SAAS;AACtE,UAAM,MAAM,KAAK,eAAe,eAAe,iBAAiB,QAAQ,eAAe;AACvF,gBAAY,CAAC;AAEb,QAAI,KAAK;AACP,aAAO,MAAM,KAAK,UAAU,SAAS,KAAK,OAAO;AAAA,IACnD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc;AAAA,EAEd;AACF;",
  "names": ["mapValues", "intersection", "uniq", "isObject", "find", "defaults"]
}
