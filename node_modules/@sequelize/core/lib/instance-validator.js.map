{
  "version": 3,
  "sources": ["../src/instance-validator.js"],
  "sourcesContent": ["'use strict';\n\nimport difference from 'lodash/difference';\nimport forIn from 'lodash/forIn';\nimport get from 'lodash/get';\nimport { promisify } from 'node:util';\nimport { AbstractDataType } from './abstract-dialect/data-types';\nimport { validateDataType } from './abstract-dialect/data-types-utils';\nimport { BelongsToAssociation } from './associations/belongs-to';\nimport * as SequelizeError from './errors';\nimport { BaseSqlExpression } from './expression-builders/base-sql-expression.js';\nimport { getAllOwnKeys } from './utils/object';\nimport { validator } from './utils/validator-extras';\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nexport class InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options,\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = difference(\n        Array.from(modelInstance.modelDefinition.attributes.keys()),\n        options.fields,\n      );\n    } else {\n      options.skip ??= [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) {\n      throw new Error('Validations already in progress.');\n    }\n\n    this.inProgress = true;\n\n    await Promise.all([this._perAttributeValidators(), this._customValidators()]);\n\n    if (this.errors.length > 0) {\n      throw new SequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    await this.modelInstance.constructor.hooks.runAsync(\n      'beforeValidate',\n      this.modelInstance,\n      this.options,\n    );\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await this.modelInstance.constructor.hooks.runAsync(\n        'validationFailed',\n        this.modelInstance,\n        this.options,\n        error,\n      );\n      throw newError || error;\n    }\n\n    await this.modelInstance.constructor.hooks.runAsync(\n      'afterValidate',\n      this.modelInstance,\n      this.options,\n    );\n\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    const { attributes } = this.modelInstance.modelDefinition;\n\n    for (const attribute of attributes.values()) {\n      const attrName = attribute.attributeName;\n\n      if (this.options.skip.includes(attrName)) {\n        continue;\n      }\n\n      const value = this.modelInstance.dataValues[attrName];\n\n      if (value instanceof BaseSqlExpression) {\n        continue;\n      }\n\n      if (!attribute._autoGenerated && !attribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(attribute, attrName, value);\n      }\n\n      if (attribute.validate) {\n        validators.push(this._singleAttrValidate(value, attrName, attribute.allowNull));\n      }\n    }\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n\n    const validateOptions = this.modelInstance.constructor.options.validate;\n\n    for (const validatorName of getAllOwnKeys(validateOptions)) {\n      if (this.options.skip.includes(validatorName)) {\n        continue;\n      }\n\n      const validator = validateOptions[validatorName];\n\n      const valprom = this._invokeCustomValidator(validator, validatorName)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    }\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} attributeName The attribute name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, attributeName, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if (value == null && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n\n    const attribute = this.modelInstance.modelDefinition.attributes.get(attributeName);\n\n    forIn(attribute.validate, (test, validatorType) => {\n      if (['isUrl', 'isURL', 'isEmail'].includes(validatorType)) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg,\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(\n          this._invokeCustomValidator(test, validatorType, true, value, attributeName),\n        );\n\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(\n        value,\n        test,\n        validatorType,\n        attributeName,\n      );\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise.all(\n      validators.map(validator =>\n        validator.catch(error => {\n          const isBuiltIn = Boolean(error.validatorName);\n          this._pushError(\n            isBuiltIn,\n            attributeName,\n            error,\n            value,\n            error.validatorName,\n            error.validatorArgs,\n          );\n        }),\n      ),\n    );\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    // TODO [>7]: validators should receive their model as the first argument, not through \"this\".\n    //  Only exception to this is the @ModelValidator decorator when used on an instance method, but it is responsible for that\n    //  behavior, not this!\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (error) {\n        return this._pushError(false, errorKey, error, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (error) {\n      return this._pushError(false, errorKey, error, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new TypeError(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {\n        validatorName: validatorType,\n        validatorArgs,\n      });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator =\n      typeof validatorArgs !== 'string' &&\n      ['isAlpha', 'isAlphanumeric', 'isMobilePhone'].includes(validatorType);\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = [...validatorArgs];\n    }\n\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} attribute As defined in the Schema.\n   * @param {string} attributeName The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(attribute, attributeName, value) {\n    if (attribute.allowNull === false && value == null) {\n      const modelDefinition = this.modelInstance.modelDefinition;\n\n      const association = Object.values(modelDefinition.associations).find(\n        association =>\n          association instanceof BelongsToAssociation &&\n          association.foreignKey === attribute.fieldName,\n      );\n\n      if (!association || !this.modelInstance.get(association.as)) {\n        const validators = modelDefinition.attributes.get(attributeName)?.validate;\n        const errMsg = get(\n          validators,\n          'notNull.msg',\n          `${this.modelInstance.constructor.name}.${attributeName} cannot be null`,\n        );\n\n        this.errors.push(\n          new SequelizeError.ValidationErrorItem(\n            errMsg,\n            'notNull violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n            attributeName,\n            value,\n            this.modelInstance,\n            'is_null',\n          ),\n        );\n      }\n    }\n\n    const type = attribute.type;\n    if (\n      value != null &&\n      !(value instanceof BaseSqlExpression) &&\n      type instanceof AbstractDataType\n    ) {\n      const error = validateDataType(value, type, attributeName, this.modelInstance);\n      if (error) {\n        this.errors.push(error);\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new SequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined,\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n"],
  "mappings": "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",
  "names": ["difference", "validator", "forIn", "association", "get"]
}
