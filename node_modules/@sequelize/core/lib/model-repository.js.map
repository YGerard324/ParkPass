{
  "version": 3,
  "sources": ["../src/model-repository.ts"],
  "sourcesContent": ["import { EMPTY_ARRAY, EMPTY_OBJECT, shallowClonePojo } from '@sequelize/utils';\nimport assert from 'node:assert';\nimport { getBelongsToAssociationsWithTarget } from './_model-internals/get-belongs-to-associations-with-target.js';\nimport type { BelongsToAssociation } from './associations/index.js';\nimport { mayRunHook } from './hooks.js';\nimport type { ModelDefinition } from './model-definition.js';\nimport {\n  assertHasPrimaryKey,\n  assertHasWhereOptions,\n  ensureOptionsAreImmutable,\n  getModelPkWhere,\n  getPrimaryKeyValueOrThrow,\n  setTransactionFromCls,\n} from './model-internals.js';\nimport type {\n  BulkDestroyOptions,\n  CommonDestroyOptions,\n  DestroyManyOptions,\n} from './model-repository.types.js';\nimport { ManualOnDelete } from './model-repository.types.js';\nimport type { Model, Transactionable } from './model.js';\nimport { Op } from './operators.js';\n\n/**\n * The goal of this class is to become the new home of all the static methods that are currently present on the Model class,\n * as a way to enable a true Repository Mode for Sequelize.\n *\n * Currently, this class is not usable as a repository (due to having a dependency on ModelStatic), but as we migrate all of\n * Model to this class, we will be able to remove the dependency on ModelStatic, and make this class usable as a repository.\n *\n * See https://github.com/sequelize/sequelize/issues/15389 for more details.\n *\n * Unlike {@link ModelDefinition}, it's possible to have multiple different repositories for the same model (as users can provide their own implementation).\n */\nexport class ModelRepository<M extends Model = Model> {\n  readonly #modelDefinition: ModelDefinition<M>;\n\n  constructor(modelDefinition: ModelDefinition<M>) {\n    this.#modelDefinition = modelDefinition;\n  }\n\n  get #sequelize() {\n    return this.#modelDefinition.sequelize;\n  }\n\n  get #queryInterface() {\n    return this.#sequelize.queryInterface;\n  }\n\n  async _UNSTABLE_destroy(\n    instanceOrInstances: readonly M[] | M,\n    options: DestroyManyOptions = EMPTY_OBJECT,\n  ): Promise<number> {\n    options = shallowClonePojo(options);\n    options.manualOnDelete ??= ManualOnDelete.paranoid;\n\n    assertHasPrimaryKey(this.#modelDefinition);\n    setTransactionFromCls(options, this.#sequelize);\n\n    const instances: M[] = Array.isArray(instanceOrInstances)\n      ? [...instanceOrInstances]\n      : [instanceOrInstances];\n    if (instances.length === 0) {\n      return 0;\n    }\n\n    options = ensureOptionsAreImmutable(options);\n\n    if (mayRunHook('beforeDestroyMany', options.noHooks)) {\n      await this.#modelDefinition.hooks.runAsync('beforeDestroyMany', instances, options);\n\n      // in case the beforeDestroyMany hook removed all instances.\n      if (instances.length === 0) {\n        return 0;\n      }\n    }\n\n    Object.freeze(instances);\n\n    let result: number;\n    const cascadingAssociations = this.#getCascadingDeleteAssociations(options);\n    if (cascadingAssociations.length > 0 && !options.transaction) {\n      result = await this.#sequelize.transaction(async transaction => {\n        options.transaction = transaction;\n        Object.freeze(options);\n\n        return this.#destroyInternal(instances, cascadingAssociations, options);\n      });\n    } else {\n      Object.freeze(options);\n      result = await this.#destroyInternal(instances, cascadingAssociations, options);\n    }\n\n    if (mayRunHook('afterDestroyMany', options.noHooks)) {\n      await this.#modelDefinition.hooks.runAsync('afterDestroyMany', instances, options, result);\n    }\n\n    return result;\n  }\n\n  async #destroyInternal(\n    instances: readonly M[],\n    cascadingAssociations: readonly BelongsToAssociation[],\n    options: DestroyManyOptions,\n  ): Promise<number> {\n    if (cascadingAssociations.length > 0) {\n      await this.#manuallyCascadeDestroy(instances, cascadingAssociations, options);\n    }\n\n    const isSoftDelete = !options.hardDelete && this.#modelDefinition.isParanoid();\n    if (isSoftDelete) {\n      // TODO: implement once updateMany is implemented - https://github.com/sequelize/sequelize/issues/4501\n      throw new Error('ModelRepository#_UNSTABLE_destroy does not support paranoid deletion yet.');\n    }\n\n    const primaryKeys = this.#modelDefinition.primaryKeysAttributeNames;\n    let where;\n    if (instances.length === 1) {\n      where = getModelPkWhere(instances[0], true)!;\n    } else if (primaryKeys.size === 1 && !this.#modelDefinition.versionAttributeName) {\n      const primaryKey: string = primaryKeys.values().next().value;\n\n      const values = instances.map(instance => getPrimaryKeyValueOrThrow(instance, primaryKey));\n\n      where = { [primaryKey]: values };\n    } else {\n      where = {\n        // Ideally, we'd use tuple comparison here, but that's not supported by Sequelize yet.\n        // It would look like this:\n        // WHERE (id1, id2) IN ((1, 2), (3, 4))\n        [Op.or]: instances.map(instance => getModelPkWhere(instance, true)!),\n      };\n    }\n\n    const bulkDeleteOptions = {\n      ...options,\n      limit: null,\n      where,\n    };\n\n    // DestroyManyOptions-specific options.\n    delete bulkDeleteOptions.hardDelete;\n    delete bulkDeleteOptions.noHooks;\n\n    return this.#queryInterface.bulkDelete(this.#modelDefinition, bulkDeleteOptions);\n  }\n\n  async _UNSTABLE_bulkDestroy(options: BulkDestroyOptions<M>) {\n    options = shallowClonePojo(options);\n    options.manualOnDelete ??= ManualOnDelete.paranoid;\n\n    assertHasWhereOptions(options);\n    setTransactionFromCls(options, this.#sequelize);\n\n    // TODO: support \"scope\" option + default scope\n\n    const modelDefinition = this.#modelDefinition;\n\n    if (mayRunHook('_UNSTABLE_beforeBulkDestroy', options.noHooks)) {\n      await modelDefinition.hooks.runAsync('_UNSTABLE_beforeBulkDestroy', options);\n    }\n\n    let result: number;\n    const cascadingAssociations = this.#getCascadingDeleteAssociations(options);\n    if (cascadingAssociations.length > 0 && !options.transaction) {\n      result = await this.#sequelize.transaction(async transaction => {\n        options.transaction = transaction;\n        Object.freeze(options);\n\n        return this.#bulkDestroyInternal(cascadingAssociations, options);\n      });\n    } else {\n      Object.freeze(options);\n      result = await this.#bulkDestroyInternal(cascadingAssociations, options);\n    }\n\n    if (mayRunHook('_UNSTABLE_afterBulkDestroy', options.noHooks)) {\n      await modelDefinition.hooks.runAsync('_UNSTABLE_afterBulkDestroy', options, result);\n    }\n\n    return result;\n  }\n\n  async #bulkDestroyInternal(\n    cascadingAssociations: readonly BelongsToAssociation[],\n    options: BulkDestroyOptions<M>,\n  ): Promise<number> {\n    const modelDefinition = this.#modelDefinition;\n\n    if (cascadingAssociations.length > 0) {\n      // TODO: if we know this is the last cascade,\n      //  we can avoid the fetch and call bulkDestroy directly instead of destroyMany.\n      // TODO: only fetch the attributes that are referenced by a foreign key, not all attributes.\n      const instances: M[] = await modelDefinition.model.findAll(options);\n\n      await this.#manuallyCascadeDestroy(instances, cascadingAssociations, options);\n    }\n\n    const deletedAtAttributeName = modelDefinition.timestampAttributeNames.deletedAt;\n    if (deletedAtAttributeName && !options.hardDelete) {\n      throw new Error(\n        'ModelRepository#_UNSTABLE_bulkDestroy does not support paranoid deletion yet.',\n      );\n      // const deletedAtAttribute = modelDefinition.attributes.getOrThrow(deletedAtAttributeName);\n\n      // return this.#queryInterface.bulkUpdate(\n      //   modelDefinition,\n      //   pojo({\n      //     [deletedAtAttributeName]: new Date(),\n      //   }),\n      //   and(\n      //     {\n      //       [deletedAtAttributeName]: deletedAtAttribute.defaultValue ?? null,\n      //     },\n      //     options.where,\n      //   ),\n      //   options,\n      // );\n    }\n\n    return this.#queryInterface.bulkDelete(this.#modelDefinition, options);\n  }\n\n  #getCascadingDeleteAssociations(\n    options: CommonDestroyOptions & Transactionable,\n  ): readonly BelongsToAssociation[] {\n    if (options.manualOnDelete === ManualOnDelete.none) {\n      return EMPTY_ARRAY;\n    }\n\n    if (\n      options.manualOnDelete === ManualOnDelete.paranoid &&\n      !options.hardDelete &&\n      this.#modelDefinition.isParanoid()\n    ) {\n      return EMPTY_ARRAY;\n    }\n\n    const belongsToAssociations = getBelongsToAssociationsWithTarget(this.#modelDefinition.model);\n\n    return belongsToAssociations.filter(association => {\n      const source = association.source.modelDefinition;\n      const foreignKey = source.physicalAttributes.getOrThrow(association.foreignKey);\n\n      return (\n        foreignKey.onDelete === 'CASCADE' ||\n        foreignKey.onDelete === 'SET NULL' ||\n        foreignKey.onDelete === 'SET DEFAULT'\n      );\n    });\n  }\n\n  async #manuallyCascadeDestroy(\n    instances: readonly M[],\n    cascadingAssociations: readonly BelongsToAssociation[],\n    options: CommonDestroyOptions & Transactionable,\n  ) {\n    assert(options.transaction, 'Handling ON DELETE in JavaScript requires a transaction.');\n\n    const isSoftDelete = !options.hardDelete && this.#modelDefinition.isParanoid();\n\n    await Promise.all(\n      cascadingAssociations.map(async association => {\n        const source = association.source.modelDefinition;\n        const foreignKey = source.physicalAttributes.getOrThrow(association.foreignKey);\n\n        switch (foreignKey.onDelete) {\n          case 'CASCADE': {\n            // Because the cascade can lead to further cascades,\n            // we need to fetch the instances first to recursively destroy them.\n            // TODO: if we know this is the last cascade,\n            //  we can avoid the fetch and call bulkDestroy directly instead of destroyMany.\n            // TODO: only fetch the attributes that are referenced by a foreign key, not all attributes.\n            const associatedInstances = await source.model.findAll({\n              transaction: options.transaction,\n              connection: options.connection,\n              where: {\n                [association.foreignKey]: instances.map(instance =>\n                  instance.get(association.targetKey),\n                ),\n              },\n            });\n\n            if (associatedInstances.length === 0) {\n              return;\n            }\n\n            if (isSoftDelete && !source.isParanoid()) {\n              throw new Error(`Trying to soft delete model ${this.#modelDefinition.modelName}, but it is associated with a non-paranoid model, ${source.modelName}, through ${association.name} with onDelete: 'CASCADE'.\nThis would lead to an active record being associated with a deleted record.`);\n            }\n\n            await source.model.modelRepository._UNSTABLE_destroy(associatedInstances, options);\n\n            return;\n          }\n\n          case 'SET NULL': {\n            // TODO: implement once bulkUpdate is implemented\n            throw new Error('Manual cascades do not support SET NULL yet.');\n          }\n\n          case 'SET DEFAULT': {\n            // TODO: implement once bulkUpdate is implemented\n            throw new Error('Manual cascades do not support SET DEFAULT yet.');\n          }\n\n          default:\n            throw new Error(`Unexpected onDelete action: ${foreignKey.onDelete}`);\n        }\n      }),\n    );\n  }\n\n  // async save(instances: M[] | M): Promise<void> {}\n  // async updateOne(instance: M, values: object, options: unknown): Promise<M> {}\n  // async updateMany(data: Array<{ instance: M, values: object }>, options: unknown): Promise<M> {}\n  // async updateMany(data: Array<{ where: object, values: object }>, options: unknown): Promise<M> {}\n  // async restore(instances: M[] | M, options: unknown): Promise<number> {}\n  // async bulkUpdate(options: unknown): Promise<M> {}\n  // async bulkRestore(options: unknown): Promise<M> {}\n}\n\nconst modelRepositories = new WeakMap<ModelDefinition, ModelRepository>();\n\nexport function getModelRepository(model: ModelDefinition): ModelRepository {\n  let internals = modelRepositories.get(model);\n  if (internals) {\n    return internals;\n  }\n\n  internals = new ModelRepository(model);\n\n  return internals;\n}\n"],
  "mappings": "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",
  "names": ["assert"]
}
