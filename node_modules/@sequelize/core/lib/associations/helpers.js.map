{
  "version": 3,
  "sources": ["../../src/associations/helpers.ts"],
  "sourcesContent": ["import isEqual from 'lodash/isEqual';\nimport isPlainObject from 'lodash/isPlainObject.js';\nimport lowerFirst from 'lodash/lowerFirst';\nimport omit from 'lodash/omit';\nimport assert from 'node:assert';\nimport NodeUtils from 'node:util';\nimport type { Class } from 'type-fest';\nimport { AssociationError } from '../errors/index.js';\nimport type { Model, ModelStatic } from '../model';\nimport type { Sequelize } from '../sequelize';\nimport * as deprecations from '../utils/deprecations.js';\nimport { isModelStatic, isSameInitialModel } from '../utils/model-utils.js';\nimport { removeUndefined } from '../utils/object.js';\nimport { pluralize, singularize } from '../utils/string.js';\nimport type { OmitConstructors } from '../utils/types.js';\nimport type {\n  Association,\n  AssociationOptions,\n  ForeignKeyOptions,\n  NormalizedAssociationOptions,\n} from './base';\nimport type { ThroughOptions } from './belongs-to-many.js';\n\nexport function checkNamingCollision(source: ModelStatic<any>, associationName: string): void {\n  if (Object.hasOwn(source.getAttributes(), associationName)) {\n    throw new Error(\n      `Naming collision between attribute '${associationName}'` +\n        ` and association '${associationName}' on model ${source.name}` +\n        '. To remedy this, change the \"as\" options in your association definition',\n    );\n  }\n}\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param association instance\n * @param mixinTargetPrototype Model prototype\n * @param methods Method names to inject\n * @param aliases Mapping between model and association method names\n */\nexport function mixinMethods<A extends Association, Aliases extends Record<string, string>>(\n  association: A,\n  mixinTargetPrototype: Model,\n  methods: Array<keyof A | keyof Aliases>,\n  aliases?: Aliases,\n): void {\n  for (const method of methods) {\n    // @ts-expect-error -- implicit any, no way around it\n    const targetMethodName = association.accessors[method];\n\n    // don't override custom methods\n    if (Object.hasOwn(mixinTargetPrototype, targetMethodName)) {\n      continue;\n    }\n\n    // @ts-expect-error -- implicit any, no way around it\n    const realMethod = aliases?.[method] || method;\n\n    Object.defineProperty(mixinTargetPrototype, targetMethodName, {\n      enumerable: false,\n      value(...params: any[]) {\n        // @ts-expect-error -- implicit any, no way around it\n        return association[realMethod](this, ...params);\n      },\n    });\n  }\n}\n\n/**\n * Used to prevent users from instantiating Associations themselves.\n * Instantiating associations is not safe as it mutates the Model object.\n *\n * @private do not expose outside sequelize\n */\nexport const AssociationSecret = Symbol('AssociationConstructorPrivateKey');\n\nexport function assertAssociationUnique(\n  type: Class<Association>,\n  source: ModelStatic<any>,\n  target: ModelStatic<any>,\n  options: NormalizedAssociationOptions<any>,\n  parent: Association | undefined,\n) {\n  const as = options.as;\n\n  const existingAssociation = source.associations[as];\n  if (!existingAssociation) {\n    return;\n  }\n\n  const incompatibilityStatus = getAssociationsIncompatibilityStatus(\n    existingAssociation,\n    type,\n    target,\n    options,\n  );\n  if ((parent || existingAssociation.parentAssociation) && incompatibilityStatus == null) {\n    return;\n  }\n\n  const existingRoot = existingAssociation.rootAssociation;\n\n  if (!parent && existingRoot === existingAssociation) {\n    throw new AssociationError(\n      `You have defined two associations with the same name \"${as}\" on the model \"${source.name}\". Use another alias using the \"as\" parameter.`,\n    );\n  }\n\n  throw new AssociationError(\n    `\n${parent ? `The association \"${parent.as}\" needs to define` : `You are trying to define`} the ${type.name} association \"${options.as}\" from ${source.name} to ${target.name},\nbut that child association has already been defined as ${existingAssociation.associationType}, to ${target.name} by this call:\n\n${existingRoot.source.name}.${lowerFirst(existingRoot.associationType)}(${existingRoot.target.name}, ${NodeUtils.inspect(existingRoot.options)})\n\nThat association would be re-used if compatible, but it is incompatible because ${\n      incompatibilityStatus === IncompatibilityStatus.DIFFERENT_TYPES\n        ? `their types are different (${type.name} vs ${existingAssociation.associationType})`\n        : incompatibilityStatus === IncompatibilityStatus.DIFFERENT_TARGETS\n          ? `they target different models (${target.name} vs ${existingAssociation.target.name})`\n          : `their options are not reconcilable:\n\nOptions of the association to create:\n${NodeUtils.inspect(omit(options, 'inverse'), { sorted: true })}\n\nOptions of the existing association:\n${NodeUtils.inspect(omit(existingAssociation.options as any, 'inverse'), { sorted: true })}\n`\n    }`.trim(),\n  );\n}\n\n/**\n * @private\n */\nenum IncompatibilityStatus {\n  DIFFERENT_TYPES = 0,\n  DIFFERENT_TARGETS = 1,\n  DIFFERENT_OPTIONS = 2,\n}\n\nfunction getAssociationsIncompatibilityStatus(\n  existingAssociation: Association,\n  newAssociationType: Class<Association>,\n  newTarget: ModelStatic<Model>,\n  newOptions: NormalizeBaseAssociationOptions<any>,\n): IncompatibilityStatus | null {\n  if (existingAssociation.associationType !== newAssociationType.name) {\n    return IncompatibilityStatus.DIFFERENT_TYPES;\n  }\n\n  if (!isSameInitialModel(existingAssociation.target, newTarget)) {\n    return IncompatibilityStatus.DIFFERENT_TARGETS;\n  }\n\n  const opts1 = omit(existingAssociation.options as any, 'inverse');\n  const opts2 = omit(newOptions, 'inverse');\n  if (!isEqual(opts1, opts2)) {\n    return IncompatibilityStatus.DIFFERENT_OPTIONS;\n  }\n\n  return null;\n}\n\nexport function assertAssociationModelIsDefined(model: ModelStatic<any>): void {\n  if (!model.sequelize) {\n    throw new Error(\n      `Model ${model.name} must be defined (through Model.init or Sequelize#define) before calling one of its association declaration methods.`,\n    );\n  }\n}\n\nexport type AssociationStatic<T extends Association> = {\n  new (...arguments_: any[]): T;\n} & OmitConstructors<typeof Association>;\n\nexport function defineAssociation<\n  T extends Association,\n  RawOptions extends AssociationOptions<any>,\n  CleanOptions extends NormalizedAssociationOptions<any>,\n>(\n  type: AssociationStatic<T>,\n  source: ModelStatic<Model>,\n  target: ModelStatic<Model>,\n  options: RawOptions,\n  parent: Association<any> | undefined,\n  normalizeOptions: (\n    type: AssociationStatic<T>,\n    options: RawOptions,\n    source: ModelStatic<Model>,\n    target: ModelStatic<Model>,\n  ) => CleanOptions,\n  construct: (opts: CleanOptions) => T,\n): T {\n  if (!isModelStatic(target)) {\n    throw new Error(\n      `${source.name}.${lowerFirst(type.name)} was called with ${NodeUtils.inspect(target)} as the target model, but it is not a subclass of Sequelize's Model class`,\n    );\n  }\n\n  assertAssociationModelIsDefined(source);\n  assertAssociationModelIsDefined(target);\n\n  const normalizedOptions = normalizeOptions(type, options, source, target);\n\n  checkNamingCollision(source, normalizedOptions.as);\n  assertAssociationUnique(type, source, target, normalizedOptions, parent);\n\n  const sequelize = source.sequelize;\n  Object.defineProperty(normalizedOptions, 'sequelize', {\n    configurable: true,\n    get() {\n      deprecations.movedSequelizeParam();\n\n      return sequelize;\n    },\n  });\n\n  if (normalizedOptions.hooks) {\n    source.hooks.runSync('beforeAssociate', { source, target, type, sequelize }, normalizedOptions);\n  }\n\n  let association;\n  try {\n    association = (source.associations[normalizedOptions.as] as T) ?? construct(normalizedOptions);\n  } catch (error) {\n    throw new AssociationError(\n      parent\n        ? `Association \"${parent.as}\" needs to create the ${type.name} association \"${normalizedOptions.as}\" from ${source.name} to ${target.name}, but it failed`\n        : `Defining ${type.name} association \"${normalizedOptions.as}\" from ${source.name} to ${target.name} failed`,\n      { cause: error as Error },\n    );\n  }\n\n  if (normalizedOptions.hooks) {\n    source.hooks.runSync(\n      'afterAssociate',\n      { source, target, type, association, sequelize },\n      normalizedOptions,\n    );\n  }\n\n  checkNamingCollision(source, normalizedOptions.as);\n\n  return association;\n}\n\nexport type NormalizeBaseAssociationOptions<T> = Omit<T, 'as' | 'hooks' | 'foreignKey'> & {\n  as: string;\n  name: { singular: string; plural: string };\n  hooks: boolean;\n  foreignKey: ForeignKeyOptions<any>;\n};\n\nexport function normalizeInverseAssociation<T extends { as?: unknown }>(\n  inverse: T | string | undefined,\n): T | undefined {\n  if (typeof inverse === 'string') {\n    return { as: inverse } as T;\n  }\n\n  return inverse;\n}\n\nexport function normalizeBaseAssociationOptions<T extends AssociationOptions<any>>(\n  associationType: AssociationStatic<any>,\n  options: T,\n  source: ModelStatic<Model>,\n  target: ModelStatic<Model>,\n): NormalizeBaseAssociationOptions<T> {\n  if ('onDelete' in options || 'onUpdate' in options) {\n    throw new Error(\n      'Options \"onDelete\" and \"onUpdate\" have been moved to \"foreignKey.onDelete\" and \"foreignKey.onUpdate\" (also available as \"otherKey\" in belongsToMany)',\n    );\n  }\n\n  if ('constraints' in options) {\n    throw new Error('Option \"constraints\" has been renamed to \"foreignKeyConstraints\"');\n  }\n\n  if ('foreignKeyConstraint' in options) {\n    throw new Error(\n      'Option \"foreignKeyConstraint\" has been renamed to \"foreignKeyConstraints\" (with a \"s\" at the end)',\n    );\n  }\n\n  const isMultiAssociation = associationType.isMultiAssociation;\n\n  let name: { singular: string; plural: string };\n  let as: string;\n  if (options?.as) {\n    if (isPlainObject(options.as)) {\n      assert(typeof options.as === 'object');\n      name = options.as;\n      as = isMultiAssociation ? options.as.plural : options.as.singular;\n    } else {\n      assert(typeof options.as === 'string');\n      as = options.as;\n      name = {\n        plural: isMultiAssociation ? options.as : pluralize(options.as),\n        singular: isMultiAssociation ? singularize(options.as) : options.as,\n      };\n    }\n  } else {\n    as = lowerFirst(isMultiAssociation ? target.options.name.plural : target.options.name.singular);\n    name = {\n      plural: lowerFirst(target.options.name.plural),\n      singular: lowerFirst(target.options.name.singular),\n    };\n  }\n\n  return removeUndefined({\n    ...options,\n    foreignKey: normalizeForeignKeyOptions(options.foreignKey),\n    hooks: options.hooks ?? false,\n    as,\n    name,\n  });\n}\n\nexport function normalizeForeignKeyOptions<T extends string>(\n  foreignKey: AssociationOptions<T>['foreignKey'],\n): ForeignKeyOptions<any> {\n  return typeof foreignKey === 'string'\n    ? { name: foreignKey }\n    : removeUndefined({\n        ...foreignKey,\n        name: foreignKey?.name ?? foreignKey?.fieldName,\n        fieldName: undefined,\n      });\n}\n\nexport type MaybeForwardedModelStatic<M extends Model = Model> =\n  | ModelStatic<M>\n  | ((sequelize: Sequelize) => ModelStatic<M>);\n\nexport function getForwardedModel(\n  model: MaybeForwardedModelStatic,\n  sequelize: Sequelize,\n): ModelStatic {\n  return typeof model === 'function' && !isModelStatic(model) ? model(sequelize) : model;\n}\n\nexport function isThroughOptions<M extends Model>(val: any): val is ThroughOptions<M> {\n  return isPlainObject(val) && 'model' in val;\n}\n"],
  "mappings": "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",
  "names": ["lowerFirst", "NodeUtils", "omit", "IncompatibilityStatus", "isEqual", "isPlainObject", "assert"]
}
