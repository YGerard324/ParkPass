{
  "version": 3,
  "sources": ["../../src/associations/belongs-to.ts"],
  "sourcesContent": ["import isEqual from 'lodash/isEqual';\nimport isObject from 'lodash/isObject.js';\nimport upperFirst from 'lodash/upperFirst';\nimport assert from 'node:assert';\nimport { cloneDataType } from '../abstract-dialect/data-types-utils.js';\nimport { AssociationError } from '../errors/index.js';\nimport type {\n  AttributeNames,\n  AttributeReferencesOptions,\n  Attributes,\n  CreateOptions,\n  CreationAttributes,\n  FindOptions,\n  Model,\n  ModelStatic,\n  SaveOptions,\n} from '../model';\nimport { normalizeReference } from '../model-definition.js';\nimport { Op } from '../operators';\nimport { getColumnName } from '../utils/format.js';\nimport { isSameInitialModel } from '../utils/model-utils.js';\nimport { cloneDeep, removeUndefined } from '../utils/object.js';\nimport { camelize } from '../utils/string.js';\nimport type { AssociationOptions, SingleAssociationAccessors } from './base';\nimport { Association } from './base';\nimport { HasManyAssociation } from './has-many.js';\nimport { HasOneAssociation } from './has-one.js';\nimport type { NormalizeBaseAssociationOptions } from './helpers';\nimport { defineAssociation, mixinMethods, normalizeBaseAssociationOptions } from './helpers';\n\n/**\n * One-to-one association\n * See {@link Model.belongsTo}\n *\n * This is almost the same as {@link HasOneAssociation}, but the foreign key will be defined on the source model.\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @typeParam S The model on which {@link Model.belongsTo} has been called, on which the association methods, as well as the foreign key attribute, will be added.\n * @typeParam T The model passed to {@link Model.belongsTo}.\n * @typeParam SourceKey The name of the Foreign Key attribute on the Source model.\n * @typeParam TargetKey The name of the attribute that the foreign key in the source model will reference, typically the Primary Key.\n */\n// Note: this class is named BelongsToAssociation instead of BelongsTo to prevent naming conflicts with the BelongsTo decorator\nexport class BelongsToAssociation<\n  S extends Model = Model,\n  T extends Model = Model,\n  SourceKey extends AttributeNames<S> = any,\n  TargetKey extends AttributeNames<T> = any,\n> extends Association<S, T, SourceKey, NormalizedBelongsToOptions<SourceKey, TargetKey>> {\n  readonly accessors: SingleAssociationAccessors;\n\n  /**\n   * The attribute name of the identifier\n   *\n   * @deprecated use {@link foreignKey} instead\n   */\n  get identifier(): string {\n    return this.foreignKey;\n  }\n\n  foreignKey: SourceKey;\n\n  /**\n   * The column name of the foreign key\n   */\n  // TODO: rename to foreignKeyColumnName\n  identifierField: string;\n\n  /**\n   * The name of the attribute the foreign key points to.\n   * In belongsTo, this key is on the Target Model, instead of the Source Model  (unlike {@link HasOneAssociation.sourceKey}).\n   * The {@link Association.foreignKey} is on the Source Model.\n   */\n  targetKey: TargetKey;\n\n  /**\n   * The column name of the target key\n   */\n  // TODO: rename to targetKeyColumnName\n  readonly targetKeyField: string;\n\n  readonly targetKeyIsPrimary: boolean;\n\n  /**\n   * @deprecated use {@link BelongsToAssociation.targetKey}\n   */\n  get targetIdentifier(): string {\n    return this.targetKey;\n  }\n\n  inverse: Association | undefined;\n\n  constructor(\n    secret: symbol,\n    source: ModelStatic<S>,\n    target: ModelStatic<T>,\n    options: NormalizedBelongsToOptions<SourceKey, TargetKey>,\n    parent?: Association,\n  ) {\n    // TODO: throw is source model has a composite primary key.\n    const targetKey = options?.targetKey || (target.primaryKeyAttribute as TargetKey);\n\n    const targetAttributes = target.modelDefinition.attributes;\n\n    if (!targetAttributes.has(targetKey)) {\n      throw new Error(\n        `Unknown attribute \"${options.targetKey}\" passed as targetKey, define this attribute on model \"${target.name}\" first`,\n      );\n    }\n\n    if ('keyType' in options) {\n      throw new TypeError(\n        'Option \"keyType\" has been removed from the BelongsTo\\'s options. Set \"foreignKey.type\" instead.',\n      );\n    }\n\n    super(secret, source, target, options, parent);\n\n    this.targetKey = targetKey;\n\n    // For Db2 server, a reference column of a FOREIGN KEY must be unique\n    // else, server throws SQL0573N error. Hence, setting it here explicitly\n    // for non primary columns.\n    if (\n      target.sequelize.dialect.name === 'db2' &&\n      targetAttributes.get(this.targetKey)!.primaryKey !== true\n    ) {\n      // TODO: throw instead\n      this.target.modelDefinition.rawAttributes[this.targetKey].unique = true;\n    }\n\n    let foreignKey: string | undefined;\n    let foreignKeyAttributeOptions;\n    if (isObject(this.options?.foreignKey)) {\n      // lodash has poor typings\n      assert(typeof this.options?.foreignKey === 'object');\n\n      foreignKeyAttributeOptions = this.options.foreignKey;\n      foreignKey = this.options.foreignKey.name || this.options.foreignKey.fieldName;\n    } else if (this.options?.foreignKey) {\n      foreignKey = this.options.foreignKey;\n    }\n\n    if (!foreignKey) {\n      foreignKey = this.inferForeignKey();\n    }\n\n    this.foreignKey = foreignKey as SourceKey;\n\n    this.targetKeyField = getColumnName(targetAttributes.getOrThrow(this.targetKey));\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n\n    const targetAttribute = targetAttributes.get(this.targetKey)!;\n\n    const existingForeignKey = source.modelDefinition.rawAttributes[this.foreignKey];\n    const newForeignKeyAttribute = removeUndefined({\n      type: cloneDataType(targetAttribute.type),\n      ...foreignKeyAttributeOptions,\n      allowNull: existingForeignKey?.allowNull ?? foreignKeyAttributeOptions?.allowNull,\n    });\n\n    // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n    // on the association, or request an `onDelete` or `onUpdate` behavior\n    if (options.foreignKeyConstraints !== false) {\n      const existingReference = existingForeignKey?.references\n        ? ((normalizeReference(existingForeignKey.references) ??\n            existingForeignKey.references) as AttributeReferencesOptions)\n        : undefined;\n\n      const queryGenerator = this.source.sequelize.queryGenerator;\n\n      const existingReferencedTable = existingReference?.table\n        ? queryGenerator.extractTableDetails(existingReference.table)\n        : undefined;\n\n      const newReferencedTable = queryGenerator.extractTableDetails(this.target);\n\n      const newReference: AttributeReferencesOptions = {};\n      if (existingReferencedTable) {\n        if (!isEqual(existingReferencedTable, newReferencedTable)) {\n          throw new Error(\n            `Foreign key ${this.foreignKey} on ${this.source.name} already references ${queryGenerator.quoteTable(existingReferencedTable)}, but this association needs to make it reference ${queryGenerator.quoteTable(newReferencedTable)} instead.`,\n          );\n        }\n      } else {\n        newReference.table = newReferencedTable;\n      }\n\n      if (existingReference?.key && existingReference.key !== this.targetKeyField) {\n        throw new Error(\n          `Foreign key ${this.foreignKey} on ${this.source.name} already references column ${existingReference.key}, but this association needs to make it reference ${this.targetKeyField} instead.`,\n        );\n      }\n\n      newReference.key = this.targetKeyField;\n\n      newForeignKeyAttribute.references = newReference;\n      newForeignKeyAttribute.onDelete ??=\n        newForeignKeyAttribute.allowNull !== false ? 'SET NULL' : 'CASCADE';\n      newForeignKeyAttribute.onUpdate ??= newForeignKeyAttribute.onUpdate ?? 'CASCADE';\n    }\n\n    this.source.mergeAttributesDefault({\n      [this.foreignKey]: newForeignKeyAttribute,\n    });\n\n    this.identifierField = getColumnName(this.source.getAttributes()[this.foreignKey]);\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`,\n    };\n\n    this.#mixin(source.prototype);\n\n    if (options.inverse) {\n      const passDown = removeUndefined({\n        ...options,\n        as: options.inverse.as,\n        scope: options.inverse?.scope,\n        sourceKey: options.targetKey,\n        inverse: undefined,\n      });\n\n      delete passDown.targetKey;\n\n      switch (options.inverse.type) {\n        case 'hasMany':\n          HasManyAssociation.associate(secret, target, source, passDown, this, this);\n          break;\n\n        case 'hasOne':\n          HasOneAssociation.associate(secret, target, source, passDown, this, this);\n          break;\n\n        default:\n          throw new Error(\n            `Invalid option received for \"inverse.type\": ${options.inverse.type} is not recognised. Expected \"hasMany\" or \"hasOne\"`,\n          );\n      }\n    }\n  }\n\n  static associate<\n    S extends Model,\n    T extends Model,\n    SourceKey extends AttributeNames<S>,\n    TargetKey extends AttributeNames<T>,\n  >(\n    secret: symbol,\n    source: ModelStatic<S>,\n    target: ModelStatic<T>,\n    options: BelongsToOptions<SourceKey, TargetKey> = {},\n    parent?: Association<any>,\n  ): BelongsToAssociation<S, T, SourceKey, TargetKey> {\n    return defineAssociation<\n      BelongsToAssociation<S, T, SourceKey, TargetKey>,\n      BelongsToOptions<SourceKey, TargetKey>,\n      NormalizedBelongsToOptions<SourceKey, TargetKey>\n    >(\n      BelongsToAssociation,\n      source,\n      target,\n      options,\n      parent,\n      normalizeBaseAssociationOptions,\n      normalizedOptions => {\n        // self-associations must always set their 'as' parameter\n        if (\n          isSameInitialModel(source, target) &&\n          options.inverse &&\n          // use 'options' because this will always be set in 'newOptions'\n          (!options.as || !options.inverse.as || options.as === options.inverse.as)\n        ) {\n          throw new AssociationError(\n            `Both options \"as\" and \"inverse.as\" must be defined for belongsTo self-associations, and their value must be different, if you specify the 'inverse' option.`,\n          );\n        }\n\n        return new BelongsToAssociation(secret, source, target, normalizedOptions, parent);\n      },\n    );\n  }\n\n  #mixin(modelPrototype: Model): void {\n    mixinMethods(this, modelPrototype, ['get', 'set', 'create']);\n  }\n\n  protected inferForeignKey(): string {\n    const associationName = this.options.name.singular;\n    if (!associationName) {\n      throw new Error('Sanity check: Could not guess the name of the association');\n    }\n\n    return camelize(`${associationName}_${this.targetKey}`);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * See {@link BelongsToGetAssociationMixinOptions} for a full explanation of options.\n   * This method is mixed-in the source model prototype. See {@link BelongsToGetAssociationMixin}.\n   *\n   * @param instances source instances\n   * @param options find options\n   */\n  async get(instances: S, options?: BelongsToGetAssociationMixinOptions<T>): Promise<T | null>;\n  async get(\n    instances: S[],\n    options?: BelongsToGetAssociationMixinOptions<T>,\n  ): Promise<Map<any, T | null>>;\n  async get(\n    instances: S | S[],\n    options?: BelongsToGetAssociationMixinOptions<T>,\n  ): Promise<Map<any, T | null> | T | null> {\n    options = cloneDeep(options) ?? {};\n\n    let Target = this.target;\n    if (options.scope != null) {\n      if (!options.scope) {\n        Target = Target.withoutScope();\n      } else if (options.scope !== true) {\n        // 'true' means default scope. Which is the same as not doing anything.\n        Target = Target.withScope(options.scope);\n      }\n    }\n\n    if (options.schema != null) {\n      Target = Target.withSchema({\n        schema: options.schema,\n        schemaDelimiter: options.schemaDelimiter,\n      });\n    }\n\n    let isManyMode = true;\n    if (!Array.isArray(instances)) {\n      isManyMode = false;\n      instances = [instances];\n    }\n\n    // TODO: the scope is ignored\n    const where = Object.create(null);\n\n    if (instances.length > 1) {\n      where[this.targetKey] = {\n        [Op.in]: instances\n          .map(instance => instance.get(this.foreignKey))\n          // only fetch entities that actually have a foreign key set\n          .filter(foreignKey => foreignKey != null),\n      };\n    } else {\n      const foreignKeyValue = instances[0].get(this.foreignKey);\n\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(foreignKeyValue as any, options);\n      }\n\n      where[this.targetKey] = foreignKeyValue;\n      options.limit = null;\n    }\n\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n\n    if (isManyMode) {\n      const results = await Target.findAll(options);\n      const result = new Map<any, T | null>();\n\n      for (const instance of results) {\n        result.set(instance.get(this.targetKey, { raw: true }), instance);\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param sourceInstance the source instance\n   * @param associatedInstance An persisted instance or the primary key of an instance to associate with this. Pass `null` to remove the association.\n   * @param options options passed to `this.save`\n   */\n  async set(\n    sourceInstance: S,\n    associatedInstance: T | T[TargetKey] | null,\n    options: BelongsToSetAssociationMixinOptions<T> = {},\n  ): Promise<void> {\n    let value = associatedInstance;\n\n    if (associatedInstance != null && associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n\n    if (options.save === false) {\n      return;\n    }\n\n    // passes the changed field to save, so only that field get updated.\n    await sourceInstance.save({\n      fields: [this.foreignKey],\n      association: true,\n      ...options,\n    });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param sourceInstance the source instance\n   * @param values values to create associated model instance with\n   * @param options Options passed to `target.create` and setAssociation.\n   *\n   * @returns The created target model\n   */\n  async create(\n    sourceInstance: S,\n    // @ts-expect-error -- {} is not always assignable to 'values', but Target.create will enforce this, not us.\n    values: CreationAttributes<T> = {},\n    options: BelongsToCreateAssociationMixinOptions<T> = {},\n  ): Promise<T> {\n    values = values || {};\n    options = options || {};\n\n    const newAssociatedObject = await this.target.create(values, options);\n    await this.set(sourceInstance, newAssociatedObject, options);\n\n    return newAssociatedObject;\n  }\n}\n\n// workaround https://github.com/evanw/esbuild/issues/1260\nObject.defineProperty(BelongsToAssociation, 'name', {\n  value: 'BelongsTo',\n});\n\nexport type NormalizedBelongsToOptions<\n  SourceKey extends string,\n  TargetKey extends string,\n> = NormalizeBaseAssociationOptions<BelongsToOptions<SourceKey, TargetKey>>;\n\n/**\n * Options provided when associating models with belongsTo relationship\n *\n * @see Association class belongsTo method\n */\nexport interface BelongsToOptions<SourceKey extends string, TargetKey extends string>\n  extends AssociationOptions<SourceKey> {\n  /**\n   * The name of the field to use as the key for the association in the target table. Defaults to the primary\n   * key of the target table\n   */\n  targetKey?: TargetKey;\n\n  inverse?: {\n    type: 'hasMany' | 'hasOne';\n    as?: string;\n    scope?: AssociationOptions<any>['scope'];\n  };\n}\n\n/**\n * The options for the getAssociation mixin of the belongsTo association.\n *\n * @see BelongsToGetAssociationMixin\n */\nexport interface BelongsToGetAssociationMixinOptions<T extends Model>\n  extends FindOptions<Attributes<T>> {\n  /**\n   * Apply a scope on the related model, or remove its default scope by passing false.\n   */\n  scope?: string | string[] | boolean;\n\n  /**\n   * Apply a schema on the related model\n   */\n  schema?: string;\n  schemaDelimiter?: string;\n}\n\n/**\n * The getAssociation mixin applied to models with belongsTo.\n * An example of usage is as follows:\n *\n * ```typescript\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\n *  declare getRole: BelongsToGetAssociationMixin<Role>;\n * }\n *\n * User.belongsTo(Role);\n * ```\n *\n * @see Model.belongsTo\n */\n// TODO: in the future, type the return value based on whether the foreign key is nullable or not on the source model.\n//   if nullable, return TModel | null\n//   https://github.com/sequelize/meetings/issues/14\nexport type BelongsToGetAssociationMixin<T extends Model> = (\n  options?: BelongsToGetAssociationMixinOptions<T>,\n) => Promise<T | null>;\n\n/**\n * The options for the setAssociation mixin of the belongsTo association.\n *\n * @see BelongsToSetAssociationMixin\n */\nexport interface BelongsToSetAssociationMixinOptions<T extends Model>\n  extends SaveOptions<Attributes<T>> {\n  /**\n   * Skip saving this after setting the foreign key if false.\n   */\n  save?: boolean;\n}\n\n/**\n * The setAssociation mixin applied to models with belongsTo.\n * An example of usage is as follows:\n *\n * ```typescript\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\n *  declare setRole: BelongsToSetAssociationMixin<Role, Role['id']>;\n * }\n *\n * User.belongsTo(Role);\n * ```\n *\n * @see Model.belongsTo\n *\n * @typeParam TargetKeyType The type of the attribute that the foreign key references.\n */\nexport type BelongsToSetAssociationMixin<T extends Model, TargetKeyType> = (\n  newAssociation?: T | TargetKeyType,\n  options?: BelongsToSetAssociationMixinOptions<T>,\n) => Promise<void>;\n\n/**\n * The options for the createAssociation mixin of the belongsTo association.\n *\n * @see BelongsToCreateAssociationMixin\n */\nexport interface BelongsToCreateAssociationMixinOptions<T extends Model>\n  extends CreateOptions<Attributes<T>>,\n    BelongsToSetAssociationMixinOptions<T> {}\n\n/**\n * The createAssociation mixin applied to models with belongsTo.\n * An example of usage is as follows:\n *\n * ```typescript\n * class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {\n *   declare createRole: BelongsToCreateAssociationMixin<Role>;\n * }\n *\n * User.belongsTo(Role);\n * ```\n *\n * @see Model.belongsTo\n */\nexport type BelongsToCreateAssociationMixin<T extends Model> = (\n  values?: CreationAttributes<T>,\n  options?: BelongsToCreateAssociationMixinOptions<T>,\n) => Promise<T>;\n"],
  "mappings": "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",
  "names": ["isObject", "assert", "isEqual", "upperFirst"]
}
