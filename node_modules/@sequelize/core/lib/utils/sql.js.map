{
  "version": 3,
  "sources": ["../../src/utils/sql.ts"],
  "sourcesContent": ["import isPlainObject from 'lodash/isPlainObject';\nimport type { AbstractDialect, BindCollector } from '../abstract-dialect/dialect.js';\nimport type { EscapeOptions } from '../abstract-dialect/query-generator-typescript.js';\nimport type { AddLimitOffsetOptions } from '../abstract-dialect/query-generator.internal-types.js';\nimport type { AbstractQueryGenerator } from '../abstract-dialect/query-generator.js';\nimport { BaseSqlExpression } from '../expression-builders/base-sql-expression.js';\nimport type { BindOrReplacements, QueryRawOptions, Sequelize } from '../sequelize.js';\n\ntype OnBind = (oldName: string) => string;\n\ntype MapSqlOptions = {\n  onPositionalReplacement?(): void;\n};\n\n/**\n * Internal function used by {@link mapBindParameters} and {@link injectReplacements}.\n * Parse bind parameters & replacements in places where they would be valid SQL values.\n *\n * @param sqlString The SQL that contains the bind parameters & replacements\n * @param dialect The dialect of the SQL\n * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\n * @param onBind if provided, sequelize will call this method each time a $bind parameter is found, and replace it with its output.\n * @param options Options\n *\n * @returns The SQL with bind parameters & replacements rewritten in their dialect-specific syntax.\n */\nfunction mapBindParametersAndReplacements(\n  sqlString: string,\n  dialect: AbstractDialect,\n  replacements?: BindOrReplacements,\n  onBind?: OnBind,\n  options?: MapSqlOptions,\n): string {\n  const isNamedReplacements = isPlainObject(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  const escapeOptions: EscapeOptions = { replacements };\n\n  let lastConsumedPositionalReplacementIndex = -1;\n\n  let output: string = '';\n\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n\n      continue;\n    }\n\n    if (isString) {\n      if (char === `'` && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n\n      continue;\n    }\n\n    if (currentDollarStringTagName !== null) {\n      if (char !== '$') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      const tagName = dollarStringStartMatch?.groups?.name ?? '';\n\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n\n      continue;\n    }\n\n    if (isSingleLineComment) {\n      if (char === '\\n') {\n        isSingleLineComment = false;\n      }\n\n      continue;\n    }\n\n    if (isCommentBlock) {\n      if (char === '*' && sqlString[i + 1] === '/') {\n        isCommentBlock = false;\n      }\n\n      continue;\n    }\n\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n\n    if (char === `'`) {\n      isString = true;\n\n      // The following query is supported in almost all dialects,\n      //  SELECT E'test';\n      // but postgres interprets it as an E-prefixed string, while other dialects interpret it as\n      //  SELECT E 'test';\n      // which selects the type E and aliases it to 'test'.\n\n      stringIsBackslashEscapable =\n        // all ''-style strings in this dialect can be backslash escaped\n        dialect.canBackslashEscape() ||\n        // checking if this is a postgres-style E-prefixed string, which also supports backslash escaping\n        (dialect.supports.escapeStringConstants &&\n          // is this a E-prefixed string, such as `E'abc'`, `e'abc'` ?\n          (sqlString[i - 1] === 'E' || sqlString[i - 1] === 'e') &&\n          // reject things such as `AE'abc'` (the prefix must be exactly E)\n          canPrecedeNewToken(sqlString[i - 2]));\n\n      continue;\n    }\n\n    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\n      isSingleLineComment = true;\n      continue;\n    }\n\n    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\n      isCommentBlock = true;\n      continue;\n    }\n\n    // either the start of a $bind parameter, or the start of a $tag$string$tag$\n    if (char === '$') {\n      const previousChar = sqlString[i - 1];\n\n      // we are part of an identifier\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\n        i += dollarStringStartMatch[0].length - 1;\n\n        continue;\n      }\n\n      if (onBind) {\n        // we want to be conservative with what we consider to be a bind parameter to avoid risk of conflict with potential operators\n        // users need to add a space before the bind parameter (except after '(', ',', and '=')\n        if (!canPrecedeNewToken(previousChar)) {\n          continue;\n        }\n\n        // detect the bind param if it's a valid identifier and it's followed either by '::' (=cast), ')', whitespace of it's the end of the query.\n        const match = remainingString.match(\n          /^\\$(?<name>([a-z_][0-9a-z_]*|[1-9][0-9]*))(?:\\]|\\)|,|$|\\s|::|;)/i,\n        );\n        const bindParamName = match?.groups?.name;\n        if (!bindParamName) {\n          continue;\n        }\n\n        // we found a bind parameter\n        const newName: string = onBind(bindParamName);\n\n        // add everything before the bind parameter name\n        output += sqlString.slice(previousSliceEnd, i);\n        // continue after the bind parameter name\n        previousSliceEnd = i + bindParamName.length + 1;\n\n        output += newName;\n      }\n\n      continue;\n    }\n\n    if (isNamedReplacements && char === ':') {\n      const previousChar = sqlString[i - 1];\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', '=', and '[' (for arrays))\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = match?.groups?.name;\n      if (!replacementName) {\n        continue;\n      }\n\n      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\n      const replacementValue = replacements[replacementName];\n      if (\n        !Object.hasOwn(replacements as object, replacementName) ||\n        replacementValue === undefined\n      ) {\n        throw new Error(\n          `Named replacement \":${replacementName}\" has no entry in the replacement map.`,\n        );\n      }\n\n      const escapedReplacement = escapeValueWithBackCompat(\n        replacementValue,\n        dialect,\n        escapeOptions,\n      );\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + replacementName.length + 1;\n\n      output += escapedReplacement;\n\n      continue;\n    }\n\n    if (isPositionalReplacements && char === '?') {\n      const previousChar = sqlString[i - 1];\n\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', '=', and '[' (for arrays))\n      // -> [ is temporarily added to allow 'ARRAY[:name]' to be replaced\n      // https://github.com/sequelize/sequelize/issues/14410 will make this obsolete.\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      // don't parse ?| and ?& operators as replacements\n      const nextChar = sqlString[i + 1];\n      if (nextChar === '|' || nextChar === '&') {\n        continue;\n      }\n\n      // this is a positional replacement\n      if (options?.onPositionalReplacement) {\n        options.onPositionalReplacement();\n      }\n\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n\n      if (replacementValue === undefined) {\n        throw new Error(\n          `Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`,\n        );\n      }\n\n      const escapedReplacement = escapeValueWithBackCompat(\n        replacementValue,\n        dialect,\n        escapeOptions,\n      );\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + 1;\n\n      output += escapedReplacement;\n    }\n  }\n\n  if (isString) {\n    throw new Error(\n      `The following SQL query includes an unterminated string literal:\\n${sqlString}`,\n    );\n  }\n\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n\n  return output;\n}\n\nfunction escapeValueWithBackCompat(\n  value: unknown,\n  dialect: AbstractDialect,\n  escapeOptions: EscapeOptions,\n): string {\n  // Arrays used to be escaped as sql lists, not sql arrays\n  // now they must be escaped as sql arrays, and the old behavior has been moved to the list() function.\n  // The problem is that if we receive a list of list, there are cases where we don't want the extra parentheses around the list,\n  // such as in the case of a bulk insert.\n  // As a workaround, non-list arrays that contain dynamic values are joined with commas.\n  if (Array.isArray(value) && value.some(item => item instanceof BaseSqlExpression)) {\n    return value.map(item => dialect.queryGenerator.escape(item, escapeOptions)).join(', ');\n  }\n\n  return dialect.queryGenerator.escape(value, escapeOptions);\n}\n\nfunction canPrecedeNewToken(char: string | undefined): boolean {\n  return char === undefined || /[\\s([>,=]/.test(char);\n}\n\n/**\n * Maps bind parameters from Sequelize's format ($1 or $name) to the dialect's format.\n *\n * @param sqlString\n * @param dialect\n */\nexport function mapBindParameters(\n  sqlString: string,\n  dialect: AbstractDialect,\n): {\n  sql: string;\n  bindOrder: string[] | null;\n  parameterSet: Set<string>;\n} {\n  const parameterCollector = dialect.createBindCollector();\n  const parameterSet = new Set<string>();\n\n  const newSql = mapBindParametersAndReplacements(\n    sqlString,\n    dialect,\n    undefined,\n    foundBindParamName => {\n      parameterSet.add(foundBindParamName);\n\n      return parameterCollector.collect(foundBindParamName);\n    },\n  );\n\n  return { sql: newSql, bindOrder: parameterCollector.getBindParameterOrder(), parameterSet };\n}\n\nexport function injectReplacements(\n  sqlString: string,\n  dialect: AbstractDialect,\n  replacements: BindOrReplacements,\n  opts?: MapSqlOptions,\n): string {\n  if (replacements == null) {\n    return sqlString;\n  }\n\n  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\n    throw new TypeError(\n      `\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`,\n    );\n  }\n\n  return mapBindParametersAndReplacements(sqlString, dialect, replacements, undefined, opts);\n}\n\nfunction isBackslashEscaped(string: string, pos: number): boolean {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== '\\\\') {\n      break;\n    }\n\n    escaped = !escaped;\n  }\n\n  return escaped;\n}\n\n/**\n * Collector for dialects that only support ordered parameters, and whose order matter in the SQL query. (e.g. dialects that use the \"?\" token for parameters)\n *\n * @param token The token to use as the bind parameter (e.g. '?' in mysql).\n */\nexport function createUnspecifiedOrderedBindCollector(token = '?'): BindCollector {\n  const parameterOrder: string[] = [];\n\n  return {\n    collect(bindParameterName) {\n      parameterOrder.push(bindParameterName);\n\n      return token;\n    },\n    getBindParameterOrder() {\n      return parameterOrder;\n    },\n  };\n}\n\n/**\n * Collector for dialects that only support ordered parameters, but whose order does not matter in the SQL query (e.g. dialect that support parameters names like '$1')\n *\n * Parameter index starts at 1!\n *\n * @param prefix The prefix to place before the name of the bind parameter (e.g. @ for mssql, $ for sqlite/postgres)\n */\nexport function createSpecifiedOrderedBindCollector(prefix = '$'): BindCollector {\n  const parameterOrder: string[] = [];\n\n  return {\n    collect(bindParameterName) {\n      const cachedPosition = parameterOrder.indexOf(bindParameterName);\n      if (cachedPosition === -1) {\n        parameterOrder.push(bindParameterName);\n\n        return `${prefix}${parameterOrder.length}`;\n      }\n\n      return `${prefix}${cachedPosition + 1}`;\n    },\n    getBindParameterOrder() {\n      return parameterOrder;\n    },\n  };\n}\n\n/**\n * Collector for dialects that support named bind parameters (e.g. @name, $name, etc)\n *\n * @param parameterPrefix The prefix to place before the name of the bind parameter (e.g. @ for mssql, $ for sqlite/postgres)\n */\nexport function createNamedParamBindCollector(parameterPrefix: string): BindCollector {\n  return {\n    collect(bindParameterName: string) {\n      return parameterPrefix + bindParameterName;\n    },\n    getBindParameterOrder() {\n      return null;\n    },\n  };\n}\n\nexport function assertNoReservedBind(bind: BindOrReplacements): void {\n  if (Array.isArray(bind)) {\n    return;\n  }\n\n  for (const key of Object.keys(bind)) {\n    if (key.startsWith('sequelize_')) {\n      throw new Error(\n        'Bind parameters cannot start with \"sequelize_\", these bind parameters are reserved by Sequelize.',\n      );\n    }\n  }\n}\n\nexport function combineBinds(bindA: BindOrReplacements, bindB: { [key: string]: unknown }) {\n  if (Array.isArray(bindA)) {\n    bindA = arrayBindToNamedBind(bindA);\n  }\n\n  return {\n    ...bindA,\n    ...bindB,\n  };\n}\n\nfunction arrayBindToNamedBind(bind: unknown[]): { [key: string]: unknown } {\n  const out = Object.create(null);\n\n  // eslint-disable-next-line unicorn/no-for-loop -- too slow.\n  for (let i = 0; i < bind.length; i++) {\n    out[i + 1] = bind[i];\n  }\n\n  return out;\n}\n\nexport function escapeMysqlMariaDbString(value: string): string {\n  // eslint-disable-next-line no-control-regex -- \\u001A is intended to be in this regex\n  value = value.replaceAll(/[\\b\\0\\t\\n\\r\\u001A'\\\\]/g, s => {\n    switch (s) {\n      case '\\0':\n        return '\\\\0';\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\b':\n        return '\\\\b';\n      case '\\t':\n        return '\\\\t';\n      case '\\u001A':\n        return '\\\\Z';\n      default:\n        return `\\\\${s}`;\n    }\n  });\n\n  return `'${value}'`;\n}\n\nexport function formatDb2StyleLimitOffset(\n  options: AddLimitOffsetOptions,\n  queryGenerator: AbstractQueryGenerator,\n): string {\n  let fragment = '';\n  if (options.offset) {\n    fragment += ` OFFSET ${queryGenerator.escape(options.offset, options)} ROWS`;\n  }\n\n  if (options.limit != null) {\n    fragment += ` FETCH NEXT ${queryGenerator.escape(options.limit, options)} ROWS ONLY`;\n  }\n\n  return fragment;\n}\n\nexport function formatMySqlStyleLimitOffset(\n  options: AddLimitOffsetOptions,\n  queryGenerator: AbstractQueryGenerator,\n): string {\n  let fragment = '';\n  if (options.limit != null) {\n    fragment += ` LIMIT ${queryGenerator.escape(options.limit, options)}`;\n  } else if (options.offset) {\n    // limit must be specified if offset is specified.\n    fragment += ` LIMIT 18446744073709551615`;\n  }\n\n  if (options.offset) {\n    fragment += ` OFFSET ${queryGenerator.escape(options.offset, options)}`;\n  }\n\n  return fragment;\n}\n\nexport async function withSqliteForeignKeysOff<T>(\n  sequelize: Sequelize,\n  options: QueryRawOptions | undefined,\n  cb: () => Promise<T>,\n): Promise<T> {\n  try {\n    await sequelize.queryRaw('PRAGMA foreign_keys = OFF', options);\n\n    return await cb();\n  } finally {\n    await sequelize.queryRaw('PRAGMA foreign_keys = ON', options);\n  }\n}\n"],
  "mappings": "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",
  "names": ["isPlainObject"]
}
