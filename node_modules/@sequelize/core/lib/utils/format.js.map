{
  "version": 3,
  "sources": ["../../src/utils/format.ts"],
  "sourcesContent": ["import forIn from 'lodash/forIn';\nimport assert from 'node:assert';\nimport type { Attributes, Model, ModelStatic, NormalizedAttributeOptions, WhereOptions } from '..';\n\nexport type FinderOptions<TAttributes> = {\n  attributes?: string[];\n  where?: WhereOptions<TAttributes>;\n};\n\nexport type MappedFinderOptions<TAttributes> = Omit<FinderOptions<TAttributes>, 'attributes'> & {\n  // an array of attribute-column mapping, or just attributes\n  attributes?: Array<[columnName: string, attributeName: string] | string>;\n};\n\n/**\n * Expand and normalize finder options.\n * Mutates the \"options\" parameter.\n *\n * @param options\n * @param Model\n */\nexport function mapFinderOptions<M extends Model, T extends FinderOptions<Attributes<M>>>(\n  options: T,\n  Model: ModelStatic<M>,\n): MappedFinderOptions<Attributes<M>> {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n\n    const modelDefinition = Model.modelDefinition;\n    options.attributes = options.attributes.filter(\n      attributeName => !modelDefinition.virtualAttributeNames.has(attributeName),\n    );\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\n\n/**\n * Used to map field names in attributes\n *\n * Mutates the \"options\" parameter.\n *\n * \u26A0\uFE0F This function does not map the \"where\" or \"having\" options, this is handled by QueryGenerator's WHERE generation.\n *\n * @param options\n * @param Model\n */\nexport function mapOptionFieldNames<M extends Model>(\n  options: FinderOptions<Attributes<M>>,\n  Model: ModelStatic,\n): MappedFinderOptions<Attributes<M>> {\n  // note: parts of Sequelize rely on this function mutating its inputs.\n  //  be aware that these places need to be fixed before trying to make this a pure function.\n  //  - ephys\n\n  const out: MappedFinderOptions<Attributes<M>> = options;\n\n  if (Array.isArray(options.attributes)) {\n    out.attributes = options.attributes.map(attributeName => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attributeName !== 'string') {\n        return attributeName;\n      }\n\n      // Map attributes to column names\n      const columnName: string = Model.modelDefinition.getColumnNameLoose(attributeName);\n      if (columnName !== attributeName) {\n        return [columnName, attributeName];\n      }\n\n      return attributeName;\n    });\n  }\n\n  return out;\n}\n\n/**\n * Used to map field names in values\n *\n * @param dataValues\n * @param attributeNames\n * @param ModelClass\n */\nexport function mapValueFieldNames( // TODO: rename to mapAttributesToColumNames? See https://github.com/sequelize/meetings/issues/17\n  dataValues: Record<string, any>,\n  attributeNames: Iterable<string>,\n  ModelClass: ModelStatic,\n): Record<string, any> {\n  const values: Record<string, any> = Object.create(null);\n  const modelDefinition = ModelClass.modelDefinition;\n\n  for (const attributeName of attributeNames) {\n    if (\n      dataValues[attributeName] !== undefined &&\n      !modelDefinition.virtualAttributeNames.has(attributeName)\n    ) {\n      // Field name mapping\n      const columnName = modelDefinition.getColumnNameLoose(attributeName);\n\n      values[columnName] = dataValues[attributeName];\n    }\n  }\n\n  return values;\n}\n\n/**\n * Removes entries from `hash` whose value is either null or undefined, unless `omitNull` is false or `allowNull` includes that key.\n *\n * Keys ending with 'Id' are never removed.\n *\n * @param hash the object from which entries with nullish values will be removed.\n * @param omitNull if false, this method returns the object as-is\n * @param options\n * @param options.allowNull A list of keys that must be preserved even if their value is null or undefined.\n */\nexport function removeNullishValuesFromHash(\n  hash: Record<string, any>,\n  omitNull: boolean,\n  options?: { allowNull?: string[] },\n): Record<string, any> {\n  let result = hash;\n\n  const allowNull = options?.allowNull ?? [];\n\n  if (!omitNull) {\n    return result;\n  }\n\n  const _hash: { [key: string]: any } = Object.create(null);\n\n  forIn(hash, (val: any, key: string) => {\n    if (allowNull.includes(key) || key.endsWith('Id') || (val !== null && val !== undefined)) {\n      _hash[key] = val;\n    }\n  });\n\n  result = _hash;\n\n  return result;\n}\n\nexport function getColumnName(attribute: NormalizedAttributeOptions): string {\n  assert(attribute.fieldName != null, 'getColumnName expects a normalized attribute meta');\n\n  // field is the column name alias\n  // if no alias is set, fieldName (the JS name) will be used instead.\n  return attribute.field || attribute.fieldName;\n}\n\nexport function getAttributeName(model: ModelStatic, columnName: string): string | null {\n  return (\n    Object.values(model.getAttributes()).find(attribute => attribute.field === columnName)\n      ?.fieldName ?? null\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,yBAAmB;AAoBZ,SAAS,iBACd,SACA,OACoC;AACpC,MAAI,MAAM,QAAQ,QAAQ,UAAU,GAAG;AACrC,YAAQ,aAAa,MAAM,kCAAkC,QAAQ,UAAU;AAE/E,UAAM,kBAAkB,MAAM;AAC9B,YAAQ,aAAa,QAAQ,WAAW;AAAA,MACtC,mBAAiB,CAAC,gBAAgB,sBAAsB,IAAI,aAAa;AAAA,IAC3E;AAAA,EACF;AAEA,sBAAoB,SAAS,KAAK;AAElC,SAAO;AACT;AAYO,SAAS,oBACd,SACA,OACoC;AAKpC,QAAM,MAA0C;AAEhD,MAAI,MAAM,QAAQ,QAAQ,UAAU,GAAG;AACrC,QAAI,aAAa,QAAQ,WAAW,IAAI,mBAAiB;AAEvD,UAAI,OAAO,kBAAkB,UAAU;AACrC,eAAO;AAAA,MACT;AAGA,YAAM,aAAqB,MAAM,gBAAgB,mBAAmB,aAAa;AACjF,UAAI,eAAe,eAAe;AAChC,eAAO,CAAC,YAAY,aAAa;AAAA,MACnC;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AASO,SAAS,mBACd,YACA,gBACA,YACqB;AACrB,QAAM,SAA8B,uBAAO,OAAO,IAAI;AACtD,QAAM,kBAAkB,WAAW;AAEnC,aAAW,iBAAiB,gBAAgB;AAC1C,QACE,WAAW,aAAa,MAAM,UAC9B,CAAC,gBAAgB,sBAAsB,IAAI,aAAa,GACxD;AAEA,YAAM,aAAa,gBAAgB,mBAAmB,aAAa;AAEnE,aAAO,UAAU,IAAI,WAAW,aAAa;AAAA,IAC/C;AAAA,EACF;AAEA,SAAO;AACT;AAYO,SAAS,4BACd,MACA,UACA,SACqB;AACrB,MAAI,SAAS;AAEb,QAAM,YAAY,SAAS,aAAa,CAAC;AAEzC,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAEA,QAAM,QAAgC,uBAAO,OAAO,IAAI;AAExD,mBAAAA,SAAM,MAAM,CAAC,KAAU,QAAgB;AACrC,QAAI,UAAU,SAAS,GAAG,KAAK,IAAI,SAAS,IAAI,KAAM,QAAQ,QAAQ,QAAQ,QAAY;AACxF,YAAM,GAAG,IAAI;AAAA,IACf;AAAA,EACF,CAAC;AAED,WAAS;AAET,SAAO;AACT;AAEO,SAAS,cAAc,WAA+C;AAC3E,yBAAAC,SAAO,UAAU,aAAa,MAAM,mDAAmD;AAIvF,SAAO,UAAU,SAAS,UAAU;AACtC;AAEO,SAAS,iBAAiB,OAAoB,YAAmC;AACtF,SACE,OAAO,OAAO,MAAM,cAAc,CAAC,EAAE,KAAK,eAAa,UAAU,UAAU,UAAU,GACjF,aAAa;AAErB;",
  "names": ["forIn", "assert"]
}
