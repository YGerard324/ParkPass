{
  "version": 3,
  "sources": ["../../src/utils/object.ts"],
  "sourcesContent": ["import type { ReadonlyMapLike } from '@sequelize/utils';\nimport { SetView, combinedIterator, map, pojo } from '@sequelize/utils';\n// @ts-expect-error -- lodash/_baseIsNative is not recognized as a separate module for @types/lodash\nimport baseIsNative from 'lodash/_baseIsNative';\nimport cloneDeepWith from 'lodash/cloneDeepWith';\nimport forOwn from 'lodash/forOwn';\nimport getValue from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport isFunction from 'lodash/isFunction';\nimport isPlainObject from 'lodash/isPlainObject';\nimport isUndefined from 'lodash/isUndefined.js';\nimport mergeWith from 'lodash/mergeWith';\nimport omitBy from 'lodash/omitBy.js';\nimport { getComplexKeys } from './where.js';\n\nexport const EMPTY_SET = new SetView<never>(new Set());\n\n/**\n * Deeply merges object `b` into `a`.\n * Mutates `a`.\n *\n * Same concept as _.merge, but doesn't overwrite properties that have already been assigned.\n *\n * @param a\n * @param b\n */\nexport function mergeDefaults<T>(a: T, b: Partial<T>): T {\n  return mergeWith(a, b, (objectValue, sourceValue) => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!isPlainObject(objectValue) && objectValue !== undefined) {\n      // _.isNative includes a check for core-js and throws an error if present.\n      // Depending on _baseIsNative bypasses the core-js check.\n      if (isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n\n      return objectValue;\n    }\n\n    // eslint-disable-next-line no-useless-return -- lodash actually wants us to return `undefined` to fallback to the default customizer.\n    return;\n  });\n}\n\n/**\n * An alternative to _.merge, which doesn't clone its arguments.\n *\n * Does not mutate parameters.\n *\n * Cloning is a bad idea because options arguments may contain references to sequelize\n * models - which again reference database libs which don't like to be cloned (in particular pg-native)\n *\n * @param args\n */\nexport function merge(...args: object[]): object {\n  const result: { [key: string]: any } = Object.create(null);\n\n  for (const obj of args) {\n    forOwn(obj, (value, key) => {\n      if (value === undefined) {\n        return;\n      }\n\n      if (!result[key]) {\n        result[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(result[key])) {\n        result[key] = merge(result[key], value);\n      } else if (Array.isArray(value) && Array.isArray(result[key])) {\n        result[key] = [...value, ...result[key]];\n      } else {\n        result[key] = value;\n      }\n    });\n  }\n\n  return result;\n}\n\nexport function cloneDeep<T>(obj: T, onlyPlain?: boolean): T {\n  return cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || isPlainObject(elem)) {\n      return;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everything else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param value an Object\n * @returns a flattened object\n * @private\n */\nexport function flattenObjectDeep<T extends {}>(value: T): T extends object ? Flatten<T> : T {\n  if (!isPlainObject(value)) {\n    // TypeScript doesn't know T is an object due to isPlainObject's typings. Cast to any.\n    return value as any;\n  }\n\n  const flattenedObj: { [key: string]: any } = Object.create(null);\n\n  function flattenObject(obj: { [key: string]: any }, subPath?: string) {\n    for (const key of Object.keys(obj)) {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = getValue(obj, key);\n      }\n    }\n\n    return flattenedObj;\n  }\n\n  return flattenObject(value) as any;\n}\n\n// taken from\n// https://stackoverflow.com/questions/66614528/flatten-object-with-custom-keys-in-typescript\n// because this is typescript black magic\ntype Flatten<T extends object> = object extends T\n  ? object\n  : {\n        [K in keyof T]-?: (\n          x: NonNullable<T[K]> extends infer V\n            ? V extends object\n              ? V extends readonly any[]\n                ? Pick<T, K>\n                : Flatten<V> extends infer FV\n                  ? {\n                      [P in keyof FV as `${Extract<K, string | number>}.${Extract<P, string | number>}`]: FV[P];\n                    }\n                  : never\n              : Pick<T, K>\n            : never,\n        ) => void;\n      } extends Record<keyof T, (y: infer O) => void>\n    ? O extends unknown\n      ? { [K in keyof O]: O[K] }\n      : never\n    : never;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param objectIn The destination object.\n * @param sources The source objects.\n * @returns Returns `object`.\n * @private\n */\nexport function defaults(\n  objectIn: { [key: PropertyKey]: any },\n  ...sources: Array<{ [key: PropertyKey]: any }>\n): object {\n  for (const source of sources) {\n    if (!source) {\n      continue;\n    }\n\n    for (const key of getComplexKeys(source)) {\n      const value = objectIn[key];\n      const objectPrototype: { [key: PropertyKey]: any } = Object.prototype;\n\n      if (\n        value === undefined ||\n        (isEqual(value, objectPrototype[key]) && !Object.hasOwn(objectIn, key))\n      ) {\n        objectIn[key] = source[key];\n      }\n    }\n  }\n\n  return objectIn;\n}\n\ntype NoUndefinedField<T> = { [P in keyof T]: Exclude<T[P], null | undefined> };\n\ntype NoNullishField<T> = { [P in keyof T]: Exclude<T[P], null | undefined> };\n\nexport function removeUndefined<T extends {}>(val: T): NoUndefinedField<T> {\n  return omitBy(val, isUndefined) as NoUndefinedField<T>;\n}\n\nexport function removeNullish<T extends {}>(val: T): NoNullishField<T> {\n  return omitBy(val, v => v == null) as NoNullishField<T>;\n}\n\nexport function getObjectFromMap<K extends PropertyKey, V>(\n  aMap: Map<K, V> | ReadonlyMapLike<K, V>,\n): Record<K, V> {\n  const record = Object.create(null);\n\n  for (const key of aMap.keys()) {\n    record[key] = aMap.get(key);\n  }\n\n  return record;\n}\n\n/**\n * Returns all own keys of an object, including non-enumerable ones and symbols.\n *\n * @param object\n */\nexport function getAllOwnKeys(object: object): IterableIterator<string | symbol> {\n  return combinedIterator<string | symbol>(\n    Object.getOwnPropertySymbols(object),\n    Object.getOwnPropertyNames(object),\n  );\n}\n\n/**\n * Returns all own entries of an object, including non-enumerable ones and symbols.\n *\n * @param obj\n */\nexport function getAllOwnEntries<T>(obj: {\n  [s: PropertyKey]: T;\n}): IterableIterator<[key: string | symbol, value: T]>;\nexport function getAllOwnEntries(\n  obj: object,\n): IterableIterator<[key: string | symbol, value: unknown]>;\nexport function getAllOwnEntries(\n  obj: object,\n): IterableIterator<[key: string | symbol, value: unknown]> {\n  // @ts-expect-error -- obj[key] is implicitly any\n  return map(getAllOwnKeys(obj), key => [key, obj[key]]);\n}\n\nexport function untypedMultiSplitObject<T extends Record<string, any>>(\n  obj: T,\n  groups: Record<string, readonly string[]>,\n): [groups: Record<string, Record<string, unknown>>, unseenKeys: Set<string>] {\n  const outputGroups: Record<string, Record<string, unknown>> = pojo();\n  const unseenKeys = new Set<string>(Object.keys(obj));\n\n  for (const groupName of Object.keys(groups)) {\n    const groupKeys = groups[groupName];\n\n    const groupValues: any = pojo();\n    outputGroups[groupName] = groupValues;\n\n    for (const key of groupKeys) {\n      if (obj[key] === undefined) {\n        continue;\n      }\n\n      groupValues[key] = obj[key];\n      unseenKeys.delete(key);\n    }\n  }\n\n  return [outputGroups, unseenKeys];\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAqD;AAErD,0BAAyB;AACzB,2BAA0B;AAC1B,oBAAmB;AACnB,iBAAqB;AACrB,qBAAoB;AACpB,wBAAuB;AACvB,2BAA0B;AAC1B,yBAAwB;AACxB,uBAAsB;AACtB,oBAAmB;AACnB,mBAA+B;AAExB,MAAM,YAAY,IAAI,qBAAe,oBAAI,IAAI,CAAC;AAW9C,SAAS,cAAiB,GAAM,GAAkB;AACvD,aAAO,iBAAAA,SAAU,GAAG,GAAG,CAAC,aAAa,gBAAgB;AAEnD,QAAI,KAAC,qBAAAC,SAAc,WAAW,KAAK,gBAAgB,QAAW;AAG5D,cAAI,kBAAAC,SAAW,WAAW,SAAK,oBAAAC,SAAa,WAAW,GAAG;AACxD,eAAO,eAAe;AAAA,MACxB;AAEA,aAAO;AAAA,IACT;AAGA;AAAA,EACF,CAAC;AACH;AAYO,SAAS,SAAS,MAAwB;AAC/C,QAAM,SAAiC,uBAAO,OAAO,IAAI;AAEzD,aAAW,OAAO,MAAM;AACtB,sBAAAC,SAAO,KAAK,CAAC,OAAO,QAAQ;AAC1B,UAAI,UAAU,QAAW;AACvB;AAAA,MACF;AAEA,UAAI,CAAC,OAAO,GAAG,GAAG;AAChB,eAAO,GAAG,IAAI;AAAA,MAChB,eAAW,qBAAAH,SAAc,KAAK,SAAK,qBAAAA,SAAc,OAAO,GAAG,CAAC,GAAG;AAC7D,eAAO,GAAG,IAAI,MAAM,OAAO,GAAG,GAAG,KAAK;AAAA,MACxC,WAAW,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,OAAO,GAAG,CAAC,GAAG;AAC7D,eAAO,GAAG,IAAI,CAAC,GAAG,OAAO,GAAG,OAAO,GAAG,CAAC;AAAA,MACzC,OAAO;AACL,eAAO,GAAG,IAAI;AAAA,MAChB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,SAAS,UAAa,KAAQ,WAAwB;AAC3D,aAAO,qBAAAI,SAAc,KAAK,UAAQ;AAEhC,QAAI,MAAM,QAAQ,IAAI,SAAK,qBAAAJ,SAAc,IAAI,GAAG;AAC9C;AAAA,IACF;AAIA,QAAI,aAAa,OAAO,SAAS,UAAU;AACzC,aAAO;AAAA,IACT;AAGA,QAAI,QAAQ,OAAO,KAAK,UAAU,YAAY;AAC5C,aAAO,KAAK,MAAM;AAAA,IACpB;AAAA,EACF,CAAC;AACH;AA+BO,SAAS,kBAAgC,OAA6C;AAC3F,MAAI,KAAC,qBAAAA,SAAc,KAAK,GAAG;AAEzB,WAAO;AAAA,EACT;AAEA,QAAM,eAAuC,uBAAO,OAAO,IAAI;AAE/D,WAAS,cAAc,KAA6B,SAAkB;AACpE,eAAW,OAAO,OAAO,KAAK,GAAG,GAAG;AAClC,YAAM,iBAAiB,UAAU,GAAG,WAAW,QAAQ;AACvD,UAAI,OAAO,IAAI,GAAG,MAAM,YAAY,IAAI,GAAG,MAAM,MAAM;AACrD,sBAAc,IAAI,GAAG,GAAG,cAAc;AAAA,MACxC,OAAO;AACL,qBAAa,cAAc,QAAI,WAAAK,SAAS,KAAK,GAAG;AAAA,MAClD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,cAAc,KAAK;AAC5B;AAwCO,SAAS,SACd,aACG,SACK;AACR,aAAW,UAAU,SAAS;AAC5B,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AAEA,eAAW,WAAO,6BAAe,MAAM,GAAG;AACxC,YAAM,QAAQ,SAAS,GAAG;AAC1B,YAAM,kBAA+C,OAAO;AAE5D,UACE,UAAU,cACT,eAAAC,SAAQ,OAAO,gBAAgB,GAAG,CAAC,KAAK,CAAC,OAAO,OAAO,UAAU,GAAG,GACrE;AACA,iBAAS,GAAG,IAAI,OAAO,GAAG;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAMO,SAAS,gBAA8B,KAA6B;AACzE,aAAO,cAAAC,SAAO,KAAK,mBAAAC,OAAW;AAChC;AAEO,SAAS,cAA4B,KAA2B;AACrE,aAAO,cAAAD,SAAO,KAAK,OAAK,KAAK,IAAI;AACnC;AAEO,SAAS,iBACd,MACc;AACd,QAAM,SAAS,uBAAO,OAAO,IAAI;AAEjC,aAAW,OAAO,KAAK,KAAK,GAAG;AAC7B,WAAO,GAAG,IAAI,KAAK,IAAI,GAAG;AAAA,EAC5B;AAEA,SAAO;AACT;AAOO,SAAS,cAAc,QAAmD;AAC/E,aAAO;AAAA,IACL,OAAO,sBAAsB,MAAM;AAAA,IACnC,OAAO,oBAAoB,MAAM;AAAA,EACnC;AACF;AAaO,SAAS,iBACd,KAC0D;AAE1D,aAAO,kBAAI,cAAc,GAAG,GAAG,SAAO,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;AACvD;AAEO,SAAS,wBACd,KACA,QAC4E;AAC5E,QAAM,mBAAwD,mBAAK;AACnE,QAAM,aAAa,IAAI,IAAY,OAAO,KAAK,GAAG,CAAC;AAEnD,aAAW,aAAa,OAAO,KAAK,MAAM,GAAG;AAC3C,UAAM,YAAY,OAAO,SAAS;AAElC,UAAM,kBAAmB,mBAAK;AAC9B,iBAAa,SAAS,IAAI;AAE1B,eAAW,OAAO,WAAW;AAC3B,UAAI,IAAI,GAAG,MAAM,QAAW;AAC1B;AAAA,MACF;AAEA,kBAAY,GAAG,IAAI,IAAI,GAAG;AAC1B,iBAAW,OAAO,GAAG;AAAA,IACvB;AAAA,EACF;AAEA,SAAO,CAAC,cAAc,UAAU;AAClC;",
  "names": ["mergeWith", "isPlainObject", "isFunction", "baseIsNative", "forOwn", "cloneDeepWith", "getValue", "isEqual", "omitBy", "isUndefined"]
}
