{
  "version": 3,
  "sources": ["../../src/utils/attribute-syntax.ts"],
  "sourcesContent": ["import { pojo } from '@sequelize/utils';\nimport type { SyntaxNode } from 'bnf-parser';\nimport { BNF, Compile, ParseError } from 'bnf-parser';\nimport memoize from 'lodash/memoize.js';\nimport type { Class } from 'type-fest';\nimport { AssociationPath } from '../expression-builders/association-path.js';\nimport { Attribute } from '../expression-builders/attribute.js';\nimport { Cast } from '../expression-builders/cast.js';\nimport type { DialectAwareFn } from '../expression-builders/dialect-aware-fn.js';\nimport { Unquote } from '../expression-builders/dialect-aware-fn.js';\nimport { JsonPath } from '../expression-builders/json-path.js';\n\n/**\n * Parses the attribute syntax (the syntax of keys in WHERE POJOs) into its \"BaseExpression\" representation.\n *\n * @example\n * ```ts\n * parseAttribute('id') // => attribute('id')\n * parseAttribute('$user.id$') // => association(['user'], 'id')\n * parseAttribute('json.key') // => jsonPath(attribute('json'), ['key'])\n * parseAttribute('name::number') // => cast(attribute('name'), 'number')\n * parseAttribute('json.key::number') // => cast(jsonPath(attribute('json'), ['key']), 'number')\n * ```\n *\n * @param attribute The syntax to parse\n */\nexport const parseAttributeSyntax = memoize(parseAttributeSyntaxInternal);\n\n/**\n * Parses the syntax supported by nested JSON properties.\n * This is a subset of {@link parseAttributeSyntax}, which does not parse associations, and returns raw data\n * instead of a BaseExpression.\n */\nexport const parseNestedJsonKeySyntax = memoize(parseJsonPropertyKeyInternal);\n\n/**\n * List of supported attribute modifiers.\n * They can be specified in the attribute syntax, e.g. `foo:upper` will call the `upper` modifier on the `foo` attribute.\n *\n * All names should be lowercase, as they are case-insensitive.\n */\nconst builtInModifiers: Record<string, Class<DialectAwareFn>> = pojo({\n  unquote: Unquote,\n});\n\nfunction getModifier(name: string): Class<DialectAwareFn> {\n  const ModifierClass = builtInModifiers[name.toLowerCase()];\n  if (!ModifierClass) {\n    throw new Error(\n      `${name} is not a recognized built-in modifier. Here is the list of supported modifiers: ${Object.keys(builtInModifiers).join(', ')}`,\n    );\n  }\n\n  return ModifierClass;\n}\n\nconst attributeParser = (() => {\n  const advancedAttributeBnf = `\n    # Entry points\n\n    ## Used when parsing the attribute\n    attribute ::= ( ...association | ...identifier ) jsonPath? castOrModifiers?;\n\n    ## Used when parsing a nested JSON path used inside of an attribute\n    ## Difference with \"attribute\" is in the first part. Instead of accepting:\n    ##  $association.attribute$ & attribute\n    ## It accepts:\n    ##  key, \"quotedKey\", and [0] (index access)\n    partialJsonPath ::= ( ...indexAccess | ...key ) jsonPath? castOrModifiers? ;\n\n    # Internals\n\n    identifier ::= ( \"A\"->\"Z\" | \"a\"->\"z\" | digit | \"_\" )+ ;\n    digit ::= \"0\"->\"9\" ;\n    number ::= ...digit+ ;\n    association ::= %\"$\" identifier (\".\" identifier)* %\"$\" ;\n    jsonPath ::= ( ...indexAccess | ...keyAccess )+ ;\n    indexAccess ::= %\"[\" number %\"]\" ;\n    keyAccess ::= %\".\" key ;\n    # path segments accept dashes without needing to be quoted\n    key ::= nonEmptyString | ( \"A\"->\"Z\" | \"a\"->\"z\" | digit | \"_\" | \"-\" )+ ;\n    nonEmptyString ::= ...(%\"\\\\\"\" (anyExceptQuoteOrBackslash | escapedCharacter)+ %\"\\\\\"\") ;\n    escapedCharacter ::= %\"\\\\\\\\\" ( \"\\\\\"\" | \"\\\\\\\\\" );\n    any ::= !\"\" ;\n    anyExceptQuoteOrBackslash ::= !(\"\\\\\"\" | \"\\\\\\\\\");\n    castOrModifiers ::= (...cast | ...modifier)+;\n    cast ::= %\"::\" identifier ;\n    modifier ::= %\":\" identifier ;\n  `;\n\n  const parsedAttributeBnf = BNF.parse(advancedAttributeBnf);\n  if (parsedAttributeBnf instanceof ParseError) {\n    throw new Error(\n      `Failed to initialize attribute syntax parser. This is a Sequelize bug: ${parsedAttributeBnf.toString()}`,\n    );\n  }\n\n  return Compile(parsedAttributeBnf);\n})();\n\ninterface UselessNode<Type extends string, WrappedValue extends SyntaxNode[]> extends SyntaxNode {\n  type: Type;\n  value: WrappedValue;\n}\n\nexport interface StringNode<Type extends string> extends SyntaxNode {\n  type: Type;\n  value: string;\n}\n\ninterface AttributeAst extends SyntaxNode {\n  type: 'attribute';\n  value: [\n    attribute: StringNode<'association' | 'identifier'>,\n    jsonPath: UselessNode<\n      'jsonPath?',\n      [\n        UselessNode<\n          'jsonPath',\n          [UselessNode<'(...)+', Array<StringNode<'keyAccess' | 'indexAccess'>>>]\n        >,\n      ]\n    >,\n    castOrModifiers: UselessNode<\n      'castOrModifiers?',\n      [\n        UselessNode<\n          'castOrModifiers',\n          [UselessNode<'(...)+', Array<StringNode<'cast' | 'modifier'>>>]\n        >,\n      ]\n    >,\n  ];\n}\n\nfunction parseAttributeSyntaxInternal(\n  code: string,\n): Cast | JsonPath | AssociationPath | Attribute | DialectAwareFn {\n  // This function is expensive (parsing produces a lot of objects), but we cache the final result, so it's only\n  // going to be slow once per attribute.\n  const parsed = attributeParser.parse(code, false, 'attribute') as AttributeAst | ParseError;\n  if (parsed instanceof ParseError) {\n    throw new TypeError(`Failed to parse syntax of attribute. Parse error at index ${parsed.ref.start.index}:\n${code}\n${' '.repeat(parsed.ref.start.index)}^`);\n  }\n\n  const [attributeNode, jsonPathNodeRaw, castOrModifiersNodeRaw] = parsed.value;\n\n  let result: Cast | JsonPath | AssociationPath | Attribute | DialectAwareFn = parseAssociationPath(\n    attributeNode.value,\n  );\n\n  const jsonPathNodes = jsonPathNodeRaw.value[0]?.value[0].value;\n  if (jsonPathNodes) {\n    const path = jsonPathNodes.map(pathNode => {\n      return parseJsonPathSegment(pathNode);\n    });\n\n    result = new JsonPath(result, path);\n  }\n\n  const castOrModifierNodes = castOrModifiersNodeRaw.value[0]?.value[0].value;\n  if (castOrModifierNodes) {\n    // casts & modifiers can be chained, the last one is applied last\n    // foo:upper:lower needs to produce LOWER(UPPER(foo))\n    for (const castOrModifierNode of castOrModifierNodes) {\n      if (castOrModifierNode.type === 'cast') {\n        result = new Cast(result, castOrModifierNode.value);\n        continue;\n      }\n\n      const ModifierClass = getModifier(castOrModifierNode.value);\n\n      result = new ModifierClass(result);\n    }\n  }\n\n  return result;\n}\n\nfunction parseAssociationPath(syntax: string): AssociationPath | Attribute {\n  const path = syntax.split('.');\n\n  if (path.length > 1) {\n    const attr = path.pop()!;\n\n    return new AssociationPath(path, attr);\n  }\n\n  return new Attribute(syntax);\n}\n\n/**\n * Do not mutate this! It is memoized to avoid re-parsing the same path over and over.\n */\nexport interface ParsedJsonPropertyKey {\n  readonly pathSegments: ReadonlyArray<string | number>;\n  /**\n   * If it's a string, it's a cast. If it's a class, it's a modifier.\n   */\n  readonly castsAndModifiers: ReadonlyArray<string | Class<DialectAwareFn>>;\n}\n\ninterface JsonPathAst extends SyntaxNode {\n  type: 'partialJsonPath';\n  value: [\n    firstKey: StringNode<'key' | 'indexAccess'>,\n    jsonPath: UselessNode<\n      'jsonPath?',\n      [\n        UselessNode<\n          'jsonPath',\n          [UselessNode<'(...)+', Array<StringNode<'keyAccess' | 'indexAccess'>>>]\n        >,\n      ]\n    >,\n    castOrModifiers: UselessNode<\n      'castOrModifiers?',\n      [\n        UselessNode<\n          'castOrModifiers',\n          [UselessNode<'(...)+', Array<StringNode<'cast' | 'modifier'>>>]\n        >,\n      ]\n    >,\n  ];\n}\n\nfunction parseJsonPropertyKeyInternal(code: string): ParsedJsonPropertyKey {\n  const parsed = attributeParser.parse(code, false, 'partialJsonPath') as JsonPathAst | ParseError;\n  if (parsed instanceof ParseError) {\n    throw new TypeError(`Failed to parse syntax of json path. Parse error at index ${parsed.ref.start.index}:\n${code}\n${' '.repeat(parsed.ref.start.index)}^`);\n  }\n\n  const [firstKey, jsonPathNodeRaw, castOrModifiersNodeRaw] = parsed.value;\n\n  const pathSegments: Array<string | number> = [parseJsonPathSegment(firstKey)];\n\n  const jsonPathNodes = jsonPathNodeRaw.value[0]?.value[0].value;\n  if (jsonPathNodes) {\n    for (const pathNode of jsonPathNodes) {\n      pathSegments.push(parseJsonPathSegment(pathNode));\n    }\n  }\n\n  const castOrModifierNodes = castOrModifiersNodeRaw.value[0]?.value[0].value;\n  const castsAndModifiers: Array<string | Class<DialectAwareFn>> = [];\n\n  if (castOrModifierNodes) {\n    // casts & modifiers can be chained, the last one is applied last\n    // foo:upper:lower needs to produce LOWER(UPPER(foo))\n    for (const castOrModifierNode of castOrModifierNodes) {\n      if (castOrModifierNode.type === 'cast') {\n        castsAndModifiers.push(castOrModifierNode.value);\n        continue;\n      }\n\n      const ModifierClass = getModifier(castOrModifierNode.value);\n\n      castsAndModifiers.push(ModifierClass);\n    }\n  }\n\n  return { pathSegments, castsAndModifiers };\n}\n\nfunction parseJsonPathSegment(node: StringNode<string>): string | number {\n  if (node.type === 'indexAccess') {\n    return Number(node.value);\n  }\n\n  return node.value;\n}\n"],
  "mappings": "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",
  "names": ["memoize"]
}
