{
  "version": 3,
  "sources": ["../../src/utils/check.ts"],
  "sourcesContent": ["import { isIterable } from '@sequelize/utils';\nimport pickBy from 'lodash/pickBy';\nimport type { AbstractDialect } from '../abstract-dialect/dialect.js';\n\n/**\n * Some dialects emit an Error with a string code, that are not ErrnoException.\n * This serves as a more generic check for those cases.\n *\n * @param val The value to check\n */\nexport function isErrorWithStringCode(val: unknown): val is Error & { code: string } {\n  return (\n    val instanceof Error &&\n    // @ts-expect-error -- 'code' doesn't exist on Error, but it's dynamically added by Node\n    typeof val.code === 'string'\n  );\n}\n\nexport function isDevEnv(): boolean {\n  return process.env.NODE_ENV !== 'production';\n}\n\n/**\n * For use in per-dialect implementation of methods to warn the user when they use an option that TypeScript declares as valid,\n * but that the dialect they use does not support.\n *\n * @param methodName The name of the method that received the options\n * @param dialect The dialect to which the implementation belongs\n * @param allSupportableOptions All options that this method *can* support. The ones that are declared in TypeScript typings.\n * @param supportedOptions The subset of options that this dialect *actually does* support.\n * @param receivedOptions The user provided options passed to the method.\n */\nexport function rejectInvalidOptions<T extends string>(\n  methodName: string,\n  dialect: AbstractDialect,\n  allSupportableOptions: Set<T>,\n  supportedOptions: Iterable<T> | Partial<Record<T, boolean>>,\n  receivedOptions: object,\n): void {\n  const receivedOptionNames = Object.keys(\n    // This removes any undefined or false values from the object\n    // It is therefore _essential_ that boolean options are false by default!\n    pickBy(receivedOptions, value => value !== undefined && value !== false),\n  );\n  const parsedSupportedOptions = parseSupportedOptions(dialect, methodName, supportedOptions);\n\n  const unsupportedOptions = receivedOptionNames.filter(optionName => {\n    return allSupportableOptions.has(optionName as T) && !parsedSupportedOptions.has(optionName);\n  });\n\n  if (unsupportedOptions.length > 0) {\n    throw buildInvalidOptionReceivedError(methodName, dialect.name, unsupportedOptions);\n  }\n}\n\nconst SUPPORTED_OPTIONS_CACHE = new WeakMap<AbstractDialect, Map<string, Set<string>>>();\n\nfunction parseSupportedOptions(\n  dialect: AbstractDialect,\n  methodName: string,\n  rawSupportedOptions: Iterable<string> | Partial<Record<string, boolean>>,\n): Set<string> {\n  let dialectCache = SUPPORTED_OPTIONS_CACHE.get(dialect);\n  if (!dialectCache) {\n    dialectCache = new Map();\n    SUPPORTED_OPTIONS_CACHE.set(dialect, dialectCache);\n  }\n\n  let supportedOptions: Set<string> | undefined = dialectCache.get(methodName);\n  if (!supportedOptions) {\n    if (isIterable(rawSupportedOptions)) {\n      supportedOptions = new Set(rawSupportedOptions);\n    } else {\n      supportedOptions = new Set();\n      for (const optionName of Object.keys(rawSupportedOptions)) {\n        if (rawSupportedOptions[optionName]) {\n          supportedOptions.add(optionName);\n        }\n      }\n    }\n\n    dialectCache.set(methodName, supportedOptions);\n  }\n\n  return supportedOptions;\n}\n\nexport function buildInvalidOptionReceivedError(\n  methodName: string,\n  dialectName: string,\n  invalidOptions: string[],\n): Error {\n  return new Error(\n    `The following options are not supported by ${methodName} in ${dialectName}: ${invalidOptions.join(', ')}`,\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA2B;AAC3B,oBAAmB;AASZ,SAAS,sBAAsB,KAA+C;AACnF,SACE,eAAe;AAAA,EAEf,OAAO,IAAI,SAAS;AAExB;AAEO,SAAS,WAAoB;AAClC,SAAO;AACT;AAYO,SAAS,qBACd,YACA,SACA,uBACA,kBACA,iBACM;AACN,QAAM,sBAAsB,OAAO;AAAA;AAAA;AAAA,QAGjC,cAAAA,SAAO,iBAAiB,WAAS,UAAU,UAAa,UAAU,KAAK;AAAA,EACzE;AACA,QAAM,yBAAyB,sBAAsB,SAAS,YAAY,gBAAgB;AAE1F,QAAM,qBAAqB,oBAAoB,OAAO,gBAAc;AAClE,WAAO,sBAAsB,IAAI,UAAe,KAAK,CAAC,uBAAuB,IAAI,UAAU;AAAA,EAC7F,CAAC;AAED,MAAI,mBAAmB,SAAS,GAAG;AACjC,UAAM,gCAAgC,YAAY,QAAQ,MAAM,kBAAkB;AAAA,EACpF;AACF;AAEA,MAAM,0BAA0B,oBAAI,QAAmD;AAEvF,SAAS,sBACP,SACA,YACA,qBACa;AACb,MAAI,eAAe,wBAAwB,IAAI,OAAO;AACtD,MAAI,CAAC,cAAc;AACjB,mBAAe,oBAAI,IAAI;AACvB,4BAAwB,IAAI,SAAS,YAAY;AAAA,EACnD;AAEA,MAAI,mBAA4C,aAAa,IAAI,UAAU;AAC3E,MAAI,CAAC,kBAAkB;AACrB,YAAI,yBAAW,mBAAmB,GAAG;AACnC,yBAAmB,IAAI,IAAI,mBAAmB;AAAA,IAChD,OAAO;AACL,yBAAmB,oBAAI,IAAI;AAC3B,iBAAW,cAAc,OAAO,KAAK,mBAAmB,GAAG;AACzD,YAAI,oBAAoB,UAAU,GAAG;AACnC,2BAAiB,IAAI,UAAU;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAEA,iBAAa,IAAI,YAAY,gBAAgB;AAAA,EAC/C;AAEA,SAAO;AACT;AAEO,SAAS,gCACd,YACA,aACA,gBACO;AACP,SAAO,IAAI;AAAA,IACT,8CAA8C,iBAAiB,gBAAgB,eAAe,KAAK,IAAI;AAAA,EACzG;AACF;",
  "names": ["pickBy"]
}
