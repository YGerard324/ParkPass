{
  "version": 3,
  "sources": ["../src/sql-string.ts"],
  "sourcesContent": ["import type { AbstractDataType } from './abstract-dialect/data-types.js';\nimport type { AbstractDialect } from './abstract-dialect/dialect.js';\nimport * as DataTypes from './data-types';\nimport { logger } from './utils/logger';\n\nconst textDataTypeMap = new Map<string, AbstractDataType<any>>();\nexport function getTextDataTypeForDialect(dialect: AbstractDialect): AbstractDataType<any> {\n  let type = textDataTypeMap.get(dialect.name);\n  if (type == null) {\n    type = new DataTypes.STRING().toDialectDataType(dialect);\n    textDataTypeMap.set(dialect.name, type);\n  }\n\n  return type;\n}\n\nexport function bestGuessDataTypeOfVal(\n  val: unknown,\n  dialect: AbstractDialect,\n): AbstractDataType<any> {\n  // TODO: cache simple types\n  switch (typeof val) {\n    case 'bigint':\n      return new DataTypes.BIGINT().toDialectDataType(dialect);\n\n    case 'number': {\n      if (Number.isSafeInteger(val)) {\n        return new DataTypes.INTEGER().toDialectDataType(dialect);\n      }\n\n      return new DataTypes.FLOAT().toDialectDataType(dialect);\n    }\n\n    case 'boolean':\n      return new DataTypes.BOOLEAN().toDialectDataType(dialect);\n\n    case 'object':\n      if (Array.isArray(val)) {\n        if (val.length === 0) {\n          throw new Error(\n            `Could not guess type of value ${logger.inspect(val)} because it is an empty array`,\n          );\n        }\n\n        return new DataTypes.ARRAY(bestGuessDataTypeOfVal(val[0], dialect)).toDialectDataType(\n          dialect,\n        );\n      }\n\n      if (val instanceof Date) {\n        return new DataTypes.DATE(3).toDialectDataType(dialect);\n      }\n\n      if (Buffer.isBuffer(val)) {\n        // TODO: remove dialect-specific hack\n        if (dialect.name === 'ibmi') {\n          return new DataTypes.STRING().toDialectDataType(dialect);\n        }\n\n        return new DataTypes.BLOB().toDialectDataType(dialect);\n      }\n\n      break;\n\n    case 'string':\n      return getTextDataTypeForDialect(dialect);\n\n    default:\n  }\n\n  throw new TypeError(`Could not guess type of value ${logger.inspect(val)}`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,gBAA2B;AAC3B,oBAAuB;AAEvB,MAAM,kBAAkB,oBAAI,IAAmC;AACxD,SAAS,0BAA0B,SAAiD;AACzF,MAAI,OAAO,gBAAgB,IAAI,QAAQ,IAAI;AAC3C,MAAI,QAAQ,MAAM;AAChB,WAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AACvD,oBAAgB,IAAI,QAAQ,MAAM,IAAI;AAAA,EACxC;AAEA,SAAO;AACT;AAEO,SAAS,uBACd,KACA,SACuB;AAEvB,UAAQ,OAAO,KAAK;AAAA,IAClB,KAAK;AACH,aAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AAAA,IAEzD,KAAK,UAAU;AACb,UAAI,OAAO,cAAc,GAAG,GAAG;AAC7B,eAAO,IAAI,UAAU,QAAQ,EAAE,kBAAkB,OAAO;AAAA,MAC1D;AAEA,aAAO,IAAI,UAAU,MAAM,EAAE,kBAAkB,OAAO;AAAA,IACxD;AAAA,IAEA,KAAK;AACH,aAAO,IAAI,UAAU,QAAQ,EAAE,kBAAkB,OAAO;AAAA,IAE1D,KAAK;AACH,UAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,YAAI,IAAI,WAAW,GAAG;AACpB,gBAAM,IAAI;AAAA,YACR,iCAAiC,qBAAO,QAAQ,GAAG;AAAA,UACrD;AAAA,QACF;AAEA,eAAO,IAAI,UAAU,MAAM,uBAAuB,IAAI,CAAC,GAAG,OAAO,CAAC,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAEA,UAAI,eAAe,MAAM;AACvB,eAAO,IAAI,UAAU,KAAK,CAAC,EAAE,kBAAkB,OAAO;AAAA,MACxD;AAEA,UAAI,OAAO,SAAS,GAAG,GAAG;AAExB,YAAI,QAAQ,SAAS,QAAQ;AAC3B,iBAAO,IAAI,UAAU,OAAO,EAAE,kBAAkB,OAAO;AAAA,QACzD;AAEA,eAAO,IAAI,UAAU,KAAK,EAAE,kBAAkB,OAAO;AAAA,MACvD;AAEA;AAAA,IAEF,KAAK;AACH,aAAO,0BAA0B,OAAO;AAAA,IAE1C;AAAA,EACF;AAEA,QAAM,IAAI,UAAU,iCAAiC,qBAAO,QAAQ,GAAG,GAAG;AAC5E;",
  "names": []
}
