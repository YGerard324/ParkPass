{
  "version": 3,
  "sources": ["../../../src/decorators/legacy/associations.ts"],
  "sourcesContent": ["import { EMPTY_ARRAY, isString } from '@sequelize/utils';\nimport { inspect } from 'node:util';\nimport type { MaybeForwardedModelStatic } from '../../associations/helpers.js';\nimport { AssociationSecret, getForwardedModel } from '../../associations/helpers.js';\nimport type {\n  AssociationOptions,\n  BelongsToManyOptions,\n  BelongsToOptions,\n  HasManyOptions,\n  HasOneOptions,\n} from '../../associations/index.js';\nimport {\n  BelongsToAssociation,\n  BelongsToManyAssociation,\n  HasManyAssociation,\n  HasOneAssociation,\n} from '../../associations/index.js';\nimport type { AttributeNames, Model, ModelStatic } from '../../model.js';\nimport type { Sequelize } from '../../sequelize.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport { throwMustBeInstanceProperty, throwMustBeModel } from './decorator-utils.js';\n\nexport type AssociationType = 'BelongsTo' | 'HasOne' | 'HasMany' | 'BelongsToMany';\n\ninterface RegisteredAssociation {\n  type: AssociationType;\n  associationName: string;\n  source: ModelStatic;\n  target: MaybeForwardedModelStatic;\n  options: AssociationOptions;\n}\n\nconst registeredAssociations = new WeakMap<ModelStatic, RegisteredAssociation[]>();\n\nfunction decorateAssociation(\n  type: AssociationType,\n  source: Object,\n  target: MaybeForwardedModelStatic,\n  associationName: string | symbol,\n  options: AssociationOptions,\n): void {\n  if (typeof source === 'function') {\n    throwMustBeInstanceProperty(type, source, associationName);\n  }\n\n  const sourceClass = source.constructor;\n  if (!isModelStatic(sourceClass)) {\n    throwMustBeModel(type, source, associationName);\n  }\n\n  if (typeof associationName === 'symbol') {\n    throw new TypeError(\n      'Symbol associations are not currently supported. We welcome a PR that implements this feature.',\n    );\n  }\n\n  if (options.as) {\n    throw new Error(\n      'The \"as\" option is not allowed when using association decorators. The name of the decorated field is used as the association name.',\n    );\n  }\n\n  const associations = registeredAssociations.get(sourceClass) ?? [];\n  registeredAssociations.set(sourceClass, associations);\n\n  associations.push({ source: sourceClass, target, options, associationName, type });\n}\n\nexport function HasOne<Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey:\n    | Omit<HasOneOptions<string, AttributeNames<Target>>, 'as'>\n    | AttributeNames<Target>,\n) {\n  return (source: Model, associationName: string | symbol) => {\n    const options = isString(optionsOrForeignKey)\n      ? { foreignKey: optionsOrForeignKey }\n      : optionsOrForeignKey;\n\n    decorateAssociation('HasOne', source, target, associationName, options);\n  };\n}\n\nexport function HasMany<Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey:\n    | Omit<HasManyOptions<string, AttributeNames<Target>>, 'as'>\n    | AttributeNames<Target>,\n) {\n  return (source: Model, associationName: string | symbol) => {\n    const options = isString(optionsOrForeignKey)\n      ? { foreignKey: optionsOrForeignKey }\n      : optionsOrForeignKey;\n\n    decorateAssociation('HasMany', source, target, associationName, options);\n  };\n}\n\nexport function BelongsTo<SourceKey extends string, Target extends Model>(\n  target: MaybeForwardedModelStatic<Target>,\n  optionsOrForeignKey: Omit<BelongsToOptions<SourceKey, AttributeNames<Target>>, 'as'> | SourceKey,\n) {\n  return (\n    // Ideally we'd type this in a way that enforces that the sourceKey is an attribute of the source model,\n    // but that does not work when the model itself receives its attributes as a generic parameter.\n    // We'll revisit this when we have a better solution.\n    // source: Model<{ [key in SourceKey]: any }>,\n    source: Model,\n    associationName: string,\n  ) => {\n    const options = isString(optionsOrForeignKey)\n      ? { foreignKey: optionsOrForeignKey }\n      : optionsOrForeignKey;\n\n    decorateAssociation('BelongsTo', source, target, associationName, options);\n  };\n}\n\nexport function BelongsToMany(\n  target: MaybeForwardedModelStatic,\n  options: Omit<BelongsToManyOptions, 'as'>,\n): PropertyDecorator {\n  return (source: Object, associationName: string | symbol) => {\n    decorateAssociation('BelongsToMany', source, target, associationName, options);\n  };\n}\n\nexport function initDecoratedAssociations(source: ModelStatic, sequelize: Sequelize): void {\n  const associations = getDeclaredAssociations(source);\n\n  if (!associations.length) {\n    return;\n  }\n\n  for (const association of associations) {\n    const { type, target: targetGetter, associationName } = association;\n    const options: AssociationOptions = { ...association.options, as: associationName };\n\n    const target = getForwardedModel(targetGetter, sequelize);\n\n    switch (type) {\n      case 'BelongsTo':\n        BelongsToAssociation.associate(\n          AssociationSecret,\n          source,\n          target,\n          options as BelongsToOptions<string, string>,\n        );\n        break;\n      case 'HasOne':\n        HasOneAssociation.associate(\n          AssociationSecret,\n          source,\n          target,\n          options as HasOneOptions<string, string>,\n        );\n        break;\n      case 'HasMany':\n        HasManyAssociation.associate(\n          AssociationSecret,\n          source,\n          target,\n          options as HasManyOptions<string, string>,\n        );\n        break;\n      case 'BelongsToMany':\n        BelongsToManyAssociation.associate(\n          AssociationSecret,\n          source,\n          target,\n          options as BelongsToManyOptions,\n        );\n        break;\n      default:\n        throw new Error(`Unknown association type: ${type}`);\n    }\n  }\n}\n\nfunction getDeclaredAssociations(model: ModelStatic): readonly RegisteredAssociation[] {\n  const associations: readonly RegisteredAssociation[] =\n    registeredAssociations.get(model) ?? EMPTY_ARRAY;\n\n  const parentModel = Object.getPrototypeOf(model);\n  if (isModelStatic(parentModel)) {\n    const parentAssociations = getDeclaredAssociations(parentModel);\n\n    for (const parentAssociation of parentAssociations) {\n      if (parentAssociation.type !== 'BelongsTo') {\n        throw new Error(\n          `Models that use @HasOne, @HasMany, or @BelongsToMany associations cannot be inherited from, as they would add conflicting foreign keys on the target model.\nOnly @BelongsTo associations can be inherited, as it will add the foreign key on the source model.\nRemove the ${parentAssociation.type} association ${inspect(parentAssociation.associationName)} from model ${inspect(parentModel.name)} to fix this error.`,\n        );\n      }\n\n      if ('inverse' in parentAssociation.options) {\n        throw new Error(\n          `Models that use @BelongsTo associations with the \"inverse\" option cannot be inherited from, as they would add conflicting associations on the target model.\nOnly @BelongsTo associations without the \"inverse\" option can be inherited, as they do not declare an association on the target model.\nRemove the \"inverse\" option from association ${inspect(parentAssociation.associationName)} on model ${inspect(parentModel.name)} to fix this error.`,\n        );\n      }\n    }\n\n    return [...parentAssociations, ...associations];\n  }\n\n  return associations;\n}\n"],
  "mappings": "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",
  "names": []
}
