{
  "version": 3,
  "sources": ["../../../src/decorators/legacy/decorator-utils.ts"],
  "sourcesContent": ["export type PropertyOrGetterDescriptor = (\n  target: Object,\n  propertyName: string | symbol,\n  propertyDescriptor?: PropertyDescriptor,\n) => void;\n\nexport interface OptionalParameterizedPropertyDecorator<T> {\n  // @Decorator()\n  (): PropertyOrGetterDescriptor;\n  // @Decorator(value)\n  (options: T): PropertyOrGetterDescriptor;\n  // @Decorator\n  (target: Object, propertyName: string | symbol, propertyDescriptor?: PropertyDescriptor): void;\n}\n\nexport interface RequiredParameterizedPropertyDecorator<T> {\n  // @Decorator(value)\n  (options: T): PropertyOrGetterDescriptor;\n}\n\nexport const DECORATOR_NO_DEFAULT = Symbol('DECORATOR_NO_DEFAULT');\n\n/**\n * Creates a decorator that MUST receive a parameter\n *\n * @param name\n * @param callback The callback that will be executed once the decorator is applied.\n */\nexport function createParameterizedPropertyDecorator<T>(\n  name: string,\n  callback: (\n    option: T,\n    target: Object,\n    propertyName: string | symbol,\n    propertyDescriptor: PropertyDescriptor | undefined,\n  ) => void,\n): RequiredParameterizedPropertyDecorator<T> {\n  return createOptionallyParameterizedPropertyDecorator(name, DECORATOR_NO_DEFAULT, callback);\n}\n\n/**\n * Creates a decorator that can optionally receive a parameter\n *\n * @param name\n * @param defaultValue The value to use if no parameter is provided.\n * @param callback The callback that will be executed once the decorator is applied.\n */\nexport function createOptionallyParameterizedPropertyDecorator<T>(\n  name: string,\n  defaultValue: T | typeof DECORATOR_NO_DEFAULT,\n  callback: (\n    option: T,\n    target: Object,\n    propertyName: string | symbol,\n    propertyDescriptor: PropertyDescriptor | undefined,\n  ) => void,\n): OptionalParameterizedPropertyDecorator<T> {\n  return function decorator(...args: [] | [options: T] | Parameters<PropertyOrGetterDescriptor>) {\n    // note: cannot use <= 1, because TypeScript uses this to infer the type of \"args\".\n    if (args.length === 0 || args.length === 1) {\n      return function parameterizedDecorator(\n        target: Object,\n        propertyName: string | symbol,\n        propertyDescriptor?: PropertyDescriptor | undefined,\n      ) {\n        const value = args[0] ?? defaultValue;\n        if (value === DECORATOR_NO_DEFAULT) {\n          throw new Error(\n            `Decorator @${name} requires an argument (used on ${getPropertyName(target, propertyName)})`,\n          );\n        }\n\n        callback(\n          value,\n          target,\n          propertyName,\n          propertyDescriptor ?? Object.getOwnPropertyDescriptor(target, propertyName),\n        );\n      };\n    }\n\n    if (defaultValue === DECORATOR_NO_DEFAULT) {\n      throw new Error(\n        `Decorator @${name} requires an argument (used on ${getPropertyName(args[0], args[1])})`,\n      );\n    }\n\n    callback(\n      defaultValue,\n      args[0],\n      args[1],\n      args[2] ?? Object.getOwnPropertyDescriptor(args[0], args[1]),\n    );\n\n    // this method only returns something if args.length === 1, but typescript doesn't understand it\n    return undefined as unknown as PropertyOrGetterDescriptor;\n  };\n}\n\nexport function throwMustBeStaticProperty(\n  decoratorName: string,\n  target: Object,\n  propertyName: string | symbol,\n): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is an instance property. This decorator can only be used on static properties, setters and getters.`,\n  );\n}\n\nexport function throwMustBeModel(\n  decoratorName: string,\n  target: Object,\n  propertyName: string | symbol,\n): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, but class \"${getClassName(target)}\" does not extend Model. This decorator can only be used on models.`,\n  );\n}\n\nexport function throwMustBeInstanceProperty(\n  decoratorName: string,\n  target: Object,\n  propertyName: string | symbol,\n): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is static. This decorator can only be used on instance properties, setters and getters.`,\n  );\n}\n\nexport function throwMustBeMethod(\n  decoratorName: string,\n  target: Object,\n  propertyName: string | symbol,\n): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is not a method. This decorator can only be used on methods.`,\n  );\n}\n\nexport function throwMustBeAttribute(\n  decoratorName: string,\n  target: Object,\n  propertyName: string | symbol,\n): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is a symbol field. Symbol Model Attributes are not currently supported. We welcome a PR that implements this feature.`,\n  );\n}\n\nexport function getPropertyName(obj: object, property: string | symbol): string {\n  if (typeof obj === 'function') {\n    return `${obj.name}.${String(property)}`;\n  }\n\n  return `${obj.constructor.name}#${String(property)}`;\n}\n\nexport function getClassName(obj: object): string {\n  if (typeof obj === 'function') {\n    return obj.name;\n  }\n\n  return obj.constructor.name;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,MAAM,uBAAuB,OAAO,sBAAsB;AAQ1D,SAAS,qCACd,MACA,UAM2C;AAC3C,SAAO,+CAA+C,MAAM,sBAAsB,QAAQ;AAC5F;AASO,SAAS,+CACd,MACA,cACA,UAM2C;AAC3C,SAAO,SAAS,aAAa,MAAkE;AAE7F,QAAI,KAAK,WAAW,KAAK,KAAK,WAAW,GAAG;AAC1C,aAAO,SAAS,uBACd,QACA,cACA,oBACA;AACA,cAAM,QAAQ,KAAK,CAAC,KAAK;AACzB,YAAI,UAAU,sBAAsB;AAClC,gBAAM,IAAI;AAAA,YACR,cAAc,sCAAsC,gBAAgB,QAAQ,YAAY;AAAA,UAC1F;AAAA,QACF;AAEA;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA,sBAAsB,OAAO,yBAAyB,QAAQ,YAAY;AAAA,QAC5E;AAAA,MACF;AAAA,IACF;AAEA,QAAI,iBAAiB,sBAAsB;AACzC,YAAM,IAAI;AAAA,QACR,cAAc,sCAAsC,gBAAgB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,MACtF;AAAA,IACF;AAEA;AAAA,MACE;AAAA,MACA,KAAK,CAAC;AAAA,MACN,KAAK,CAAC;AAAA,MACN,KAAK,CAAC,KAAK,OAAO,yBAAyB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAC7D;AAGA,WAAO;AAAA,EACT;AACF;AAEO,SAAS,0BACd,eACA,QACA,cACO;AACP,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,iBACd,eACA,QACA,cACO;AACP,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY,iBAAiB,aAAa,MAAM;AAAA,EAC1H;AACF;AAEO,SAAS,4BACd,eACA,QACA,cACO;AACP,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,kBACd,eACA,QACA,cACO;AACP,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,qBACd,eACA,QACA,cACO;AACP,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,gBAAgB,KAAa,UAAmC;AAC9E,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,GAAG,IAAI,QAAQ,OAAO,QAAQ;AAAA,EACvC;AAEA,SAAO,GAAG,IAAI,YAAY,QAAQ,OAAO,QAAQ;AACnD;AAEO,SAAS,aAAa,KAAqB;AAChD,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,IAAI;AAAA,EACb;AAEA,SAAO,IAAI,YAAY;AACzB;",
  "names": []
}
