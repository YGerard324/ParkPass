{
  "version": 3,
  "sources": ["../src/model-set-view.ts"],
  "sourcesContent": ["import { map, SetView } from '@sequelize/utils';\nimport { inspect } from 'node:util';\n// @ts-expect-error -- toposort-class definition will be added to sequelize/toposort later\nimport Toposort from 'toposort-class';\nimport type { AbstractDialect } from './abstract-dialect/dialect.js';\nimport type { Model, ModelStatic } from './model';\nimport type { SequelizeTypeScript } from './sequelize-typescript.js';\n\nexport class ModelSetView<Dialect extends AbstractDialect> extends SetView<ModelStatic> {\n  readonly #sequelize: SequelizeTypeScript<Dialect>;\n\n  constructor(sequelize: SequelizeTypeScript<Dialect>, set: Set<ModelStatic>) {\n    super(set);\n\n    this.#sequelize = sequelize;\n  }\n\n  get<M extends Model = Model>(modelName: string): ModelStatic<M> | undefined {\n    return this.find(model => model.modelDefinition.modelName === modelName) as\n      | ModelStatic<M>\n      | undefined;\n  }\n\n  getOrThrow<M extends Model = Model>(modelName: string): ModelStatic<M> {\n    const model = this.get<M>(modelName);\n\n    if (!model) {\n      throw new Error(`Model ${inspect(modelName)} was not added to this Sequelize instance.`);\n    }\n\n    return model;\n  }\n\n  /**\n   * Returns the list of registered model names.\n   */\n  getNames(): Iterable<string> {\n    return map(this, model => model.modelDefinition.modelName);\n  }\n\n  hasByName(modelName: string): boolean {\n    return this.get(modelName) !== undefined;\n  }\n\n  /**\n   * Returns an array that lists every model, sorted in order\n   * of foreign key references: The first model is a model that is depended upon,\n   * the last model is a model that is not depended upon.\n   *\n   * If there is a cyclic dependency, this returns null.\n   */\n  getModelsTopoSortedByForeignKey(): ModelStatic[] | null {\n    const models = new Map();\n    const sorter = new Toposort();\n\n    const queryGenerator = this.#sequelize.queryGenerator;\n\n    for (const model of this) {\n      let deps = [];\n      const tableName = queryGenerator.quoteTable(model);\n\n      models.set(tableName, model);\n\n      const { attributes } = model.modelDefinition;\n      for (const attrName of attributes.keys()) {\n        const attribute = attributes.get(attrName);\n\n        if (!attribute?.references) {\n          continue;\n        }\n\n        const dep = queryGenerator.quoteTable(attribute.references.table);\n        deps.push(dep);\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (error: unknown) {\n      if (error instanceof Error && !error.message.startsWith('Cyclic dependency found.')) {\n        throw error;\n      }\n\n      return null;\n    }\n\n    return sorted\n      .map((modelName: string) => {\n        return models.get(modelName);\n      })\n      .filter(Boolean);\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables.\n   * Will take foreign key constraints into account so that dependencies are visited before dependents.\n   *\n   * @param iterator method to execute on each model\n   * @param options\n   * @param options.reverse\n   * @private\n   *\n   * @deprecated\n   */\n  forEachModel(iterator: (model: ModelStatic) => void, options?: { reverse?: boolean }) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error('Cyclic dependency found.');\n    }\n\n    // TODO: options should be false by default\n    const reverse = options?.reverse ?? true;\n\n    if (reverse) {\n      sortedModels.reverse();\n    }\n\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA6B;AAC7B,uBAAwB;AAExB,4BAAqB;AAKd,MAAM,qBAAsD,qBAAqB;AAAA,EAC7E;AAAA,EAET,YAAY,WAAyC,KAAuB;AAC1E,UAAM,GAAG;AAET,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,IAA6B,WAA+C;AAC1E,WAAO,KAAK,KAAK,WAAS,MAAM,gBAAgB,cAAc,SAAS;AAAA,EAGzE;AAAA,EAEA,WAAoC,WAAmC;AACrE,UAAM,QAAQ,KAAK,IAAO,SAAS;AAEnC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,aAAS,0BAAQ,SAAS,6CAA6C;AAAA,IACzF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,WAA6B;AAC3B,eAAO,kBAAI,MAAM,WAAS,MAAM,gBAAgB,SAAS;AAAA,EAC3D;AAAA,EAEA,UAAU,WAA4B;AACpC,WAAO,KAAK,IAAI,SAAS,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,kCAAwD;AACtD,UAAM,SAAS,oBAAI,IAAI;AACvB,UAAM,SAAS,IAAI,sBAAAA,QAAS;AAE5B,UAAM,iBAAiB,KAAK,WAAW;AAEvC,eAAW,SAAS,MAAM;AACxB,UAAI,OAAO,CAAC;AACZ,YAAM,YAAY,eAAe,WAAW,KAAK;AAEjD,aAAO,IAAI,WAAW,KAAK;AAE3B,YAAM,EAAE,WAAW,IAAI,MAAM;AAC7B,iBAAW,YAAY,WAAW,KAAK,GAAG;AACxC,cAAM,YAAY,WAAW,IAAI,QAAQ;AAEzC,YAAI,CAAC,WAAW,YAAY;AAC1B;AAAA,QACF;AAEA,cAAM,MAAM,eAAe,WAAW,UAAU,WAAW,KAAK;AAChE,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,aAAO,KAAK,OAAO,SAAO,cAAc,GAAG;AAE3C,aAAO,IAAI,WAAW,IAAI;AAAA,IAC5B;AAEA,QAAI;AACJ,QAAI;AACF,eAAS,OAAO,KAAK;AAAA,IACvB,SAAS,OAAP;AACA,UAAI,iBAAiB,SAAS,CAAC,MAAM,QAAQ,WAAW,0BAA0B,GAAG;AACnF,cAAM;AAAA,MACR;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,OACJ,IAAI,CAAC,cAAsB;AAC1B,aAAO,OAAO,IAAI,SAAS;AAAA,IAC7B,CAAC,EACA,OAAO,OAAO;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,aAAa,UAAwC,SAAiC;AACpF,UAAM,eAAe,KAAK,gCAAgC;AAC1D,QAAI,gBAAgB,MAAM;AACxB,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAGA,UAAM,UAAU,SAAS,WAAW;AAEpC,QAAI,SAAS;AACX,mBAAa,QAAQ;AAAA,IACvB;AAEA,eAAW,SAAS,cAAc;AAChC,eAAS,KAAK;AAAA,IAChB;AAAA,EACF;AACF;",
  "names": ["Toposort"]
}
