{
  "version": 3,
  "sources": ["../../src/_internal/data-types-db.ts"],
  "sourcesContent": ["import { isValidTimeZone } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/dayjs.js';\nimport dayjs from 'dayjs';\nimport type { TypeCastField } from 'mysql2';\nimport wkx from 'wkx';\nimport type { MySqlDialect } from '../dialect.js';\n\n/**\n * First pass of DB value parsing: Parses based on the MySQL Type ID.\n * If a Sequelize DataType is specified, the value is then passed to {@link DataTypes.ABSTRACT#parseDatabaseValue}.\n *\n * @param dialect\n */\nexport function registerMySqlDbDataTypeParsers(dialect: MySqlDialect) {\n  /*\n   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html\n   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js\n   */\n  dialect.registerDataTypeParser(['DATETIME'], (value: TypeCastField) => {\n    const valueStr: string | null = value.string();\n    if (valueStr === null) {\n      return null;\n    }\n\n    const timeZone: string = dialect.sequelize.options.timezone;\n    if (timeZone === '+00:00') {\n      // default value\n      // mysql returns a UTC date string that looks like the following:\n      // 2022-01-01 00:00:00\n      // The above does not specify a time zone offset, so Date.parse will try to parse it as a local time.\n      // Adding +00 fixes this.\n      return `${valueStr}+00`;\n    }\n\n    if (isValidTimeZone(timeZone)) {\n      return dayjs.tz(valueStr, timeZone).toISOString();\n    }\n\n    // offset format, we can just append.\n    // \"2022-09-22 20:03:06\" with timeZone \"-04:00\"\n    // becomes \"2022-09-22 20:03:06-04:00\"\n    return valueStr + timeZone;\n  });\n\n  // dateonly\n  dialect.registerDataTypeParser(['DATE'], (value: TypeCastField) => {\n    return value.string();\n  });\n\n  // bigint\n  dialect.registerDataTypeParser(['LONGLONG'], (value: TypeCastField) => {\n    return value.string();\n  });\n\n  dialect.registerDataTypeParser(['GEOMETRY'], (value: TypeCastField) => {\n    let buffer = value.buffer();\n    // Empty buffer, MySQL doesn't support POINT EMPTY\n    // check, https://dev.mysql.com/worklog/task/?id=2381\n    if (!buffer || buffer.length === 0) {\n      return null;\n    }\n\n    // For some reason, discard the first 4 bytes\n    buffer = buffer.subarray(4);\n\n    return wkx.Geometry.parse(buffer).toGeoJSON({ shortCrs: true });\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAgC;AAChC,IAAAA,gBAAkB;AAElB,iBAAgB;AAST,SAAS,+BAA+B,SAAuB;AAKpE,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAAyB;AACrE,UAAM,WAA0B,MAAM,OAAO;AAC7C,QAAI,aAAa,MAAM;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,WAAmB,QAAQ,UAAU,QAAQ;AACnD,QAAI,aAAa,UAAU;AAMzB,aAAO,GAAG;AAAA,IACZ;AAEA,YAAI,8BAAgB,QAAQ,GAAG;AAC7B,aAAO,cAAAC,QAAM,GAAG,UAAU,QAAQ,EAAE,YAAY;AAAA,IAClD;AAKA,WAAO,WAAW;AAAA,EACpB,CAAC;AAGD,UAAQ,uBAAuB,CAAC,MAAM,GAAG,CAAC,UAAyB;AACjE,WAAO,MAAM,OAAO;AAAA,EACtB,CAAC;AAGD,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAAyB;AACrE,WAAO,MAAM,OAAO;AAAA,EACtB,CAAC;AAED,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAAyB;AACrE,QAAI,SAAS,MAAM,OAAO;AAG1B,QAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,aAAO;AAAA,IACT;AAGA,aAAS,OAAO,SAAS,CAAC;AAE1B,WAAO,WAAAC,QAAI,SAAS,MAAM,MAAM,EAAE,UAAU,EAAE,UAAU,KAAK,CAAC;AAAA,EAChE,CAAC;AACH;",
  "names": ["import_dayjs", "dayjs", "wkx"]
}
