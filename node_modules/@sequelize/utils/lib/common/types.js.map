{
  "version": 3,
  "sources": ["../../src/common/types.ts"],
  "sourcesContent": ["/**\n * Represents any plain function (no `this`)\n */\nexport type AnyFunction = (...args: any[]) => any;\n\nexport type UnknownFunction = (...args: unknown[]) => unknown;\n\n/**\n * Represents any plain object (or Record, as TypeScript calls it).\n *\n * Prefer {@link UnknownRecord} unless you're encountering issues with it.\n */\nexport type AnyRecord = Record<PropertyKey, any>;\n\n/**\n * Represents any plain object (or Record, as TypeScript calls it)\n *\n * Stricter than {@link AnyRecord}. Not all records can be assigned to this value due to how TypeScript works\n * but its usage is recommended because the value won't be typed as any.\n */\nexport type UnknownRecord = Record<PropertyKey, unknown>;\n\nexport type Nullish = null | undefined;\n\nexport type NonNullish = {};\n\n/**\n * Makes the type accept null & undefined\n */\nexport type MakeNullish<T> = T | Nullish;\n\nexport type MakeNonNullish<T> = NonNullable<T>;\n\nexport type NonUndefined<T> = T extends undefined ? never : T;\n\nexport type NonNull<T> = T extends null ? never : T;\n\nexport type NonUndefinedKeys<T, K extends keyof T> = {\n  [P in keyof T]: P extends K ? NonUndefined<T[P]> : T[P];\n};\n\nexport type AllowArray<T> = T | T[];\n\nexport type AllowIterable<T> = T | Iterable<T>;\n\nexport type AllowReadonlyArray<T> = T | readonly T[];\n\nexport type AllowPromise<T> = T | Promise<T>;\n\n/**\n * Like {@link Partial}, but also allows undefined.\n * Useful when \"exactOptionalPropertyTypes\" is enabled.\n */\nexport type PartialOrUndefined<T> = {\n  [P in keyof T]?: T[P] | undefined;\n};\n\n/**\n * Type helper for making certain fields of an object optional.\n */\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\nexport type StrictRequiredBy<T, K extends keyof T> = NonUndefinedKeys<\n  Omit<T, K> & Required<Pick<T, K>>,\n  K\n>;\n\nexport type ReadOnlyRecord<K extends PropertyKey, V> = Readonly<Record<K, V>>;\n\nexport type PartialRecord<K extends PropertyKey, V> = {\n  [P in K]?: V;\n};\n\nexport type PartialReadonlyRecord<K extends PropertyKey, V> = Readonly<PartialRecord<K, V>>;\n\nexport type Entry<Key, Value> = [key: Key, value: Value];\n\nexport type JsonArray = JsonValue[];\nexport type JsonObject = { [key: string]: JsonValue };\nexport type JsonPrimitive = string | number | boolean | null;\nexport type JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\nexport type PickByType<T, U> = { [K in keyof T as U extends T[K] ? K : never]: T[K] };\n\nexport interface ReadonlyMapLike<K, V> {\n  entries(): IterableIterator<Entry<K, V>>;\n  get(key: K): V | undefined;\n  has(key: K): boolean;\n  keys(): IterableIterator<K>;\n  readonly size: number;\n  [Symbol.iterator](): IterableIterator<Entry<K, V>>;\n  values(): IterableIterator<V>;\n}\n\nexport interface MapLike<K, V> extends ReadonlyMapLike<K, V> {\n  clear(): void;\n  delete(key: K): boolean;\n  set(key: K, value: V): this;\n}\n\nexport interface ReadonlySetLike<V> {\n  has(value: V): boolean;\n  readonly size: number;\n  [Symbol.iterator](): IterableIterator<V>;\n  values(): IterableIterator<V>;\n}\n\nexport interface SetLike<V> extends ReadonlySetLike<V> {\n  add(value: V): this;\n  clear(): void;\n  delete(value: V): boolean;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
