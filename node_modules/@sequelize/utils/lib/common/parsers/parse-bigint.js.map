{
  "version": 3,
  "sources": ["../../../src/common/parsers/parse-bigint.ts"],
  "sourcesContent": ["import { buildNullBasedParser } from '../_internal/build-parser.js';\nimport { inspect } from '../inspect.js';\nimport { isNumber } from '../predicates/is-number.js';\n\n/**\n * The base 10 regex is special because it accepts the scientific notation\n */\nconst BASE10_INTEGER_REGEX =\n  /^(?<integerStr>-?[0-9]*)(\\.(?<decimalStr>[0-9]+))?([eE](?<exponentStr>[-+]?[0-9]+))?$/;\n\nfunction parseBigIntInternal(value: string | number): bigint | null {\n  if (isNumber(value)) {\n    if (!Number.isSafeInteger(value)) {\n      return null;\n    }\n\n    return BigInt(value);\n  }\n\n  if (value === '') {\n    return null;\n  }\n\n  if (!BASE10_INTEGER_REGEX.test(value)) {\n    return null;\n  }\n\n  try {\n    return BigInt(value);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses a string as a bigint in base 10.\n *\n * Unlike {@link parseSafeInteger}, this function does not support specifying the radix; it is always base 10.\n * This method supports the scientific notation (e.g. 5e1 produces 50n).\n * The Scientific notation is only allowed in base 10.\n *\n * @param value The string to parse as a safe integer\n * @returns The corresponding bigint value\n */\nexport const parseBigInt = buildNullBasedParser(\n  parseBigIntInternal,\n  value => `Cannot convert ${inspect(value)} to a BigInt.`,\n);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAAqC;AACrC,qBAAwB;AACxB,uBAAyB;AAKzB,MAAM,uBACJ;AAEF,SAAS,oBAAoB,OAAuC;AAClE,UAAI,2BAAS,KAAK,GAAG;AACnB,QAAI,CAAC,OAAO,cAAc,KAAK,GAAG;AAChC,aAAO;AAAA,IACT;AAEA,WAAO,OAAO,KAAK;AAAA,EACrB;AAEA,MAAI,UAAU,IAAI;AAChB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,qBAAqB,KAAK,KAAK,GAAG;AACrC,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,OAAO,KAAK;AAAA,EACrB,QAAE;AACA,WAAO;AAAA,EACT;AACF;AAYO,MAAM,kBAAc;AAAA,EACzB;AAAA,EACA,WAAS,sBAAkB,wBAAQ,KAAK;AAC1C;",
  "names": []
}
