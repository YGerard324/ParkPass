{
  "version": 3,
  "sources": ["../../../src/common/_internal/build-predicate-function.ts"],
  "sourcesContent": ["export function buildAssertionFunction<AssertedType>(\n  isAssertedType: (value: unknown) => value is AssertedType,\n  buildError: (value: unknown, shouldEqual: boolean) => string,\n): [is: AssertionFunction<AssertedType>, isNot: NegatedAssertionFunction<AssertedType>] {\n  const isType = (value: unknown): value is AssertedType => {\n    return isAssertedType(value);\n  };\n\n  const isNotType = <Value>(value: Value): value is Exclude<Value, AssertedType> => {\n    return !isAssertedType(value);\n  };\n\n  isType.assert = (value: unknown, message?: string): asserts value is AssertedType => {\n    if (!isType(value)) {\n      throw new Error(message ?? buildError(value, true));\n    }\n  };\n\n  const assertIsNotType = <Value>(\n    value: Value,\n    message?: string,\n  ): asserts value is Exclude<Value, AssertedType> => {\n    if (isType(value)) {\n      throw new Error(message ?? buildError(value, false));\n    }\n  };\n\n  isNotType.assert = assertIsNotType;\n\n  return [isType, isNotType];\n}\n\nexport type AssertionTuple<AssertedType> = [\n  is: AssertionFunction<AssertedType>,\n  isNot: NegatedAssertionFunction<AssertedType>,\n];\n\nexport interface AssertionFunction<AssertedType> {\n  assert(value: unknown, message?: string): asserts value is AssertedType;\n\n  (value: unknown): value is AssertedType;\n}\n\nexport interface NegatedAssertionFunction<AssertedType> {\n  assert<Value>(value: Value, message?: string): asserts value is Exclude<Value, AssertedType>;\n\n  /**\n   * For use as a predicate callback. Prefer using `!` instead if you are not using it as a predicate.\n   *\n   * @example\n   * // exclude all strings\n   * [].filter(isNotString)\n   */\n  <Value>(value: Value): value is Exclude<Value, AssertedType>;\n}\n\nexport function toBe(validValueOrType: string) {\n  return function buildToBeErrorMessage(value: unknown, shouldEqual: boolean): string {\n    return buildErrorMessage(validValueOrType, value, shouldEqual);\n  };\n}\n\nexport function buildErrorMessage(\n  validValueOrType: string,\n  value: unknown,\n  shouldEqual: boolean,\n): string {\n  return `expected value ${shouldEqual ? '' : 'not '}to be ${validValueOrType} but got ${JSON.stringify(\n    value,\n  )} instead`;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,SAAS,uBACd,gBACA,YACsF;AACtF,QAAM,SAAS,CAAC,UAA0C;AACxD,WAAO,eAAe,KAAK;AAAA,EAC7B;AAEA,QAAM,YAAY,CAAQ,UAAwD;AAChF,WAAO,CAAC,eAAe,KAAK;AAAA,EAC9B;AAEA,SAAO,SAAS,CAAC,OAAgB,YAAoD;AACnF,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,YAAM,IAAI,MAAM,WAAW,WAAW,OAAO,IAAI,CAAC;AAAA,IACpD;AAAA,EACF;AAEA,QAAM,kBAAkB,CACtB,OACA,YACkD;AAClD,QAAI,OAAO,KAAK,GAAG;AACjB,YAAM,IAAI,MAAM,WAAW,WAAW,OAAO,KAAK,CAAC;AAAA,IACrD;AAAA,EACF;AAEA,YAAU,SAAS;AAEnB,SAAO,CAAC,QAAQ,SAAS;AAC3B;AA0BO,SAAS,KAAK,kBAA0B;AAC7C,SAAO,SAAS,sBAAsB,OAAgB,aAA8B;AAClF,WAAO,kBAAkB,kBAAkB,OAAO,WAAW;AAAA,EAC/D;AACF;AAEO,SAAS,kBACd,kBACA,OACA,aACQ;AACR,SAAO,kBAAkB,cAAc,KAAK,eAAe,4BAA4B,KAAK;AAAA,IAC1F;AAAA,EACF;AACF;",
  "names": []
}
